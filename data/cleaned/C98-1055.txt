Group Theory and Linguistic Processing* 
Mare Dymetman 
Xerox Research Centre Europe 
6, chemin de Maupertuis 
38240 Meylan, France 
Marc. Dymetman@xrce. xerox, com 
1 Introduction

There is currently much interest in bringing together 
the tradition of categorial grammar, and especially the 
Lambek calculus (Lambek, 1958), with the more recent 
paradigm of linear logic (Girard, 1987) to which it has 
strong ties. One active research area concerns the de
sign of non-commutative versions of linear logic (Abr
usci, 1991; Rdtor6, 1993) which can be sensitive to word 
order while retaining the hypothetical reasoning capabil
ities of standard (commutative) linear logic that make it 
so well-adapted to handling such phenomena as quanti
tier scoping (Dalrymple et al., 1995). 
Some connections betweeq the Lambek calculus and 
group structure have long been known (van Benthem, 
1986), and linear logic itself has some aspects strongly 
reminiscent of groups (the producer/consumer duality of 
a formula A with its linear negation A-L), but no serious 
attempt has been made so far to base a theory of linguis
tic description solely on group structure. 
This paper presents such a model, G-grammars (for 
"group grammars"), and argues that: 
• The standard group-theoretic notion of conjugacy, 
which is central in G-grammars, is well-suited to 
a unifot'm description of commutative and non
commutative aspects of language; 
• The use of conjugacy provides an elegant approach 
to long-distance dependency and scoping phenom
ena, both in parsing and in generation; 
• G-grammars give a symmetrical account of the 
semantics-phonology relation, from which it is easy 
to extract, via simple group calculations, rewriting 
systems computing this relation for the parsing and 
generation modes. 
2 Group
Computation 
A MONOID 211 is a set M together with a product 21I × 
M -+ .'tl, written (a, b) ~-~ oh, such that: 
• This product is associative; 
• There is an element i E M (the neutral element) 
with la = al = a for all a E M. 
* This paper is an abridged version of G*vup Theo O' and Gram
matical Description. TR-MLTT-033. XRCE, April 1998; available 
on the CMP-LG archive at the address: http://xxx.lanl.gov/abs/cmp
Ig/9805002. 
A GROUP is a monoid in which every element a has an 
inverse a -1 such that a-la = aa -1 = 1. 
A PREORDER Oil a set is a reflexive and transitive re
lation on this set. When the relation is also symmetrical, 
that is, R(x, y) ~ R(y, x), then the preorder is called an 
EQUIVALENCE RELATION. When it is antisymmetrical, 
that is that is,/~(x, y) A R(y, x) => x = y, it is called a 
PARTIAL ORDER. 
A preorder R on a group G will bc said to be COM
PATIBLE with the group product ill', whenever R(x, y) 
and R(x', y'), then R(xx', yy'). 
Normal submonoids of a group. We consider a com
patible preorder notated x -+ y on a group G. The fol
lowing properties, lbr any x, y E G, are immediate: 
x--+y ~ xy-~-->l; 
x ---+ y ¢=~ yl _+ x-1; 
x-+l ¢~ 1 -+ x-l; 
x -+ l ~ yxy-l --+ l, foranyyEG. 
Two elements x, x' in a group G are said to be CONJU
GATE if there exists y E G such that a :~ = yxy -~. The 
fourth property above says that the set M of elements 
x E G such that x ~ 1 is a set which contains along with 
an element all its conjugates, that is, a NORMAL subset 
of G. As 21i is clearly a submonoid of G, it will be called 
a NORMAL SUBMONOID of G. 
Conversely, it is easy to show that with any nor
real submonoid M of G one can associate a pre
order compatible with G. Indeed let's define x-+ y 
as xy -1 C 214. The relation --+ is clearly reflex
ive and transitive, hence is a preorder. It is also 
compatible with G, for if xl -+ Yi and a:2 --+ y~., then 
xlyl -t, x2y, -1 and y1(x~_y2-1)y1-1 are in M; hence 
xlx2y~-ly1-1 = xlyl-lyax2y2-1y1-1 is in 21I, im
plying that xlx2-+ Yly2, that is, that the preorder is 
compatible. I 
If S is a subset of G, the intersection of all normal 
submonoids of G containing S (resp. of all subgroups 
of G containing S) is a normal submonoid of G (resp. a 
1In general hi is not a subgroup of G. It is iff x --9 y implies 
y --9x, tbat is. if tim compatible preorder ~ is an equivalence re
lation (and, dmrefore, a CONC~RUF.NC~;) on G. When this is the case, 
M is a NORMA\[. SUBGROUI' of G. This notio,~ plays a pivotal role in 
classical algebra, its generalization to submonoids of G is basic for the 
algebraic tlmory of computation presented here. 
348 
normal subgroup of G) and is called the NORMAL SUB
MONOID CLOSURE NM(S) of ,b' in G (resp. the NOR
MAL SUBGROUP CLOSURe; NG(S) of S in G). 
The free group over V. We now consider an arbitrary 
set V, called the VOCABULARY, and we fortn the so
called SET OF ATOMS ON V, which is notated V U V -~ 
and is obtained by taking both elements ,; m V and the 
formal inverses v~ of these elements. 
We now consider the set F(V) consisting of the ctnpty 
string, notated 1, and of strings of the /brm .elx~...a:,, 
where :r~ is an atom on V. It is assumed that such a 
string is REDUCED, that is, never contains two consecu
tive atotns which are inverse of each other: no substring 
t,t,-1 or v-iv is allowed to appear in a reduced string. 
When a and fl are two reduced strings, their concate
nation aft can be t'cdttccd by eliminating all substrings of 
the form v vJ or vt v. It can bc proven that the reduced 
string 7 obtained in this way is independent of the order 
of such eliminations. In this way, a product on F(V) 
is defined, and it is easily shown tlmt F(V) becomes a 
(non-commutative) group, called the FREE GROUP over 
U (Hungerl'ord, 1974). 
Group computation. Wc will say that an ordered pair 
(;CS = (V, H) is a GROUP COMPUTATION STRUCTURE 
it': 
1. ~," is a set, called the VOCABULARY, or the set of 
GENERATORS 
2. 1~ is a subset of IV(V), called the LEXICt)N, or the 
set o\[" RELATORS. 2 
The sttbmonoid closure NM(/2) of t{ in 1:(~ ") is called 
the RESULT MONOID of the group computation structure 
Gt',',S'. The elements of NM(H) will be called COMPU
TATION RESULTS, or simply RESULTS. 
If r is a relator, and if a is an arbitrary eletnent of 
F(V), then o.m~ -1 will be called a QUASI-RELATOR of 
the group computation structure. It is easily seen that 
the set l<v of quasi-relators is equal to the nornml sub
set closure of/? in F(l'), and thai NM(HN) is equal to 
NM(/~). 
a COMPUTATION relative to (7C',5' is a tinite sequence 
c = (rt ..... t', ) of quasi-relators. The product rl • .r,~ 
in f:'(V) is evidently a result, and is called the RESULT 
OF THE COMPUTATION c. It can be shown that the result 
monoid is entirely covered in lifts way: each result is 
the result of some computation. A computation can thus 
be seen as a "witness", or as a "proof", of the fact that 
a given elelnent of F(V) is a result of the computation 
structure. 3 
For specific computation tasks, one lScusses on results 
of a certain sort, for instance results which express a re
lationship of input-output, where input and output are 
2 For
readers familiar with group theory, this termiuology will evoke 
the classical notion of group I'RESI.\]NTATION through generators and 
relators. The main difference with our detinition is that, in the classical 
case, the set of relators is taken to be symmetrical, that is, to contain 
r -1 if it contains r. When this additional asst, mption is made. our 
preorde," becomes an equivalence relation. 
3The analogy with the view in constructive logics is clear. There 
what we call a result is called a\]ormula or a type, and what we call a 
computation is called a proof 
j john -~ 
1 louise -I 
p parts 
--1 m m(I?l 
W WoDlan--1 
A -1 r (A) ra;t -1 
A -I s(A,B) B -1 saw -1 
E -q i(E,A) A -I in -I 
t {N) N -I the -1 
a' ev(N,X,P\[X\]) p\[X\]-I a-1 X N -I 
a sm(N,X,P\[X\]) P\[X\] -1 O ~-1 X N -1 
N -I tt(N,X,P\[X\]) P\[X\] -l (t -I X ct 
SOIII~Y 1 
that
Figure 1: A G-grammar for a fragment of English 
assutncd to belong to certain object types. For exam
pie, in computational linguistics, one is often interested 
in results which express a relationship between a fixed 
semantic input and a possible textual output (generation 
mode) or conversely in results which express a relation
ship between a fixed textual input and a possible seman
tic output (parsing mode). 
If GCS = (V, R) is a group computation structure, 
and if A is a given subset of F(V), then we will call 
the pair GCSA = (GCS, A) a GROUP COMPUTATION 
STRUCTURE WITH ACCEPTORS. We will say that A 
is the set of acceptors, or the PUBLIC INTERt:ACE, of 
G(WA. A result of (/CS which belongs to the public 
interface will be called a PUBLIC P, ESULT Of (/C,'~'J.. 
3 G-Grammars 
We will now show how the formal concepts introduced 
above can be applied to the pt'oblems of grammatical 
description and computation. We start by introducing 
a grammar, which we will call a G-GRAMMAR (for 
"Group Grammar"), for a fragment of English (see Fig. 
1). 
A G-grammar is a group computation structure with 
acceptors over a vocabulary V = Woo U \[vJ ..... con
sisting of a set of logical forms ~Jio.q and a disjoint 
set of phonological elements (in tl~e example, words) 
~,\]; ..... Examples of phonological elements are john, 
saw, every, examples of logical forms j, s(j, 3_), 
ev(m,x, sm(w,y, s (x,y)) ); these logical forms can 
be glossed respectively as "jolm", "john saw louise" and 
"for every man x, for some woman y, x saw y". 
The grammar lexicon, or set of relators, I{ is given as a 
list of "lexical schemes". An example is given in Fig. 1. 
Each line is a lexical scheme and represents a set of re
lators in F(V). The first line is a ground scheme, which 
corresponds to the single relator j john -1, and so arc 
the next four lines. The fifth line is a non-ground scheme, 
which corresponds to an inlinitc set of relators, obtained 
by instanciating the term meta-variable A (notated in up
percase) to a logical form. So are the remaining lines. 
We use Greek letters for expression meta-variables such 
as ~Y, which can be replaced by an arbitrary expression 
of F(V); thus, whereas the term mete-variables A, B ..... 
range over logical forms, the expression mete-variables 
a, fl ..... range over products of logical forms and phono
349 
logical elements (or their inverses) in F(V). 4 
The notation P \[x\] is employed to express the fact 
that a logical form containing an argument identifier x 
is equal to the application of the abstraction P to x. The 
recta-variable X in p \[X\] ranges over such identifiers (x, 
y, z .... ), which are notated in lower-case italics (and are 
always ground). The meta-variable p ranges over logi
cal form abstractions missing one argument (for instance 
t=. s ( j, z) ). When matching recta-variables in logical 
forms, we will allow limited use of higher-order unifica
tion. For instance, one can match P\[X\] to s (j ,x) by 
taking P = Az.s(j, z) and X = x. 
The vocabulary and the set of relators that we have just 
specified define a group computation structure GCS = 
(U, R). We will now describe a set of acceptors A for 
this computation structure. We take A to be the set of 
elements of F(V) which are products of the following 
form: 
S \[Vn -1 l/V,,-1-1 ... IV1-1 
where S is a logical form (S stands for "semantics"), 
and where each I14 is a phonological element (W stands 
for "'word"). The expression above is a way of encoding 
the ordered pair consisting of the logical form S and the 
phonological string I I1 l I:: ... \[~\]~ (tlmt is, the inverse of 
tim product l\[~z -1 \[15~_1-1 ... l'\[71--1). 
A public result SI4';,-1\[V,,_1-1 ...lV1-1 in the 
group computation structure with acceptors ((V, R), A) 
-the G-grammar --will be interpreted as meaning that 
the logical form S can be expressed as the phonological 
string IVI l'\['~ . . . \['I~. 
Let us give an example of a public result relative to the 
grammar of Fig. 1. 
We consider the relators (instanciations of relator 
schemes): 
rl : j-1 s(j,1) 
r, : 1 louise -1 
r3 : j john-Z 
\]_1 saw1 
and the quasi-relators: 
'--1 rl' = j rl 3 
r2' = (j saw) r2 
r3 ' : r3 
(J saw) -1 
Then we have: 
r I ' r2 , \]5 3 , = 
j j-i s(j,l) 1-i saw-I j-1 
j saw 1 louise-1 saw-! j-z 
j john-1 = s (j , t) louise-1 sawZ john-1 
which means that s (j, 1 ) louise-lsaw-Xjolm -1 is the 
result of a computation (rl ', r2 ', r3 ' ). This result 
is obviously a public one, which means tlmt the logi
cal form s ( j, 1 ) can be verbalized as the phonological 
string john saw louise. 
4 Expression
meta-variables are employed in the grammar for form
ing the set of conjugates c~ ea:p oe -1 of certain expressions eocp (in 
our example, exp is ev(N,X,P\[X\]) P\[X\] -1, sm{N,X,P\[X\]) 
P \[X\] -a, or X). Conjugacy allows the enclosed material exp to move 
as u block in expressions of F(V). see sections 3. and 4. 
j --~ john 
1 --~ louise 
p --~ paris 
m -~ I;~(lrl 
W --~ woman 
r (A) ~ A ran 
s(A,B) -~ A saw B 
i(E,A) ~E in A 
t(N) -~ the N 
ev(N,X, P\[X\] ) -~ 
sm(N,X,P\[X\]) -~ 
tt(N,X,P\[X\] ) -~ 
ce -~ eve O' N X -z cr P\[X\] 
ct -1 some N X -1 oe P\[X\] 
N that a '-1 x -1 ee P\[X\] 
Figure 2: Generation-oriented rules 
4 Generation

Applying directly, as we have just done, the definition of 
a group computation structure in order to obtain public 
results can be somewhat unintuitive. It is often easier to 
use the preorder --+. If, for a, b, c E F(V), abe is a rela
tor, then abe -+ 1, and therefore b -+ a1 c1. Taking this 
remark into account, it is possible to write the relators of 
our G-grammar as the rewrmn~ rules of Fig. 2; we use 
the notation ~ instead of --+ to distinguish these rules 
from the parsing rules which will be introduced in the 
next section. 
The rules of Fig. 2 have a systematic structure. The 
left-hand side of each rule consists of a single logical 
form, taken from the corresponding relator in the G
grammar; the right-hand side is obtained by "moving" 
all the remaining elements in the relator to the right of 
the arrow. 
Because the rules of Fig. 2 privilege the rewriting of 
a logical form into an expression of F(V), they are 
called generation-oriented rules associated with the G
grammar. 
Using these rules, and the fact that the preorder --, 
is compatible with the product of F(V), the fact that 
s ( J, 1 ) louise1sawl john1 is a public result can be 
obtained in a simpler way than previously. We have: 
s(j,1) 
j --" john 
1 ~ louise 
j saw 1 
by the seventh, first and second rules (properly instanci
ated), and therefore, by transitivity and compatibility of 
the preorder: 
s(j,1) --x j saw 1 
--~ john saw 1 -~ john saw louise 
which proves that s (j, 1) --~john saw louise, 
which is equivalent to saying that s (j, 1) 
louiset ~a,vl john1 is a public result. 
Some other generation examples are given in Fig. 3. 
The first example is straightforward and works simi
larly to the one we have just seen: from the logical form 
i (s (j, 1) , p) one can derive the phonological string 
john saw louise in paris. 
350 
i(s(j,l) ,p) 
s(j,l) in p 
_x j saw I in p 
--~ john saw I in p 
-~ john saw louise in p 
john saw louise in t,a,'is 
ev(m,x, sm(w,y, s (x,y)) ) 
--~ a -1 every m x -1 cr sm(w,y,s(x,y)) 
c~-* eve~7 m x -1 a' fl-1 some w y-1 /3 s(x,y) 
_a ce -1 ever)' mall X -1 r_t' 
fl-1 some woman ),-t /3 x saw y 
O( -1 every magi x -1 (t x SUW soul(? womatl 
(by taking/3 = saw -1 x -~ ) 
-~ every man SOW some woman 
(by taking a = l) 
sin(w, v, ev(m,x, s (x,y)) ) 
tint some w 3 '-1 /3 ev(m,x,s(x,y))) 
_~ fl-I some w y-\] ~ a '-~ eve O' m x -1 c~, s(x,y) 
__~ fl-i some woman y-1 /~ 
0~ -1 every mall X -1 cr X S(IW )' 
_a /3-1 some woman y-1 /3 eveo' man saw 3" 
(by taking a = 1) 
every llI(lll SaW SO/lie WOll|(lll 
(by taking fl = saw -1 nlan -1 every -1) 
Figure 3: Generation examples 
ment, quantified noun phrases can move to whatever 
place is assigned to them after the expansion of their 
"scope" predicate, a place which was unpredictable at 
the time of the expansion of the quantified logical form. 
The identifiers act as "target markers" for the qtmntified 
noun phrase: the only way to "get rid" of an identifier z 
is by moving :r -1, and therefore with it the correspond
ing quantified noun phrase, to a place where it can cancel 
with a:. 
5 Parsing

To the compatible preorder --+ on F(V) there corre
sponds a "reverse" compatible preorder --, defined as 
a--,b iff b ~ a, or, equivalently, a -~ ~ b -~. The nor
mal submonoid M ~ in F(V) associated with --, is the 
inverse monoid of the normal submonoid M associated 
with -+, that is, M' contains a iff ivl contains rt -t. 
It is then cleat" that one can present the relations: 
j john-l-+ 1 
A-ir (A) ratl -! --+ 1 
sm(N,X,P\[X\] ) P\[X\]-I~-IX N-1some -1 --+ 
etc. 
in the equivalent way: 
john j-l_, i 
ran r (A)-IA --, 1 
some N X-1~ P\[X\] 
etc. 
sm(N,X, P \[X\] ) -le-i -v i 
Long-distance movement and quantifiers The sec
ond and third examples are parallel to each other and 
show thc derivation of the same string every man saw 
some woman from two different logical forms. Tile 
penultimate and last steps of each example are the most 
interesting. In the pennltimate step of the second exam
ple,/3 is instanciated to sawa xt. This has the effect of 
"moving" as a whole the expression some woman y-1 
to the position just before y, and therefore to allow for the 
cancellation of y-~ and y. The net effect is thus to "re
place" the identifier y by the string some woman; in the 
last step a is instanciated to the neutral element 1, which 
has the effect of replacing x by every man. In the penul
tinmte step of the third example, a is instanciated to the 
neutral element, which has the effect of replacing x by ev
eo' man; then fl is instanciated to sawl manl every t , 
which has the effect of replacing y by some woman. 
Remark. In all cases in which an expression similar to 
a al ... a,n cr -1 appears (with the ai arbitrary vo
cabulary elements), it is easily seen that, by giving c~ an 
appropriate value in F(V), the al ... a,, can move ar
bitrarily to the left or to the right, but only together in 
solidarity; they can also fi'eely permute cyclically, that 
is, by giving an appropriate value to c~, the expression 
(~ al ... a,, ~_~-1 can take on the value ak ak+l . • • 
a,,, al ... ak-~ (other pcrmutations are in general not 
possible). The values given to the a, fl, etc., in the exam
pies of this paper can be understood intuitively in terms 
of these two properties. 
We see that, by this meclmnism of concerted move
john -7 j 
louise -~ Z 
paris ~ p 
lllall ~ m 
WOIII(lll ~ W 
ran ~ A -1 r(A) 
saw --, A -I s(A,B) B -I 
in -v E -I i(E,A) A -I 
the -7 t (N) N -I 
every -~ c~ ev(N,X,P\[X\]) P\[X\] -I ~-i X N -I 
some -7 c~ sm(N,X,P\[X\]) P\[X\] -I cr -1 X N -I 
t\]tat --r N -I tt(N,X,P\[X\]) p\[x\]-I -I X 
Figure 4: Parsing-oriented rules 
Suppose now that we move to the right of the -7 ar
row all elements appearing on the left of it, but for the 
single phonological element of each relator. We obtain 
the rules of Fig. 4, which we call the "parsing-oriented" 
rules associated with the G-grammar. 
By the same reasoning as in the generation case, it is 
easy to show that any derivation using these rules and 
leading to the relation PS --~ LF, where PS is a phono
logical string and LF a logical form, corresponds to a 
public result LF PS1 in the G-grammar. 
A few parsing examples are given in Fig. 5; they are 
the converses of the generation examples given earlier. 
In the first example, we first rewrite each of the 
phonological elements into tile expression appearing on 
351 
john saw louise in paris 
-.-7 j A -I S (A, B) B -I 1 E -I 
--, s(j,B) B -I 1 E -I i(E,p) 
-7 s(j,l) E -I i(E,p) 
--, i(s(j,l),p) 
i(E,C) C-I p 
ever 3, man saw some WOlllglll 
--r Ce ev(N,x,P\[x\]) P\[X\] -1 cr -1 
--7 o~ ev(m,x,P\[x\]) P\[x\] -1 oe -1 
---, x A -1 ev(m,x,P\[x\]) P\[x\] -1 
• --r X A -1 ev(m,x,P\[x\]) P\[x\] -1 
---, ev(m,x,P\[x\]) P\[x\] -x s(x,y) 
and then either: 
~-r ev(m,x,P\[x\]) P\[x\] -I sm(w,y,s(x,y)) 
-7 ev(m,x, sm(w,y,s(x,y)) ) 
or: 
--, ev(m,x,s(x,y)) Q\[y\]-1 sm(w,y,Q\[y\]) 
-7 sm(w,y, ev(m, x, s (x,y)) 
X N -Im A -I s(A,B) B -I /9 sm(M,y,Q\[y\]) Q\[y\]-t 
x A -I s(A,B) B -I /3 sm(w,y,Q\[y\]) Q\[y\]-I /9-I y 
s(A,B) B -I /3 sm(w,y,Q\[y\]) Q\[y\]-I /3-I y 
s(A,B) Q\[y\]-1 sm(w,y,Q\[y\]) B-I y 
Q\[y\]-i sm(w,y,Q\[y\]) 
Figure 5: Parsing examples 
O-lyM-1 w 
the right-hand side of the rules (and where the meta
variables have been renamed in the standard way to avoid 
name clashes). The rewriting has taken place in par
allel, which is of course permitted (we could have ob
tained the same result by rewriting the words one by 
one). We then perform certain unifications: A is uni
fied with j, C with p; then 13 is unified to k. 5 Finally E 
is unified with s ( j, i ), and we obtain the logical form 
5( s ( j, 3. ) , p ). In this last step, it might seem feasible 
to unify E to 5_ (E, p) instead, but that is in fact forbid
den for it would mean that the logical form 5_ (E, p) is 
not a finite tree, as we do require. This condition pre
vents "self-cancellation" of a logical form with a logical 
form that it strictly contains. 
Quantifier scoping In the second example, we start 
by unifying m with I',! and w with M; then we "move" 
P\[X\] -1 next to s(A,13) by taking cv = xA-1; 6 then 
again we "move" Q \[y\] -1 next to s (A, B) by taking 9 
= B sm (w, y, Q \[y\] )-1; x is then unified withAand3, 
with 13. This leads to the expression: 
ev (m, x, P \[x\] ) P \[x\] -Is (x,y) Q \[),\] -lsm(w,y, Q \[y\] 
where we now have a choice. We can either 
unify s(x,y) with Q\[y\], or with p\[x\]. In the 
5Another possibility at this point would be to unify 1 with E rather 
than with /3. This would lead to the construction of the logical form 
5_ ( 1, p ), and, after unification of E with that logical form, would con
duct to the output s ( j, ± ( 1, p ) ). If one wants to prevent this output, 
several approaches arc possible. The first one consists in typing the log
ical form with syntactic categories. The second one is to have some no
tion of logical-form well-formedness (or perhaps interpretability) dis
allowing the logical forms 5. ( 1, p) \[louise in paris\] or 5. ( t (w), p ) 
\[(the woman) in paris\], although it might allow the form t ( 5. (w, D) ) 
\[the (wonmn in paris)\]. 
¢'We have assumed that the meta-variables con'esponding to identi
fiers in P and Q have been instanciated to arbitrary, but different, values 
x and y. See (Dymemmn, 1998) for a discussion of this point. 
first case, we continue by now unifying p\[x\] 
with sm(w,y,s(x,y)), leading to the output 
ev(m,x, sm(w,y,s(x,y)) ). In the sec
ond case, we continue by now unifying Q\[y\] 
with ev(m,x,s(x,y)), leading to the output 
sm(w,y, ev(m,x,s(x,y)). The two possible 
quantifier scopings lbr the input string are thus obtained, 
each corresponding to a certain order of performing the 
tmifications. 
Acknowledgments 
Thanks to Christian Retor6, Eric de la Clergerie, Alain 
Lecomte and Aarne Ranta for comments and discussion. 

References 

V.M. Abrusci. 1991. Phase semantics and sequent calculus for pure non-commutative classical linear logic. Journal of Symbolic Logic, 56(4). 

M. Dalrymple, J. Lamping, E Pereira, and V. Saraswat. 1995. Linear logic for meaning assembly. In P~vc. CLNLP, Edinburgh. 

Marc Dymetman. 1998. Group computation and its applications to linguistic description. (in preparation). 

J.Y. Girard. 1987. Linear logic. Theoretical Contputer Science, 50(1). 

Thomas W. Hungerford. 1974. Algebra. Springer-Verlag. 

J. Lambek. 1958. The mathematics of sentence structure. American Mathematical Monthly, 65:154-168. 

C. Rdtor6. 1993. R~seaux et s~quents ordonnds. Ph.D. thesis, Univ. Paris 7. 

Johan van Benthem. 1986. Essays in Logical Semantics. D. Reidel, Dordrecht, Holland. 352 

