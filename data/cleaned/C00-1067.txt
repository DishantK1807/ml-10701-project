On Underspecified Processing of Dynamic Semantics Alexander Keller, Joachim Niehren University of the Saarland, Saarbriicken, Germany {koller@coli I niehren@ps}, uni-sb, de Abstract We propose a new inference system which operales on underspecified semantic representations of scope and anaphora.
This system exploits anaphoric accessibility conditions from dynamic selnantics to disambiguate scope ambiguities if possible.
The main feature of the system is that it deals with underspecified descriptions directly, i.e. without enumeratlng readings.
1 Introduction
A particularly appealing aspect of lmdersl)ecification (van Deemter and Peters, 1996; Reyle, 1993; Muskens, 1995; Pinkal, 1996; Bos, 1996) is that it can in principle deal very efficiently with local ambiguities ambiguities which are only due to lack of inibrmation at an intermediate stage of processing and go away by the end of the analysis.
An example for this effect is (1): The scope ambiguity that is perceived alter processing the first sentence is no longer present after the second one.
This effect can be explained in a framework of dynamic selnantics (Groelmndijk and Stokhof, 1991; Kamp and Reyle, 1993) by the fact that a wide-scope universal quantifier would make the indefinite inaccessible for anaphoric reference from the second sei/tence.
(1) Every man loves a woman.
Her nanle is Mary.
In this paper, we show how this particular type of local ambiguity can be processed efficiently.
The approach we propose employs deterministic inference rules that can exclude the readings which violate anaphoric accessibility conditions without enlnnerating them.
These rules operate directly on underspecified descriptions and fully maintain underspecifiedness.
We also show how this behaviour Call be captured by constraint propagation in an existing implementation of tree descriptions using finite set constraints (Duchier and Niehren, 2000; Keller and Niehren, 2000; Duchier and Gardent, 1999).
More specifically, we introduce DPL structuT"cs~ extended trce structures that encode formulas of dynamic predicate logic (DPL) in much the same way as Egg et al.'s (1998) lambda structnres encode A-terms.
Then we define a constraint language tbr the description of DPL structures, called CL(DPL), in analogy to Egg et al.'s constraint langague for lambda structures (CLLS).
We characterize those DPL structures in which all restrictions oil anaphoric accessibility are obeyed by talking directly about the syntactic structure of a DPL formula.
This is ill contrast to the standard procedure in dynanfic semantics, where the dynamic behaviour is produced by the semantics of the logic; we do not need to (and do not) talk about interpretation of DPL structures and model accessibility by purely "static" means.
The paper is structured as follows.
In Section 2, we introduce DPL structures and tree descrit)tions in the language CL(DPL).
In Section 3, we add syntactic restrictions on admissible variable bindings to DPL structures and present axioms that characterize these restrictions.
In Section 4:, we turn these axioms into deterministic infhrence rules and combine them with deterministic inference rules known from an existing ilfference algorithm for dominance constraints.
We obtain a procedure that can do the kind of underspccified reasoning described above without enmncrating readings.
In Section 5, we sketch all imtflelnentation of our inf'erence system based on finite set constraint progralnming.
This implementation can be obtained by adapting an existing ilnI)lelnentation of a solver for dominance constraints.
Finally, we conclude and point to further work in Section 6.
2 Tree
Descriptions In this section, we define the Constraint Language tbr DPL structures, CL(DPL), a language of tree descriptions which conserw~tively extends donfinance constraints (Marcus et al., 1983; Rainbow et al., 1995; Keller et al., 2000) by variable binding constraints.
CL(DPL) is a close relative of the Constraint Language for 460 Lamb(la Structures (CLLS), 1)resented in (Egg et al., 1998).
It; is interl)reted over DPL structures trees extended by a variable 1)inding function which can be used to encode tbrmulas of dynamic (or static) predicate logic.
We will define DPL structures in two steps and then the language to talk al)out them.
2.1 Tree
Struetures For the definitions below, we assulne a signature Y\] = {(~12, varl0,Vl~,~ll,Al.z, manll, likel2,...
} of node labels, each of which is equipped with a fixed arity n _> 0.
The labels A,_~,_V,... are the.
tirst-order commctives.
Node lal)els are.
ranged over by f, g, a, b, and the arity of a lal)el f is denoted by ar(./'); i.e. if J'l,~ C E then ar(f) = n.
Let N l)e the set; of natural numbers ~.
> 1.
As usual, we write N* tbr the set of words over N, C for the elnl)ty word, and 7r~-' for the concatellatioll of two words 7r, 7r t C N*.
A wor(t 7t is a prefiz of 7c' (written rc _< re') if there is a word 7r u such that 7rTr tt = 7r t.
A node of a tree is the word rr E N* which addresses the node.
The empty word e C N* is called the root node.
A tree domain A is a nonempty, t)refixed-closed subset of N* which is closed under the left-sil)ling relation.
Definition 2.1 A tree strllctilre iS a t'a\])l(: (A, c,) consisting of a finite, tree dmn, ain A and a total labeling t'unction co ° : A -+ E s'ach th, al, for all rr 6 A and i G N: c A 1 < i < We say that the nodes r 6 rcl,..., 7c~ m'e in the labeling,'elationsh/ip 7c: J' On,..., 7r,~) ill! a (Tr) = J' and tbr each 1 < i < n, ~-i = ~-i.
Similarly, we say that a node ~c properly dom, inatcs a node 7c' and write 7r<\]+rc ' iffrr is a proper prefix of 7c'.
We take Ir and It' to be disjoint (~r J_ ~r') if ttley are different and neither node dominates the other.
So any two nodes in a tree structure are in one of the four relations = (equality), <1 +, ~>+ (the inverse of <1+), or _L.
We shall ~lso t)e interested the coml)inations of these l"elatiolls by set operators: intersection, coml)lementation, union, and inversion.
For instance, the dominance relation <~* is detined as the union of node equality and proper dominance = U<1 +.
Finally, we detine the ternary non-intervention relation ~(Tr<l*Td<Frc") to hold ifl' it is not the case that 1)oth ~r < ~r' and ~r' < re".
'. ~r var a ~ ma0 \lo var • var tr var-.
Figm'e 1: I)PL structure tbr the meaning of (1).
2.2 DPL
structures Now we extend tree structures by variable binding and obtain DPL structures.
To this end, we I)artition E into three sets: conneetive.s Econ = {V_,A,_%...}, predicate symbols Epred = {man, likes,...}, and tcr'm symbols Ere,.,. = {var, peter, mother_of,...} which substone, the variable symbol var and fimction sym1)ols.
Definition 2.2 A DPL structure is a triple (A,c&A) con.~isting of a trcc structure.
(A,c,) and a partial varial)le t)inding flmction A : A A which sati.sfies for all % ~r t ~ A: 1.
the. < r.co,, u.fo,.
all 7ci C A; 2.
< the,,,, fo,.
all 7ci ~ A; I)PL structures can be used to re, present ibrmulas of first-order predicate logic.
For instance, the DPL structure in Fig.
1 represents the (unique) meaning of (1).
So far, however, variables bound by a quantifier do not need to be in any special position in a DPL structure; in particular, not in its scope.
To entbrce seeping as in static predicate logic, we could simpy add the condition ~c'<~*~r in condition 3 of Definition 2.2.
We will define an appropriate counterpart \]'or DPL in Section 3 (properness).
Modeling variable binding with an explicit binding flmction instead of variable nmnes was first proposed in (Egg et al., 1998).
There, binding flmctions heJp to avoid a capturing problem in the context of scope underspecitication which t)ecomes most ~q)l)arent in the presence of ellipsis.
Her(; the 1)inding flmction mainly gives us a different t)erspective on variable binding which 461 R ::= <+1>+1 = I± I -* ::= X:f(X\],...,X,,) (fin C E) I xRz I I \[ ~A~'.
Figure 2: Syntax of CL(DPL) is useflfl for defining properness of DPL structures.
2.3 The
Constraint Language CL(DPL) The syntax of CL(DPL) is defined in Figure 2.
It provides constraints tbr all the relations discussed above.
There are labeling constraints X:.f(X~,...,Xr~), expressive combinations XRY of dominance constraints 'with set operators (Dtu:hier and Niehren, 200(}; Cornell, 1994), non-intervention constraints ~( X <1* Y <~* Z), and binding constraints a(X)=Z.
CL(DPL) is interpreted over DPL structures.
A variable assignment into a DPL structure 54 is a total flmction fi'om the set of variables of a constraint to the domain of 54.
A pair (54, oz) of a DPL structure 54 and a variable assignment (t into 54 satisfies a constraint qo ifl' it satisfies all of its atomic constraints; that is, if the relation with the same sylnbol holds of the nodes assigned to their arguments.
We also call the pair (54, oz) a solution and Ad a model of ~o.
Only some of the atonfic constraints in CL(DPL) are used in mlderspecified descriptions in t)articular, labeling, dominance, and binding constraints; the other constraints are helpful in processing the others.
These three types of constraints can be transparently displayed in constraint graphs.
For instance, the constraint graph ill Fig.
3 represents a constraint describing the readings of example (1) including the scope ambiguity.
The nodes of the graph stand for variables in tile constraint; labels and solid edges represent labeling COl> straints, dotted edges, donlinance constraints, and dashed arrows, binding constraints, hi addition, the constraint graph represents an inequality constraint X-~=Y between each two variables whose nodes carry a label.
A constraint with the latter property is called overlapfree.
The intuition is that the solid-edge tree fragments in the constraint graph must never overlap properly in a solution.
3 Dynamic
Semantics in CL(DPL) The semantics of DPL is built in a way that allows quantifiers to bind only variables in certain positions: inside their scopes and, if it is an existential quantifier, from the left-hand sides of conjunctions and implications into the righthand sides.
In CL(DPL), we model this as a purely syntactic restriction on the accessibility of binders which we define as a structural property of DPL structures.
DPL structures which have this property will be called proper.
A useflll auxiliary concept tbr the definition is that of an infimum of two nodes with respect to the dominance relation q*, which constitutes a lower senfilattice because of the underlying treeness of DPL structures.
Furthermore, we will use the standard DPL notions of internally v@" = {A,~} and exdynamic COlUlectives ~con ternalh d, static connectives ~con'~stat = {2, V, __=::k, _V}.
The semantics definition of DPL gives these two groups special relevance tbr variable binding.
Now we can define pTvper \])PL structures as tbllows.
Definition 3.1 A DPL structure 54 is called proper '~f for each, node ~r of 54 on which ~ is defined, one of th, e following cases holds true wh, ere p, is the i'nfimum of rc and A(TC).
1. ff = ;~(~), or 2.
)@r) is labeled 'with ~_, ttl<l*.~(Tr), p,2q*% I t is labeled with art internally dynamic connective, and no node between ttl and A(Tc), inclusively, is labeled with an externally static connective.
Intuitively, the first branch of the definitiou corresponds to usual binding of variables inside tile scope of a quanfifer.
In the second branch, the positions of the variable and the (existential) quantifier in the DPL structure are dis.joint, and the quantifier is dominated by tile left child of the infimum.
Then the infimum must be labeled with an internally dynamic connective, and there must be no externally static connective between this node and the quantifier.
This restriction is what we are going to exploit 462,..-'' r, / • / womb2',1% ..)...':'\,,' \ vat Figure 3: Constraint graph for (1).
to capture the influence 055 scope.
There is 51o such restriction for the lmth 1)etwcen the intimmn and the w~riM)le.
Sohll;ions of & constraint thnt violate the (lynmnie accessibility conditions are now excluded silnply by restricting the, class of ~utmissible solutions to i)roper ones.
As exl)ected from the linguistic intuition, only one sohd;ion of the nmning exmnple (1) is proper: the one where "a woman" is assigned wide scope (Fig.
1). Tit(; other solution is not prot)er because the path Kern the infimum ((lellol;cd by Z0 in Fig.
3) to the antecedent contains ;~ mfiversal qu~mtiticl".
Prot)erness of ;~ I)PI, sl;ruct;u5"(' ('t~sl I)(; ~txiolnatized synta,ctically: A \])PL sl;rucl;urc is 1)rot)er iff the CI~(I)I'I~)~xioms (l)y,,\])to (l)yn4)in Fig.
4 ~re, wflid over it.
The rule (Dynl) threes universM qmmtifiers to bind only variM)les in their scopes, and the rules (l)yn2) to (Dyn4) enforce properness of binding when a wtrial)le is not in the scope of its binder.
4 Underspecified
Reasoning We next present a procedure for mMorspecitied reasoning with dynmnic semmltics.
Th(' goal is to narrow an mMerst)ecified (les(;rit)tion such that improi)er DPL-structure, s are removed flom the solution set.
Narrowing should apply as soon as possible, so unde, rspeciliedness (:~m be 5naintmned and readings need not t)e enmnerated.
We present ml intb, rence procedure tlmt can do this and go through two exmnples.
4.1 Inference
Procedure This infi;rence procedure,s'atuvatt,.s a, constrMnt ttccording to the rules in Figures 4 and 5; that is, whenever a constraint conttdns the lefl;-hmM side of a rule,, it adds il;s right-hand side, until no new conjuncts ca, n 1)e ndded.
Fig. 4 contains simply the prot)erness axioms from the, l)revious sections, turned into deterministic proof rules.
The rules in Pig.
5 are t)ropagation rules t'ronl Algorithm DO in (Duchier and Niehren, 2000), plus new rules for non-intervention constrainl;s.
Algorithm DO contains some ~Mditional rules, in I)ari;iculm' distribution rules that perform case distinctions, because DO is a complete solver tbr dominance constraints with set operators, wlfich improves on (Duchier and Oardent, 1999; Keller et M., 1998).
We have omitted the (listril)ution rules here l)e,(;ause we do 'not wmlt to perform case distinctions; l)y ndding 1;\]1(;115 ~tg~l, ill~ WC COll\]d ellll511era, I;e all proper solutions, ~:ls Schiehlen (1997) does tbr UDI1T.
The new rules (NonI1) ~md (NonI2) Mlow to derive dominan(:e infbrmation from nonintervention constraints.
As we will see, the most interesting rule in Fig.
4 is (l)yn2), which derives explicit non-intervention int'ormalion fi'om the structurM t)roperLies of dynamic 1)inding.
Note that while the rules in Fig.
5 are sound over ;my DPL strucl;ure, those in Fig.
4 are only serum eve5" proper DPL structures.
This is intended: Application of a prot)erness rule is s'upposcd to exclude (improper) solutions.
4.2 Examples
The inii;rence rules go a long w:ty towards makink tile eft'cot of dynamic seminal;its on scope e, xt)lieit.
Let us consider |;15(; running example in Figure 3 to see how this works; we show how to derive Y3<I*X, which specifies the relative quantifier scope.
First of all, we need to make the information 463 (Dynl) (Dyn2) (Dyn3) (Dyn4) a(x)=Y A Y:V(z') Y<*X Z(X)=Y A Z:f(Zl, Z2) A ZI<1*Y A Z2<\]*X A W:g(W1,..., Wn) ~dyn ~st~tt (fe or,, e ~(X)=Y A Z:f(Z1,..., Zn) A Zi<:1*X A Zj<:\]*Y --+ false A(X)=Y A Z:f(Z1,...,Zn) A Zi<l*X A &<1*Y -~ false Figure 4: Properness axioms.
(Trans) (Lab.Dom) (NegDisj) (Lab.Disj) (Inter) (Inv) (Child.down) (NegDom) (NonI1) (NonI2) X <a* Y A Y <q* Z -+ X <1* Z x:f(...,z,)... x<+y X <1* Z A Y <F Z --+ X~ -L Y,xs,)...
XR1Y A XR2Y -+ XRY XRY -+ YR-1X -+ -~(Z~ <*W<a*Y) v~dY'1 i ¢ j) (.fl,, ~ Econ -,-,co,,, (.fl,, e E, i < j) Xi ± Xj where i < j if RINR2 C R X<:\]+Y A X:f(Xl,,...,Xn) A X-~ ± Y A X J_Z -+ Z-~<a*Y -~(X<*Y<1*Z) A X<*Y --+ Y~<*Z ~(X<\]*Y<I*Z) A Y<*Z --," X-~<1*Y ---> X i <F Y Figure 5: Propagation rules for dominance and non-intervention constr~dnts.
Z2<1*Za explicit by application of (Lab.Dom) and (Inter).
In this instance, (Inter) is used as a rule of weakening.
(Lab.Dom) Zg:A(Za, Z4) -~ Z,~<1+ Za (Inter) Z.~<Y'Za --+ Z2<F Z3 Now we can apply the rule (Dyn2) to the variable binding constraint A(Za) = Y (drawn in boldface in the graph) and the V labeling constraint to derive a non-intervention constraint.
(Dyn2) Z0:A(Z:j, Z2) A ZI<1*X1 A X:V_(X1) A Z2<q*Za A A(Z3) = 1/ All that is left to do is to make the positive dominance intbrmation contained in the new non-intervention constraint explicit.
As the constraint also contains Zo<1*X, we can apply (NonI1) on the new non-intervention constraint and derive X~<FY.
(NonIl) =(Zo<1*X<1*Y) A Zo<1*X --+ X~<1*Y On the other hand, we can derive nondisjointness of X and Y because (Trans), (Lab.Dom), and (Inter) allow the deriw~tion of X<FW and Y<1*W: (NegDisj) X<*W A Y<I*W ~ X= £ Y We can now combiue all of our constraints tbr X and Y with the intersection rule and obtain Y<1*X, which basically determines the order of the two quantifiers: (Inter) X~<*Y A X-~ £ Y ~ Y<*X By exploiting the fact that the constraint is overlap-ti'ee (i.e.
contains an inequality coststraint for each two labeled variables), we (:an even derive Y3<I*X by repeated application of the rules (Child.down), (Lab.Disj), (NegDisj), and (NegDom).
This means that we have flflly disambiguated the scope ambiguity by saturntion with deterministic inference rules.
Now let us consider a more complicated example.
Fig. 6 is the underspecified description of the semantics of (2) Every visitor of a company saw one of its departments.
The constraint graph has five solntions, three of which are proper.
Unfortunately, the constraint language is not expressive enough to describe these three solutions ill a single constraint: Both X and Z can be either above or below Y, even in a proper solution, but if X is below Y, Z must be too, and ifX is above Y, Z must be anywhere below X (but; may be above 464 • IX V,, Y """-q,,,Z company ".
" x ".
". i "".," " var " researcher i ".
/ of~----~ depar.tmen-gh'~ ;, "~".
var \~!
".. ' Var ~ var'~ """.
var ~"".
• i "..
" ", ".
L" i . " / var'~ vat ~ .......
Figure 6: Constraint graph for (2).
YI). In other words, this constraint is an exampie where the inference procedure is not strong enough to narrow the description.
In this case, we must still resort to pertbrming nondeterministic case distinctions; at worst, the rules will apply on solved forms of CL(1)PL) constraints.
constraints over these set variables; examples for set constraints are V C V' and V = V~ U V.2.
The new non-intervention constraint ~(X<1*Y<1*Z) can be encoded as Y e <+(x) u _L(Z) u >+(Z).
5 Processing
with Finite Set Constraints This inferen('e procedure fits nicely with all imph;mentation of (lominance constraints t)ased on constraint programming (Marriott and Stuckey, 1.998; Koller and Niehren, 2000) with tinite set constraints (Miiller, 1999).
Constraint programlning is a technology for solving combinatoric puzzles eificiently.
The main idea is to replace "generate and test" by "propagate and distrilmt(f'.
Constraint prot~agation t)eribrms deterministic inferences which prune the search space, whereas distribution tmrfonns (nondeterrain|st|c) case distinctions.
Duchier and Niehren (2000) show how to implenmnt a (lominance constraint solver by encoding donfinance constraints as finite set constraints and disjunctive propagators.
This solver does not handle non-intervention constrain|s, lint we show here that they can tm added very naturally.
The (Dyn) rules still have to be implemented as saturation rules.
The idea of this implementation is to encode a solution (Ad, ~) of a donfinance constraints by introducing for each variable X in the constraint and each relation symbol R C {<1 +, t> +, =, J_ } a finite set variable R(X).
This w~riable is supposed to denote the set of all variables denoting nodes that are in tile relation R to ~(X): l~,(X) = {Y e W(~o)I (M, ~) bYI~.X} Dominance constr~fints can now be stated as The bull|in t)rot)agation tbr set constraints automatically implenmnts the rules (NonI1) and (NonI2).
For instance, assume that X<1*Y t)elongs to ~; then there will 1)e a set constraint Y ¢ <1 +(X), so set constraint propagation will derive Y ~ ~_(Z) U t>+(Z).
This is the |mined|at(; encoding of Y_L U t>+Z, which is equiwdent to Y~<1* Z.
6 Conclusion
In this paper, we have shown how a sl)ecific type of local anti)|gully, which is produced by the interaction of intersentential anaphora and scope ambiguities, can l)e processed ell|clearly ill the framework of underspecification.
We h~ve defined \])PL structures, which can be used to model fonmflas of DPL, and proper DPL structures, ill which w~riable binding must obey the accessibility conditions of DPL.
Finally, we have shown how an underspecified description can be narrowed to a description of its proper solutions, sometimes without even partial enumeration of readings, and integrated this operation into all implelnentation of dominance constraints which is based on tin|re set constraints.
Se, en from the perspective of DPL, our definition of tlrot)ern(;ss is tmrely syntactic and technically has nothing to do with dynamic semantics.
We could state such a definition t/ecause the expli(;it variable binding flmctions gave us a structure-in(let)endear handle on variable binding that excluded all tbnns of capturing.
This deviates from the standard perspective of indef465 inites changing the context, but has the advantage of being extremely modular in that the accessibility conditions are factorized out explicitly.
For instance, it is simple to represent the meaning of "Bach-Peters sentences" by relaxing these conditions; it should also be easy to adapt our tbrmalism to other frameworks of dynamic semantics.
Of course, the question of how to interpret a DPL structure remains open.
Another open question is how the approach presented here can be extended to higher-order systems of dynamic semantics (e.g.
Dynanfic Lambda Calculus (Kuschert, 1999)).
In this context, it could be worthwhile to restore tim distinction of variable binding and anaphoric linking from CLLS.
Finally, it should be interesting to find other classes of local ambiguity that lend themselves to a treatment as presented here.
So far, there are not many related examples; one is lexical ambiguity in parsing of dependency grammar, as presented in (Duchier, 1999).
However, we believe that the work presented here provides further illustration that underspecified processing can go a long way towards efficient processing of local ambiguities.
Acknowledgments. This work was supported by the l)eutsche Forschungsgemeinschaft in the SFB 378.
As always, we thank all members of the SFB 378 project CHORUS at the University of the Saarland.
We are also grateful to the participants at the Dagstuhl workshop on Dynamic Semantics in February 1999 for comments and discussions on an earlier version of this paper.

