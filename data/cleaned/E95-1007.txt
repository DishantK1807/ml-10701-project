Some Remarks on the Decidability of the Generation Problem in LFGand PATR-Style Unification Grammars Jiirgen Wedekind Institute for Natural Language Processing University of Stuttgart Azenbergstr.
12 D-70174 Stuttgart, FRG juergen@ims.uni-stuttgart.de Abstract In this paper, we prove the decidability of the generation problem for those unification grammars which are based on contextfree phrase structure rule skeletons, like e.g.
LFG and PATR-II.
The result shows a perhaps unexpected asymmetry, since it is valid also for those unification grammars whose parsing problem is undecidable, e.g. grammars which do not satisfy the off-line parsability constraint.
The general proof is achieved by showing that the space of the derivations which have to be considered in order to decide the problem for a given input is always restricted to derivations whose length is limited by some fixed upper bound which is determined relative to the "size" of the input.
1 Introduction
Unification Grammars with a context-free skeleton, like Lexical Fhnctional Grammar (LFG) and PATRII (cf.
e.g. Kaplan and Bresnan 1982, Shieber et al.1983) assign to a sentence not only a constituent structure (c-structure), but also an additional linguistic entity.
In the rather restricted grammars of the early stage this entity is identified with a special graph structure, commonly called feature structure.
Since a string is regarded as well-formed only if a (well-formed) feature structure is assigned to it by the grammar, two inverse decidability problems arise which had to be solved in order to know whether we can formulate terminating parsing and generation algorithms.
If we retain the terminology of the early stages then an adequate parsing algorithm requires that we can decide for a given grammar and a given string whether there exists a feature structure assigned to it by the grammar (parsing problem) and an adequate generation algorithm requires that we can decide for a given grammar and a given feature structure whether there exists a sentence to which this structure is assigned by the grammar (generation problem).
While we already know for a long time that the parsing problem is undecidable (cf.
Kaplan and Bresnan 1982, Johnson 1988), we want to show in this paper that the generation problem is decidable even for unrestricted (not off-line parsable) unification grammars.
For the proof we first introduce in section 2 the type of grammar we want to consider.
In section 3 we then define the generation problem and show its decidability in two steps.
2 Preliminaries
The unification grammars we want to consider consist of rules with a context-free skeleton and a set of annotations associated with the constituents mentioned in the rules.
Typical examples taken from LFG and PATR-II are given in figure 1.
For the forS --~ NP VP S --+ NP VP (t SUB J) ----$ j'=$ (VP AGR) = (NP AGR) NP -+ John NP -4 Uther (1" PRED) = JOHN (NP AGR NUM) = SG (NP AGR PER) ---3RD Figure 1 Examples of rules in LFG (left) and PATR-II format (right).
mal definition of those grammars we reconstruct the annotations as formulas of a quantifier-free sublanguage of a classical first-order language with equality whose (nonlogical) symbols are given by a finite set of unary partial function symbols and a finite set of constants.
For the translation of LFG and PATR-II annotations we regard the attributes (in figure 1: SUB J, PRED, AGR, NUM, PER) 58 unary partial function symbols and the atomic values (in figure 1: JOHN, 45 SG, 3RD) as individual constants.
Furthermore, we assume for a context-free rule of the form A ---> w (w e (VN U VT)*) that the variable x0 is associated with A and that for each occurrence wi in w there is a variable xi which is associated with wi.
For the formal reconstruction of LFG's we assume that each occurrence of $ in the annotation of w~ corresponds to an occurrence of xi and that each occurrence of 1" corresponds to an occurrence of x0.
For grammars in PATR-II format we suppose that occurrences of categories in the annotations correspond to the associated variables.
Before we give the definition of the grammars we want to investigate, we introduce the following notation.
In the following we use S\[xl,.., x~\] to indicate that the variables occurring in the set of formulas S are included in {xl, .., Xn} and S(Xl, .., xn) if the set of variables occurring in S is exactly {Xl,.., xn}.
1. DEFINITION.
A unification grammar is a tuple (VN, VT, S, F1, V, V, R>, consisting of a finite nonterminal vocabulary VN, a finite terminal vocabulary VT, a start symbol S E VN and a feature-description language L determined by a finite set of unary partial function symbols F~, a finite set of atomic values V and a denumerable set of variables 1 V= {x~ I a e N*} with x~ #x,, for a # a'.
All vocabularies are pairwise disjoint.
R is a finite set of rules of the form r = ((A,w),S~\[xo,..,xl~l\] } (zi E 1;), with (A, w) e VN x (VN U VT)* (a contextfree phrase structure rule) and S~\[x0, .., xl~l\] a finite set of (quantifier-free) literals of L.
2 According
to our definition the LFG rules in figure 1 are now expressed as depicted in (la) and the PATRII rules as given in (lb).
Note that the structure of the terms is now "mirror imaged", since we assume the attributes to be unary partial function symbols.
(1) (a) (S -+ NP VB, {SUBJ Xo ..~ xl,xo ~ x2}) (NP --~ John, {PRED XO ~ JOHN}) (b) (S --> NP VP, {AOa z2 ~ AGR xl}) SNUM AGR XO ~ SO,1 \ (NP --+ Uther, \].PEg AOR Xo ~ 3RD~/ For the definition of the sentences derivable by a unification grammar we have to specify first what derivations are.
2. DEFINITION.
A sequence of pairs ~r0...~rn with 7to = (Be, 01 (B 6 VN) is called derivation of length n iff for each 7ri = (B \[..A~..\]~, S) (0 < i < n) there is a rule r (A -+ w~ k = ..win, S~) such that = ..,,~\]~..\]~,S~).
In the definition we assume that the order of the arcs of a tree is encoded by numbering the arcs and that each node is identified with the sequence of integers numbering the arcs along the path from the 1The syntax and semantics of feature-description languages is given in the appendix.
2A literal is an atomic formula or the negation of an atomic formula.
root (O) to that node.
In our bracket notation we add to a constituent its root node as the right and its root node label as the left index.
In order to be able to refer to the c-structure derivation and to the sequence of feature descriptions and to have access to the nodes which are substituted in each step of a derivation, we define for a derivation 7r three other sequences.
3. DEFINITION.
Let ~r be a derivation of length n.
We then define two sequences w and ")' for each i=O,..,n with lh=(Tc, S) by wi=Tc and 7i = S and a sequence w for each i-1,..,n with w~-i = B\[..A~..\]O and Tc = B\[..A\[W~.I,..,wk.m\]~..\]0 by wi = #.
Let S be a set of literals and 0 a unary partial mapping over the set of terms.
Then the expression S\[0\] denotes the set of expressions obtained from S by simultaneously replacing each occurrence of a term ~in each formula in S by 0(T).
The feature description derived by zr is then defined by means of the following operation.
4. DEFINITION.
If ~r is a derivation of length n then the feature description derived by 7r from h to k (0 <_ h < k <_ n) is given by k S;-~k = U 7i\[{(xj,xw, j) I xj occurs in 3'i}\].
i----h EXAMPLE 1.
If we start a derivation zr from (So, 0) and apply the S-rule in (la) and the following VPrule (VP -+ V VP', {xo ~ Xl,XCOMP ~0 ~ X2}) we end up with the following sequence.
~o = (So, 0) 7rl = (s\[NP1, VP2\]o,{SUBJ xo ~ Xl,XO ~ x2}) zr2 ---(s\[NPI,vp \[V2.1,VP'2.21210,{xo ~.
Xl,XCOMP Xo ~ X2}) For the steps depicted above the sequence w is given by wl = 0 and w2 = 2 and the feature description derived by 7r from 0 to 2 (S~_~2) is {SUBJ X0 ~ Xl,X0 ~ X2,X2 ~ x2.1,XCOMP x2 ~ x2.2}.
Sentences are then defined as follows.
5. DEFINITION.
A terminal string w (w E V~) is a sentence iff there is a derivation (So, 0) = r0..Trn with Wn = S\[w\]0 and 3x~1 ..x,~ A S~-"~n(X~tl' "" Z~tm) satisfiable.
3 In
the following we write S" for S~_+n if the interval covers the whole derivation, i.e. if ~r is of length n.
Since a specific reduction algorithm and a few model-theoretic facts required in the proofs later on can be introduced by showing how satisfiability of such existential prenex formulas can be decided, we will continue with a short excursion on satisfiability.
3We use s\[w\]o to denote an S-rooted c-structure with yield w.
46 2.1 Satisfiability In order to test whether for a given finite set of literals S of a feature-description language (2) (2) 3z~..zt A S(x~,.., zl) is satisfiable, we can exploit by skolemization wellknown test procedures available for quantifierand variable-free sets of such literals.
Let C be a set of Skolem-constants (\[{xl, ..,xz}\[ = ICl) and 0 be a bijective function from {Xl, .., xt} to C, then (2) can be tested by testing the set of literals (3) over L(C) 4 (3) S\[0\], since (2) and (3) are equi-satisfiable.
In the following we complete the procedure by introducing a reduction algorithm that reduces a set of literals (3) according to a measure in a sequence of measure decreasing rewrite steps to a deductively equivalent set (4) (in reduced form) (4) (S\[e\])p, which is satisfiable iff the terms 7of all inequalities T ~ 7of (4) do not occur as subterms in equations of (4).5 For the proof we first introduce a few definitions and some notation.
Let 7be the set of terms of a variable-free feature-description language L(C).
Then an injective function m • \[7~ ~l*\] is a measure iff it satisfies the following conditions for all T, T' • 7" and a • FI*: (i) if \[7-\[ < \[7-'\[, then re(w) < m(7-'), (ii) if re(r) < m(7-'), then m(aT) <_ m(a'c').
For literals and sets of literals S we extend a measure m as usual by m((.~)7~ 7-')= m(7-)+ m(7-') and re(S) = Era(C).
Ces In the following we use 7~7-' iff m(7-) > m(7-') and 7-~7-' to denote ambiguously 7~ 7-' or 7-~ ~ 7-.
Let S be a set of literals then E denotes the set of all equations in S, 7-s the set of terms occurring in the formulas of S (7-s = {~-, 7-' \[ ("~)7~ 7-' • S}) and SUB(Ts) the set of all subterms of the terms in 7~ SUB(7~) = {7-\[a7• 7~, with a • FI*}.
For the construction of a reduced form we need a specific partial choice function p which satisfies p(S) • {7~7-' • SIT • SVS(Ts\{r~.,.,})} if the specified set is nonempty and undefined otherwise.
6. DEFINITION.
For a given finite set of literals S and a choice function p we define a sequence of sets Sp, (i > O) by induction: Spo =S f( Spi\{ 7-~-.7-t} )\[r/v' \] U {7-~T t} if p( Sp, ) = 7~7-' Sp,+, = \[So, if p(S m) undef.
aThe feature-description language which in addition to L provides a distinct set of Skolem-constants C'.
Cf. the appendix for more details.
~The algorithm is adapted from Statman 1977 and Knuth and Bendix 1970 and first applied to featuredescription languages by Beierle and Pletat (1988).
Since m(Sm) > m(Sp,+l ) ifp is defined for Sin, the construction terminates with a finite set of literals.
If we set Sp = Spt ; with t = mini \[ Sp, = Sin+ ~ } the following lemma can easily be proven by induction on the construction of Sp.
6 7.
LEMMA. For Sp it holds that: (i) S ~F S o, (ii) if T~T' C S o then T ¢ SUB(Tsp\{r~r,}).
Since Sp is obviously not satisfiable if it contains an inequality T ~ 7 and 7 occurs as a subterm in Ep, the whole proof is completed by showing that we can construct a canonical model satisfying Sp if Sp does not contain such an inequality.
For the model construction we need the set T~p = {r e SUB(TE,) \[ -~3T'(T ~T' e Ep)} and the function h c E \[SUB(7-Ep) ~ 7-~,\] which is defined for each 7e SUB(TE,) by f,T'(7-~T' Ep) if 7E, h e (T) = • f\[ T'c \[7otherwise.
That h e is well-defined results of course from 7(ii).
8. DEFINITION.
For a set of literals S o the canonical term model is given by the pair Mp = (Hp, .~p), consisting of the universe Ltp=\[7~, ifE, ~ 0 \[.{O} otherwise and the interpretation function ~p, which is defined forc•VUC, f•/'l and 7-•Hpby: \[M(c) if c • SUB(TE,) ~p(e) = I.undefined otherwise ~ h~(fT-) if fT• SUB(TE,) "~P(f)(7-) = \[undefined otherwise.
For Mp which is well-defined the following lemma holds: 9.
LEMMA. If 7is a subterm of Ts, then (i) ~p(7-) = he(7-), if 7• SUB(TE~), (ii) 7• SUB(T~), if T • Dom(.~o).
PROOF. (By induction on the length of 7-).
The lemma is trivial for constants.
By showing (i) before (ii) we get the induction step for a subterm fTof Ts, in both cases according to ~p(fT) = ~p(f)(-~p(7-)) = ~,(f)(hC(7-)) = ~p(f)(7-).
We get .~p(7-) = hC(T) by inductive hypothesis and M(7-) = % since 7¢ Hp would imply the existence of 6In order to verify 7(i) cf.
e.g. Wedekind 1991 and 1994.
47 T ~ r' • E o and fT could not be a subterm of 7~p according to lemma 7(ii).
Now, if (i) fT • SUB(TEp) then ~p(f)(T) is defined and equal to h~(fr) and (ii) if fr • SUB(Ts,) and .~o(fT) is defined then fr • SUB(TE~).
\[\] On the basis of lemma 9 it is now easy to prove: 10.
LEMMA. VT ~ T • So(7" ¢ SVB("fEp)) --~PMp S O.
PROOF. (If the condition is satisfied ~M, ¢ holds for every ¢ • So.
) If ¢ = ~'~T' • S o with m(T') < m(r), then v' • T~o by 7(ii) and hence hC(T ') = T'.
We get then h~(~ -) = T' for m(T') = m(T) by T' = T and for m(~-') < m(~-) by the definition of h ~, since r ¢f T~.
Thus ~p(T) = ~p(T') by 9(i) and hence ~Mo ¢.
Assume ¢=TCT'.
If T~7' were satisfied by Mp, we would get ~p(T)= ~p(T') and by 9(ii) T,T'•SUB(TE,).
Since 7(ii) ensures he(r) = h~(~ -') = v = ~-', we would have ~¢ r • Sp with T • SUB(TEo).
\[\] Finally it should be mentioned that Mp is a unique (up to isomorphism) minimal model for Sp, i.e. if M is a model for So, homomorphic to Mp, then every minimal submodel of M that satisfies S o is isomorphic to Mp.
3 The
Generation Problem and its Decidability Although it was not necessary for the definition of the sentences derivable by a unification grammar, we now have to make explicit that also a feature description is assigned to a sentence.
11. DEFINITION.
A terminal string w (w • V~) is derivable with feature description 3Xl..Xl¢(Xl,.., xt) iff the feature description is satisfiable and there is a derivation (S~, O) = ~r0..Ir,~ with w~ = s\[w\]~ and ¢=AS ~.
Since deductively equivalent consistent feature descriptions are assumed to describe the same set of feature structures (models), the assignment of entities to terminal strings determined by a unification grammar is then formally given by a binary relation A between terminal strings and sets of classes of deductively equivalent feature descriptions \[?Xl ..Xl ~)( X l, .., Xl ) \]'-tF .7 12.
DEFINITION. For each terminal string w • V~ and each class \[Sxl..xl¢(Xl,.., xl)\]: A(w, \[3xl ..xl¢(xl,.., xl)\]) iff w is derivable with 3zl..zl¢(zl, .., xt).
Definition 12 now brings us closer to the problem, since we can for any unification grammar in rather abstract terms specify what parsers and generators are: a parser is a procedure which recursively enumerates for any given string w the set {\[~Xl..XI~)(Xl,.-, Xl)\] \[ A(W, \[3X 1..xI¢(xl,.., Xl)\])} 7We omit the index of the equivalence classes in the following.
and a generator is a procedure which recursively enumerates for any given class \[3Xl..Xl¢(xl, .., xl)\]: s {w • y~ l A(w, \[3Xl..Z,C(Xl, ..,z,)\])}.
Whether adequate algorithms (effective procedures) can be formulated depends on the decidability of the corresponding parsing and generation problem.
In our case (generation), it is the problem whether 3w • y~(zx(~, \[3Xl..X~¢(xl, .., x~)\])) is decidable for any given class \[3xl..xl¢(xl, ..,xl)\]. The decidability of the generation problem alone ensures the existence of algorithms which terminate in any case with an output, although they might (of course) not be able to produce all possible solutions.
Despite decidability, inputs can still be infinitely ambiguous (\[{w • V~ \[A(w, \[3xl..xl¢(Xl, ..,xl)\])}\] infinite).
In order to prove the decidability of the generation problem (theorem 13), we proceed in two steps.
13. THEOREM.
It is decidable for each feature description 3yl..Yk¢(Yl,..,yk) whether there is a terminal string w • V~ which is derivable with 3Xl..Xl¢(xl,.., Xl) and 3yl ..Yk¢(Yl,.., Yk) qF3Xl ..Xt¢(Xl, .., Xl).
In the first step we show that we can always shorten a derivation of a sentence w with (consistent) feature description ¢ to a derivation of a sentence w' with feature description ¢' and ¢ -t~¢' whose length is bounded by the "size" of ¢.
By showing in the second step that two deductively equivalent consistent feature descriptions have the same "size" theorem 13 follows, since only a finite set of derivations (those whose length does not exceed this upper bound) have to be inspected in order to decide 3w • V~ (A(w, \[¢\])) for an arbitrary consistent input ¢.
3.1 Redundant
Recursions and Pumping For the proof that for a derivation of a sentence w with (consistent) feature description ¢ there always exists a short derivation of a sentence w' with feature description ¢' and ¢ -tt¢' we exploit the fact that a c-structure may contain recursions of the form depicted in figure 2 whose corresponding subderivations in ~r are eliminable.
Such recursions are called redundant.
14. DEFINITION.
Let rr be a derivation of a sentence uvzxy of length m + k + 1 whose c-structure derivation has the form ~O0..t.dm..O.~rn-t-k..Wm-l-k-bl -~ OQn with wm= S\[U, A u, Y\]0 and aJm+ k : s\[U, AIr, Au.~, x\],, Y\]0 (reorder if necessary).
If 7r' is a derivation of uzy of length m+l which is defined for each j (O < j < rn+l) by {r~j if j <_ m 7r~ = (s\[ury\]~, S) if j > m and 7rj+k = (s\[uvrxy\]~,S) SWe assume here strong reversibility, since a generator is for a given input y simply a parser which operates on A-I: it recursively enumerates instead of {x I A(x,y)} the set {x I A-I(x,Y)} • 48 \ u v z x y Figure 2 A c-structure with recursion A\[V, A~.~, x\]t, (1~1 > 0).
and, {;rj ifj<_m wJ = .t if j>m and wj+k = #.~.~ then 7rm+l...~m+ k is a redundant recursion iff 3x,..x~ h S~(xt, .., x~) ~ 3xl "x'k h S~' (xl, .-, x~)If we assume that a given derivation of a sentence is already shortened to a derivation without redundant recursions it remains to show that the length of such a derivation could not exceed the upper bound determined by the "size" of the derived feature description.
The "size" of a consistent feature description is on the one hand determined by the size of its minimal model, and on the other hand determined by a normal form into which every feature description can be converted.
The conversion is performed in two steps.
In the first step, we eliminate as many variables as possible by substitution.
15. DEFINITION.
If S(Xl,..,Xl) is a set of literals, then xi is eliminable in S(xl,..,xl) iff there is a term T not containing xi such that ~3zl..x~(A S(Xl, .., ~) ~ z~ = r).
16. NOTATION.
In the following we write S\[x~, .., xz\] iff each xi is not eliminable in S.
17. DEFINITION.
We assign to a set of literals S'(x~,..,x~,x~,..,X~k) a set R(S') which contains a set S\[x~,..,xt\] iff there is a substitution O E \[{x~, ..,x~} ~-~ T(x~, ..,x,)\] such that ~..~,~..x~(A s' ~ ~ ~ o(~)) for all ~ (1 < i < k) and Sfz~, ..,~\] = S'\[O\]?
By the substitutivity theorem we get: 18.
LEMMA. If SfXl, .., xl\] E R(S'(Xl,.., xl,X~l,.., x~k)) then 2x~ ..x~k(A S A S').
In the second step, we make the set of literals independent, i.e. we remove those literals which are implied by the remaining subset.
~T(x~,..,xt) denotes the set of terms over V, {x~, .., x~} and F~.
19. DEFINITION.
A set of literals S(xl,..x~) is independent iff there is no formula ¢ E S for which F~xl..xl(A(S\{¢}) D ¢) holds.
Normal forms are then defined as follows.
20. DEFINITION.
A consistent feature description ~xl..xl A Six1,.., xt\] is in normal form (in the following indicated by a v index) iff S\[xl, .., xl\] is independent.
Furthermore, we call ~xl ..xl A S~ Ix1, .., xl\] a normal form of ~xl..xtx'~..x~ h S'(xl, .., x~) iff S~ Ix1, .., xt\] is an independent subset of S'\[O\] E R(S') and ~Z1..Xl(ASv\[Xl,..,Xl\] ~ ASt\[0\]) • Lemma 18 and the condition in definition 20 ensure that a consistent feature description and its normal forms are deductively equivalent.
In order to be able to show the existence of a redundant recursion, we exploit the simple fact that the information which contributes a literal in a normal form with a minimal model (Up, ~p} can be specified by an equation ~-~ 1 -s where IT\[ + \[rq < \[Up\[ + 2.
A literal r ~ O'a'T 't (\[a I > 0) whose terms are longer must always be reducible by a loop 5rtT tl,-~ T II to a shorter equation.
Since the construction of such an information piece can be done with a subderivation of some fixed length, there must be a redundant recursion if the length of whole derivation exeeds a fixed value which is dependent on \[Hp\[ and \[S~\[ and exactly specified in lemma 21.1° 21.
LEMMA. Suppose that w E V~ is derivable with ¢ = ~xl ..xtx'l..x'k A S~(xl, .., x'k) over ~r of length n, that ~xl..xl A S~ Ix1,.., xl\] is a normal form of ¢ and that M o = (Up, ~o) is a minimal model of ¢.
If ~r has no redundant recursions then each path of wn is shorter or equal to IVN\[ . (3 \[Hol + 1)(IS~\[ + 1).
PROOF. Suppose, one path of wn were longer than IVN\[.
(3 \[Up\[ + 1).
(\[S~\[ + 1), then more than (3 I/~p\] + 1).
(\[S~ I + 1) different nodes on that path had to be labelled by the same A E VN.
Without loss of generality we can assume that lr is a derivation whose c-structure derivation w has the form Wo..wm..wn with wm= s\[u, A,, y\]~ for each node # on that path which is labelled by A (reorder if necessary).
In order to exclude that complex inferences are used to build up 0, we assume furthermore that 0 is non-deterministicaUy constructed from S ~ by recursive variable substitution, i.e. we require for each (X, aT) E 0 either x'~aT E S ~ or ~x~ay E S'((y,T) E 0).
Finally, let S C S ~ with S~ = S\[O\].
In order to identify the redundant recursion we have to consider the following cases.
1. Suppose there are more than \[Sv\[ + 1 A-labelled nodes # such that x i, does not occur in S ", then there must be more than \[Su\[ non-overlapping recursions.
For at least one of those recursions ~rm+~...Trm+k it must hold that (S \[~l S~+l_+rn_l_k) C (s~r.+rn \[.J S~n+k..kl_~n).
1°The given factor \[VN\[.
(3\[//p\[ + 1).
(\[S~\[ + 1) decreases for more restricted grammars, like e.g. grammars which allow only feature descriptions with single-rooted and/or acyclic minimal models.
49 But then Sn ~r S c_ ( 0-~m u Sm+,+~) and ~rm+~...7rrn+k must be redundant.
2. If case 1 does not apply there must be more than 3 I/4p\[ • (\]S~ I + 1) distinct A-labelled nodes # on that path such that x, occurrs in S ~ and for more than 31S-I + 1 of these nodes must pairwise hold ~.-z~ (h s ~ ~ x, ~ ~.~).
But then there must be at least three recursions such that and (S n s~+~_~+~+~+z) G ($8~ ~ s~\~+.+~+~_~.).
We can then assign to each recursion 7rm+l...Trrn+k (m=i,k=l; m= i +l,k=v or m=i+l +v,k= z) a type which corresponds to the strongest of the following conditions the recursion satisfies.
(a) ~,~+~...~m+~ satisfies (b) It holds only ~~..x~(A S~+~+~ ~ z,.~ ~ ax,) with lal > 0 and aO(x,)..~ O(x,) is implied by ~-Sxl..x'k(ASo'_,m+~ A S~) where S a is the set of ground literals of S.
(c) Or it holds t 7r with \]a' I > 0 and a'O(x,.~) ~ O(x,.~) is implied by ~~z~..z~(A S~+l~ A S~).
(d) If a recursion which satisfies (\[a I > O) is not of type (b) then there must be a ground term T which is not reducible in terms of x~, i.e. t? can not satisfy T = a'O(x,) for some non-empty prefix a', and (e) For a recursion with which is not of type (c) we get for x, the same property as for x,.~ in (d).
(f) If the previous cases do not apply, the recursion might satisfy with lal > 0 and Io'1 > 0.
Since x~, is not eliminable in terms of x,., and vice versa, there must be ground terms T, y' such that ~..~%(A s ~ 3 ~.
~ ~ A x..~ ~ ~' A ~ ~ ~').
(g) If a recursion is not of type (a-f) then ~3Xl..Xk( A Sm+l_~m+k D ax ~ x, A a'y ~ x~.~).
But then x, and x~.~ must be ground eliminable as in (f).
Since a recursion of type (a-c) is not redundant if it contains terms T or T' such that T is not reducible in terms of x, and r' is not reducible in terms of x~.~ and ~or T ~ are used to eliminate x, and x, ~, there must be at least one recursion 7r,~+l...Trm+k such that and 0 still follows either by ground inferences or due to the properties of (b) and (c).
\[\] If lmax = maxIw\[ l ((A,w),Srl e R} then the following pumping lemma follows immediately as a corollary.
22. COROLLARY.
Suppose that w E V~ is derivlr X I able with ¢= ~Xl..X~X~l..X~kAS (x,..,Xk) over of length n, that 3Xl..xl A Sv\[xl,..,xl~ is a normal form of ¢ and that Mp=(Hp,~p) is a miniI ~ Iwl "l IV~F(21U;l+l) then mal model of ¢.
j j l max w has the form uvzxy with vx >0 and for all i> 1: ! {~v~zx~y, \[~x~ ..z~ ~'~ ..
~'k/\ ^ S" (~, .., ~k)\]) e A.
PROOF. If Iwl > lWalx (~IupI+I) then at least one path ofwn is longer than \[VNI" (2 \]Hal + 1) and more than 2\[H;\[ + 1 different nodes on that path are labelled by the same A E VN.
Without loss of generality we assume again that 7r is a derivation whose cstructure derivation w has the form w0..w,~..w,~ with Wm = s\[u, A,, Y\]0 for each node p on that path which is labelled by A, and that 0 is non-deterministically constructed from S ~ by recursive variable substitution, i.e. we require for each (x, ar)E 0 either x~ffT e S ~r or 3x~ay • SW((y,T) • 0).
Suppose furthermore that S C S ~ with S~ = S\[0\].
In order to isolate the recursion which allows pumping we have to distinguish the following cases.
1. If 7r contains a recursion 7~m~l...7rm+ k with wm = s\[u,A~,y\]0, 03mWk = s\[u, Mv, A~.~,x\],,Y\]V and Ivx\[ > 0 and x~ and x,.~ do not occur in S ~, we take 71"mW1...Tl'rn+k.
2. If 7r does not contain such a recursion there must be at least three distinct A-labelled nodes ~, ~.A, ~.A.v on that path such that I' wi = S u,A~,y%, fv I A X I~ I1 w~+~=stu,At, ~.X, b,YJ0, ~+~+~ = s\[~', Ale, Air, A,.~.,, ~\],.~, ~'1~, V'\]0 with Iv'x'l > O, Irsl > 0 and ~~z~..z'k(A S '~ ~ z~ ~ z~.~,,~ z~.x.,). 2.1 Suppose there is a recursion of type (a-c) (cf.
proof of lemma 21) we choose this one.
2.2 If
7r does not contain such a recursion each of the recursions must be of type (d), (e), (f) or (g).
But then there must be one recursion "ffrn+l...'ffrn+k (m=i,k=Iorm=i+l,k:v) with I ff 50 for some ground terms T, T'.
This recursion is choosen for the proof.
On the basis of the recursion 7rm+i...TrmWk we can now define derivations r i as follows.
We set 7r i = r and define ~r i+i on the basis of 7r ~ by I(:\[U,A\[virxi\]~.~',Y\]o,S) ifj>m+ikand ~T~+I i = . ~J-~ = (s\[u,A\[vi-1,':~i-1\],.,.,~,-,,y\]~,S) ~rj if j <_m+ik and zv~ if j <_ m + ik \[#.ai.~ if j > m + ik and i ~j--k ---~.~i--l.t.
By induction on i it can then be shown for all possible cases that k 3x~..x~..(A S" A S').
\[\] 3.2 Invariance of the Parameters under Deductive Equivalence Since the universes of the minimal models of two deductively equivalent consistent feature descriptions must have the same cardinality, for the completion of the proof of theorem 13 it remains to be shown that two deductively equivalent consistent feature descriptions have the same "information content", i.e. that the sets of literals of their normal forms have the same cardinality: 23.
LEMMA. Suppose that 3Xl..Xi A S~rxi,..,xl\] and 3Yl..Yk A S~ \[Yi, .., Yk \] are deductively equivalent consistent feature descriptions in normal form then We proof lemma 23 in two steps.
First, we show that we can convert s'~rYl,..,Yk\] into a set S~\[xi,..,xl\] with the same cardinality such that 3xl..xl (A S~ rxl, .., Xl\] -~A S~' rxl, .., xl\] ) holds.
24. LEMMA.
Assume that 3xi..xl A S~rxl,..,xl\] and qyi..Yk A S~ \[Yl, .-, Yk \] are deductively equivalent consistent feature descriptions in normal form.
Then H l ---k and there is a set S~ rXl, ..,xl\] with H (i) IS,, rxi,.., :clll = is,, ryl,.., y,ql and (ii) I3x,..xl (A S,, rxl, .., xl\] _= A s~,, \[xi, .., xl\]).
PROOF. Suppose that {xl,..,xl} N {Yl,..,Yk} = (~ (rename if necessary), that S~\[yl,..,yk\] is in reduced form (the reduction of an independent set does not change the cardinality) and that M = (~, ~) is an arbitrary model of 3xi..Xl A S.rxi,..,xl\] and ~yl..ykAS'~ryl,..,yk\]p. Let a and a' be assignments such that a ~M Su\[Xl,..,xl\] and a' ~M S~\[Yl,..,Yk\];. We show first that there is a bijective function 1) • \[{Xl,..,Xl} ~ {yl,..,Yk}\] such that for all xi there is aai • F~ (i = 1, ..,l) and a variable 1)(xi) occurring in S' with a(xi) = ~(aiO(xi))(a').
First of all ~ is left-total, since a(xi)= ~(T) with T variable-free would imply that xi is eliminable in S.
In order to show that ~ is a function, assume a(xi) = ~(ajyj)(a*) = (~(ahYh)(a') for Yj,Yh occurring in S' with yj ¢ Yh.
Since yj and Yh are not eliminable in S' there must be terms Tj, Th such that a'(yj)-=~(Tj)(a), a'(Yh) = ~(Th)(OL), ~(O'jTj)(OI) ~~(qhrh)(O 0 and there is no a • Fi* such that ~(aTj)(a) = ~(rh)(a) or ~(aVh)(a) = ~(Tj)(a).
Thus, vj and Vh must be terms in T({xi,..,Xl}\{xi}) and xi would be eliminable in S.
Suppose now that yj is not in the range of 1).
Then there must be a term r with .~(T)(a) ---a'(yj).
Since yj is not eliminable in S', T must be of the form axi and there must be a term T' with a(xi) = .~(T')(a').
If T' is a term in T({yi,..,yk}\{Yj}), yj would be eliminable.
Otherwise r' is of the form a'yj and we would get a(xi) = c3(a'yj)(a').
Hence 1) is onto.
Assume finally a(xi) = ~(aiYh)(a') and a(xj) = ~(ajYh)(a') with xi ~ xj.
Then there must be a term r with a'(yh) = ~(T)(a).
Since xi and xj would be eliminable in S if T is a term in T({xi, ..,xl}\{xi,xj}), T is of the form axi or axj.
But then either a(z~) = .~(a~x~)(a) or a(x~) = ~(m~xA(~).
Thus, 1) is bijective and l = k.
On the basis of 1) we then define a sequence of new sets S~ (0 < i _< l) by induction as follows (within the induction we assume 1)(xi) -= y): s~ = s" ryl, .., yl\] p, \[s~_,\[y/~,\] if a(x,) = ~'(y) Si = ((S~_l \{y~o'o"y} )\[Y/o.x, \] U {x i ~ oJoxi} if (A), where (A) means a(xi) ~ a'(y), y~aa'y • S~_ 1 and a(xi) = .~(a'y)(a').
In the case where the variables refer to different nodes on a loop (a(xi) ~ a'(y)) the definition is well-formed, since S~\[yi,..,yl\]p is reduced and normalized and thus there must be exactly one equation y~aa'y in S~_ 1 describing the loop with the node to which xi refers.
For S" = S\[, IS~ rxl, .., xl\]l ~Is~ ryl,.., Yk\]l follows immediately by induction on the construction of S'.
Finally we get (ii), since 3xi..xi(3xi+l..x~ A S~ \[xi, .., xl\] 31)(x~+~ )..1)(xl) h s~ rx~, .., :~, 1)(x~+1 ),.., 1)(xl)\]) can easily be verified by induction on the construction of S".
\[\] Since two deductively equivalent independent and consistent sets of (variable-free) literals reduce to the same set of literals in reduced form, lemma 25 follows by skolemization and completes the proof of lemma 23.
25. LEMMA.
If Bxi..xl A Sv \[xi, .., xl\] is a consistent feature description m normal form andt3xi..xl(A S~rxi,..,xl \] ---A S'~'rxi,..,xl\]) then I&rzx,..,zlql --Appendix: Syntax and Semantics of Feature-Description Languages A feature-descriptionlanguage L(C) consists of the logical connectives -.~ (negation), D (implication), the equality symbol ~, the existential quantifier 3 and the parentheses (,).
The nonlogical vocabulary is given by a finite set of constants V (atomic values), 51 a possibly empty finite set of constants C (Skolemconstants) and a finite set of unary partial \]unction symbols F1 (V, C, F1 pairwise disjoint).
The class of terms and formulas of L(C) are recursively defined as usual.
Feature descriptions of L(C) are expressions of the form 3xl..xl A Six1, ..,xt\], where S is a finite set of (quantifier-free) literals.
(We assume that the connectives v (disjunction), A (conjunction) and (equivalence) are introduced by their usual definitions).
A model for L(C) consists of a nonempty universe b/and an interpretation function ~.
Since not every term denotes an element in/d if the function symbols are interpreted as unary partial functions, we generalize the partiality of the denotation by assuming that ~ itself is a partial function.
It is only required that all Skolem-constants denote.
Suppose IX ~-~ Y\] designates the set of all partial functions from X to Y and IX ~-~ Y\] the set of all total functions from X to Y, then a model is defined as follows: 11 DEFINITION.
A model for L(C) is a pair M = (b/, ~), consisting of a nonempty set b/and an interpretation function ~ = ~v U -~c U ~F1, such that (ii) ~c • \[C ~-+/d\], (iii) ~F, • IF1 ~ \[U ~/d\]\], (iv) Vf • Fl(f • Dom(~) ~ ~(f) ¢O).
If we extend the denotation function to terms and variable assignments c~, the definition of the satisfaction relation differs only in the clause for the equations from the usual one: O/ ~M T,~ T' iff ~(T)(C~) and ~(T')(C~) are defined and ~(T)(a) = .~(T')(~).
References Beierle, C., and U.
Pletat. 1988.
Feature Graphs and Abstract Data Types: A Unifying Approach.
In Proceedings of the 12th International Conference on Computational Linguistics.
Budapest. Kaplan, R., and J.
Bresnan. 1982.
Lexical-Functional Grammar: A Formal System for Grammatical Representation.
In J.
Bresnan, ed., The Mental Representation of Grammatical Relations.
Cambridge, Mass.: The MIT Press.
Johnson, M.
1988. Attribute-Value Logic and the Theory of Grammar.
Chicago: CSLI Lecture Notes Series, Chicago University Press.
Knuth, D., and P.
Bendix. 1970.
Simple Word Problems in Universal Algebra.
In J.
Leech, ed., Computational Problems in Universal Algebra.
Elmsford: Pergamon Press.
Shieber, S., H.
Uszkoreit, F.
Pereira, J.
Robinson, and M.
Tyson. 1983.
The Formalism and Implementation of PATR-II.
In B.
Grosz and M.
Stickel, eds., Research on Interactive Acquisition and Use of Knowledge.
SRI Final Report 1984.
SRI International, Menlo Park.
llIf constant-consistency and constant/complexconsistency are to be guaranteed for the atomic values V or acyclicity has to be ensured for the models, special conditions can be added to the definition.
Statman, R.
1977. Herbrand's Theorem and Gentzen's Notion of a Direct Proof.
In J.
Barwise, ed., Handbook of Mathematical Logic.
Amsterdam: Elsevier NorthHolland.
Wedekind, J.
1991. Classical Logics for Attribute-Value Languages.
In Proceedings of the 5th Conference of the European Chapter of the Association for Computational Linguistics.
Berlin. Wedekind, J.
1994. Some Remarks on the Logic of Unification Grammars.
In C.
J. Rupp, M.
Rosner, and R.
Johnson, eds., Constraints, Language and Computation.
London: Academic Press. 52

