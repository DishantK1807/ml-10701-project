Feature Graphs and Abstract Data Types: A Unifying Approach Christoph BEIERLE and Udo PLETAT IBM Deutschland GmbH Science and Technology LILOG P.O.
Box 80 08 80 7000 Stuttgart 80, West Germany (electronic mail on EARN/BITNET: BEIERLE at DS#LILOG, PLETAT at DS#LILOG) Abstract: Feature graphs appearing in unification--based grammar formalisms and algebraic specifications of abstract data types (ADTs) are both used for defining a collection of objects together with functions between these object sets.
Starting from this observation we define an algebraic semantics for feature graphs by assigning an algebraic specification to each feature graph.
This opens the rich world of semantical foundations for abstract data types to the area of feature graphs and thus to unification grammar formalisms.
Using results from ADT theory we define a sim~le and fast syntactic decision procedure testing the usual consistency conditions on feature graphs like constant consistency, constant/complex consistency and acyclicity on the algebraic specification assigned to a feature graph.
With this machinery at hand feature graph unification becomes union of feature graph specifications followed by the consistency test.
1. Introduction Unification-based grammar formalisms have become a popular field o'f research.
The subject has attracted the interest not only of (computer) linguists but also of computer scientists, especially in the area of logic programming, see e.g.
\[Pe 87\].
Due to the formality of grammars we also observe activities developing foundations for the formal semantics of various approaches on unification grammars, e.g.
\[PS 84\], \[KR 86\], \[RK 86\], \[Pe 87\], \[Jo 87\].
In this paper we investigate the relationship between feature graphs on the one hand and algebraic specifications of abstract data types (ADTs) on the other hand.
There is a natural correlation between both these areas since a feature graph as well as an abstract data type defines a collection of objects together with functions relating the objects.
We present a formal semantics for feature graphs by assigning to each feature graph G an equational ADT specification ~(G), called fg--specification.
This opens the rich world of ma'thematical foundations of ADT specifications (e.g \[GTW 78\], \[EM 85\]) in order to obtain a better not only formal understanding of the nature of feature graphs.
In particular, we provide a model-theoretic characterization of various consistency conditions for feature graph specifications reflecting the consistency concepts usually imposed on feature graphs such as clash-freeness and acyclicity.
These 40 model-theoretic characterizations have proof-theoretic counterparts in terms of syntactic conditions on the deductive closure of the set of equations of r(G)o Although the proof-theoretic consistency characterizations are of syntactic nature, a test of their validity requires to examine the deductive closure of the set of equations of a fg-specification.
Our objective is to restrict consistency checks to equations explicitly mentioned in a fg-specificationo In the ADT-world there is a well-known tool for such tasks: the Knuth-Bendix algorithm (\[KB 70\]).
We present a Knuth-Bendix like completion procedure transforming any fg-specification into a reduced normal form.
We show that the model-theoretic consistency characterizations for G are equivalent to the presence resp.
absence of certain types of equations in this reduced normal form.
These results are used for defining the semantics of the unification of two feature graphs GI and G2 as the (set-theoretic componentwise) union of ~(GI) and x(G2 ) followed by the normalization process using the completion algorithm and the consistency check on the resulting set of equations° 2.
Featuregraphs A feature graph is a directed graph with a distinguished root node.
The edges of the graph are called features.
An atomic graph is just a symbol; it contains no features.
A complex graph is a set of feature-value pairs where each value is either an atomic graph or again a complex one.
Two paths starting at the root and ending at the same node are said to co-.refer.
Feature graph unification is a binary eperation taking two graphs and returning\[ a graph containing exactly the informat J.on of both graphs if they are unifiabl~.
~, and fails otherwise.
An atomic graph is unifiable only with itself and the empty graph.
A complex graph G~ is unifiable with the, empty graph, and G~ is unifiable with a complex graph G2 if for all features in both G: and G2 the respective vahles are unifiab\](~° Several notations for feature graphs have been suggested° The graphical representation of NP could al~o be represented in matrix form: ~Cat I : VP Agr I Agr < 1 > in the matrix notation coreference is indicated by numbers enclosed in brackets.
Another notation, which for instance is employed in PATR, uses special equations indicati\[Lg coreference of paths and atomic values aL the end of of paths, respectively: < Cat > == VP < Subj Cat > == NP Subj Agr > : < Agr > In the following we will discuss an equatJon~l representation of feature graphs in greater detail.
This representation will be oriented towards the equational specification of abstract data types, thus making ~.vai lable the powerful machinery developed for such specifications° Above we did not make a clear distinction between the syntax for describing feature graphs and feature graphs as semantical objects.
In fact, such a distinction has been omitted to a large extent in the literature.
The situation changed with approaches that formalize the concepts of feature graphs since such a distinction is essential for a formal treatment (see e.g.
\[KR 86\], \[Jo 87\]).
In the area of ADT specifications the strict separation of the syntactic and the semantic level has ulways beet* a central aspect.
Our ADT-.based approach to feature graphs adopts this two-level view in a natural way: Feature graph specifications are the syntactical means to describe feature graphs which are the models (or structures) of such specifications.
3._Equational Specifications 3oi ADT Specifications: Syntax and Semantics We introduce the basic notions of abstract data type specifications.
More detailed information can be gathered in \[GTW 78\] or \[EM 85\].
A s.~gt_ure is a pair Z = <S, O> where S is a set of sorts and O = <O > a family of sets of ~erators w.r.t.
S. We write op: s~...s~ -> s for an operator whose i-th argument is of sort s~ and which delivers a result of sort s.
The well-fermed terms w.r.t.
Z and S-sorted variables V form an S-indexed family Tz (V), and an equation over ~ and V is of the form i = r where 1 and r are terms of the same sort.
An al~@hraic ~gcifiqation is a pair SP = <Z, E> where Z is a signature and E is a set of equations over Z and some family of variables V.
Besides these syntactical concepts of ADT specifications we provide the basic semantical concepts of heterogenous algebras: Given a signature ~ = <S, O>, a ~-algebra A consists of a family of sets A = < A, > .... and for each operator op e O .... there is a function opA : A, ---> A~ . A satisfies an equation 1 = r if for each assignment of values from A to the variables of 1 and r the evaluation of 1 and r in A yields the same element of A.
A is a <Z,E>-algebra if A satisfies every e ~ E.
We say that E semantically implies an equation e if every <~,E>-algebra satisfies e.
It is well-known that this model-theoretic notion of satisfaction coincides with the proof-theoretic notion of deduction (Birkhoff theorem) where e can be proved from E iff e can be deduced from E using the rules of the equational calculus (e.g.
\[EM 85\]).
We let E e denote the deductive closure of E.
The following theorem is one of the central results of ADT theory and forms the basis fo\]:" defining the semantics of a specification.
Theorem: For each algebraic specification SP = <~, E> there is an initial algebra Tsp satisfying the equations in E.
T~, is the so-called ~uotient term alqebr ~ consisting of congruence classes obtained by factorization according to the equations in E of constant terms over Z.
The initial algebra Tsp is 'the ADT specified by SP.
It can be characterized informally by two conditions: all its elements are denoted by some ground term ("no junk"), and it satisfies a ground equation e iff every other <Z,E>-algebra also satisfies e ("no confusion").
3,2 Feature Graph Specifications Feature graphs can be seen as particular algebraic specifications (see also \[Pe 87\]): 41 There are only constants (representing atomic values) and unary functions (representing the features) in the signature.
We assume that ATOMS is the set of all atomic values and FEATURES is set of all features occuring in the feature graphs; both sets may be infinite in general.
An equation s = t is given for paths having the same final node, or for paths ending at an atomic value.
For instance, consider the feature graph %/ Following e.g.
Pereira and Shieber (\[PS 84}) this feature graph can be described by the equations < f g > = < h > < g > = a leaving the root symbol of the feature graph implicit and using the order for the attributes as in the examples of Section 2.
However, in equational ADT specifications it is essential to state explicitly to which objects an equation can be applied.
For simplicitly, we first assume that we have only one sort which we call "universe", and that we have a variable x of sort "universe'.
By using a functional notation for the attributes and thus the reverse order of the attributes as compared to e.g.
\[PS 84\], we would arrive at the specification sorts universe functions a: -> universe f,g,h: universe -> universe equations g(f(x)) = h(x) g(x) = a However, by simply introducing a universally quantified variable x of sort "universe" we run into problems: From I, g(f(x)) = h(x) 2.
g(x) = a we can deduce h(x) = a by using the usual rules of the equational calculus and substituting f(x) for x in equation (2).
The problem is that x should be quantified only over all objects described by the original feature graph.
But f(x) is not neccessarily in this set, so we must find a way of avoiding such a substitution.
A simple way of achieving this is to switch to another signature with an additional sort, say "soi', denoting the "sort of interest" and comprising all objects described by a feature graph.
The sort "sol" is then a subsort of sort "universe'.
This could be expressed by extending the algebraic specifications to include also subsort relationships, thus moving from many-sorted specifications (as described in Section 3.1) to so-called order-sorted specifications (e.g.
\[GM 87\]).
Here, we want to stick to the simpler case of many-sorted specifications.
A subsort relationship in a many-sorted setting is expressed by an inclusion function 42 which we will.
denote by i: soi -> universe in our case.
In order to avoid problems with empty sorts (\[GM 87\], \[EM 85\]) we assume that there is a constant "const" of sort "sol'.
For the rest of this paper we also assume that x is a variable of sort "seA'.
Thus~ the feature graph above gi~es rise to the feature graph specification sorts sol, universe functions a: -> universe f,g,h: universe ~> uz~iverse const: .-> soi i: soi ~> universe equations g(f(i(x))) = h(i(x)) g(k(x)) = a motivating the following definition: A feature graph signature (fg-signature) Z = <S,OP> is a signature with S : {sol, ~lniverse} OP : Atoms(Z) u Features(X) u {const: -.> soi} U {i: SOJ -> universe} where : Atoms(E) c {a: -> universe I a s ATOMS\] Features(Z) c {f: universe -> universe \[ f s FEATURES} A feature graph specification (fg-.specification) SP ~ <Z,E> has a fg-signature Z and a set of equations over Z and {x}.
With the definitions above it shoud be obvious how to transform any feature graph G into a fg-specification ~(G): The signature of ~(G) contains all atoms and features occuring in G as constants resp.
unary functions, and for any co-referring paths or any path ending with an atomic value there is an equation in ~(G).
Thus, we have a well-defined function ~: Feature graphs -> fg-specifications making available the machinery that has been developed for algebraic specifications.
4. Consistency_ In \[PS 84\] the only inconsistency considered is an equation of the form a ~ b where a and b are distinct constants.
Such a situation Js called constant clash in \[Pe 87\] where additionally a constant L_cpmP!exf~lash is considered.
Such a clash is "any set of two equations e~ and e2 in which e~ equates some path p to some other path or atomic value and e2 equates a strict prefix of p to a constant" \[Pe 87\].
Whereas \[PS 84\] also consider cyclic feature graphs, Kasper and Rounds (\[KR 86\]), ~ome PATR-II implementations, and also the STUF formalism described in \[Us 86\], only allow for 99~fclic feature graphs.
We will show that the absence of cycles in a feature graph car~ also be expressed as a consistency condition on the corresponding fg-specification.
Below we use the machinery of abstract data types in order to define several notions of semantical, consistency for a feature grap\[b.
Finest W(-: introduce a rio_tat:ior% A texfa :;,,(...(f~(t))~ ).
~ 'r~(\[x\]) with t ~ T, (\[X\]),,,i .....
. .... fl ~ Features(Y,), and n k 0 will be writ'ten as p(t) where p := :,!.o~of~ e Features(}:)*o Note that the notation f.
( . . . (f~ (t)) . ..
) reflects -the usual mathematical notation for function composition, whei'eas the ~)ath notation amp Loyed for feature graphs as sketched :i(l Section 2 uses the reverse order Let S~' == -<}:~ \]!',> be cl .fg-;~pe<:ificatien.
A <}\]~ E>-al.gebra A is ~ cpn\[~tt~.g'h ~ g0nsiste~c Jff for all a, b ~.
Atoms(Z) with a ~: b we have : u cons tagt/<'.omp.\].ex cons.isten tiff for all a~ b ~ Atoms(Z) and a\]\] pl, p2, q ~ Feature~;(Z): tlhere exists ral element o ~ A,,,~,,¢:iti~: 7p\]~ (i~ (o)) :: a,, :: > p2,,(p\]., (i, (o))) + q^(i~(o)) & )/,2a(pl~ (i.(o))) ~b^ ac yc l'i,/ iff for all p~ q ~ Features(Z) ÷ there exists an element o ~ A,o± with: p~(q~(i^(o))) + q^(i^(o)) SP is .g_grn}italrt cons:Lste.l-tt, cor~staL~t/gpmplgx collsiste_lJt or" .gcycliq iff there is at least one mode\], of SP having the respective propert?
. The above definition of\[ censJstency of a fg-specifi~ation SP suggests that one has to search through the entire (:lass of models of SP in or, let to determJ ne whether SP :i s consistent or net.
The fol ).owing theorem shows the power ef initial models in the sense of shrinking the search space: only the initial model has to be considered.
Theorem : The fgspeei ficaT-ion SP is constant consistent, constant/complex consistent, or acyclic iff the initial algebra Ts~, has the respective property.
The above pz:opert:ies can be proven for the initial model by using the deductive closure E* of a set of equations E.
Theoz'em : The initial algeblTa \[I,',3 ~ of the fg-spec\[fication SP is u constant consistent iff for all a, b ~ Atoms(Z) with a + b We have: a :: 'b ~/ E* ~i coiL.~tar~t/complex consistent iff for all a~ b ¢ Atom:3(};) and all t)\[~ t :)2, q ~ Features(Z)" %'¥,~ have : pl('i(const)) = ;~.
~ E';," it~p\].ies p2(pl(i(const))) ::: q(i(const)) / E* and p2(pl(i(const))) = b / E* I acyclic iff for all p, q e Features(Z) ~ we have : p(q(i(const))) --: q(i(const)) / E* The equivalences established by these two theorems show us that the consistency of a fg-specification <Z, E> can be tested by inspecting tile deductive closure E* for the absence of certain equations, depending on which consistency aspects one is interested ill.
Since E* may be too large for performing these tests efficiently it would be desirable to be able to perform the consistency tests on E only.
ill the next section we develop a completion procedure for the set of equations E which transforms E into a normalized set E" such that it Js sufficient to check E'.
The complet.io~), procedure thus provides a simple and fast decision procedure for our consistency constraints.
5o _Ti)9 completion pr~cedure Our completion procedure is a variant of the Knuth-Bendix algorithm (\[KB 70\]) which J.s a well-known method for testing properties of rewrite rule systems and for transforming equations into a set of rewrite rules, which then constitute a decision procedure for the equality, in general, there are some problems with the Knuth-Bendix algorithm: \]it may not terminate, or it may terminate with failure.
However, we csn show that due to the restricted form of equations these problems do not occur when dealing with fg-specifications.
We first define an order relation ~ on the set T~ ({x}) of terms over an fg-signature Z.
We assume that ATOMS (resp.
FEATURES) is linearly ordered by ~^To~ (resp.
~ .... u~:~).
Then we order T~ ({x}) using the lexicographic ordering induced by NA~oMs and N~^TunE~ : Let a, b ~ ATOMS, f~, g~ e FEATURES, and t T~ ({x}).
a <,r b if a <^'roM~ b " a <T f, (t) t <~ f~ (t) f~,(...(f~ (t)))...
<.r g, (...(g~ (t)))... -<-T is the reflexive and transitive closure of <.~.
Let SP : <Z,E> be a fg-specification.
We assume that E does not contain any trivia\] equations of the form t :: t (otherwise we can just eliminate such equations from E).
Le~na: For all 1 = r ~ E we have either 1 <~ r or r <.~ \]..
Thus, without loss of generality, we assume that r <T 1 for all 1.
= r s E (otherwise we can just exchange the lefthand and the righthand side of the equation).
We call E a directed set of equations and we may write 1-> r instead of 1 = r.
43 C~letion algorithm CP Transform E into a directed set of equations and apply successively any of the two following rules until none is applicable any more: \[\] LHS reduction: If there are two different equations (I) p(1) -> r (2) 1 -> r' in E then: Delete equation (I) from E If r <T p(r') then add p(r') -> r to E If p(r') <~ r then add r -> p(r') to E \[Note: Nothing is added if p(r') and r are identical!\] • RHS__!'9_d" u c t ion !_ If there are two different equations (I) 1 -> p(l') (2) 1" -> r in E then: Delete equation (I) from E If 1 <~ p(r) then add p(r) -> 1 to E If p(r) <T 1 then add 1 -> p(r) to E \[Note: Nothing is added if p(r) and 1 are identical!\] where: r, r', i, i" ~ T~ ({x}), and p ~ Features(Z)* Theorem : For every fg-specification completion procedure CP SP the • terminates on input SP = <Z, E> delivers as output a fg-specification SP" = <Z, E'> and SP and SP'are equivalent in the sense of E* = (E')*, i.
e. E and E" have the same deductive closure.
This theorem assures that the completion procedure performs only syntactical modifications on the fg-specifications, but does not change their meaning.
So we can use SP" in order to test the consistency constraints of SP.
The next theorem shows that stepping from SP to SP" simplifies this task: instead of inspecting the deductive closure E* it suffices to inspect the set of equations E'.
Theorem: Let SP = <Z, E> be a fg-specification and SP" = <Z, E'> be the result of running the completion procedure CP on SP.
SP is Constant consistent iff E" does not contain an equation whose lefthand side is an atom a ~ Atoms(Z) constant/complex consistent iff E" does not contain an equation in which a term f(a) occurs where f ~ Features(Z) and a ~ Atoms(Z) acyclic iff E" does not contain an equation p(t) -> t where p ~ Features(Z)* 44 The proof of this theorem is based on the fact that E" is a confluent and terminating set of rewrite rules.
Since the atoms are smaller than any non-atomic term with respect to the term order <~, for any equation a --> t in E" with an atom a, t must also be an atom~ Therefore, any equation holding between atoms must be contained directly in E', implying the constant consistency property of the theorem.
The other parts of 'the theorem follow from similar observations.
6. Unification In Section 2 we presented three different notations for feature graphs, and in 3.2~ we introduced a translation ~ from feature graphs to fg-specifications.
On the other hand, it is straightforward to transform a fg-specification SP into a feature graph C: The atoms and features of G are those occuring in the signature of SP and £he equations of E reflect the coreferring paths resp.
paths ending with an atomic value in G° We denote this transformation by ~-~ : fg-specifications -> feature graphs Although ~-I (SP) and ~-i (CP(SP)) may be syntactically different since CP(SP)) contains equations in a reduced normal form, the two graphs are equivalent in the sense of feature graph unification: they are unifiab\].e with exactly the same feature graphs.
Besides giving a basis for a simple consistency test and providing a normal form presentation for fg-specifications the completion procedure CP also provides the basis for a precise mathematical definition of feature graph unification.
This is true regardless which consistency concept for feature graphs one wants to apply, e.g.
J.f one wants to allow cyclic graphs or only acyclic ones.
Thus, let X-consistent be either "constant consistent", "constant/complex consistent", "acyclic", or any combination thereof.
Let GI and G2 be feature graphs.
graph-unify(G~,G~) = let (Zi,Ei) = ~(Gt) in let (Z,E) = CP(Z~ u Z,, El u E2) in ~-I (Z,E) if (Z,E) is X-consistent fail if (Z,E) is not X-consistent 7.
Conclusions We have presented a mathematical semantics of feature graphs and feature graph unification in terms of ADT specifications.
It supports various consistency concepts used for feature graphs.
The important notion of partiality (\[Pe 87\]) in the sense that arbitrary new features may be unified into a feature graph is supported since any feature graph specification can be extended by arbitrary features, atoms, and equations; there exists no "largest" feature graph specification (unless of course, one adds an artificial "largest" element, e.g. as the $F$-specification in the STUF formalism as described in \[BPU 88\]).
Another approach bringing together initial ADT spec, i fications and feature graphs is given ill \[SA 87\].
~t uses an order-sorted approach:, where the set of atoms and features must be fixed in advance, and where every element of a supersort must be in one of its subsorts Compared to the ordersorte%l approach of \[SA 87\] a drawback of the work presented here is the asymetric treatment of the tool; of a feature graph (giving rise to the "se,i" sort) and the other nodes (being mapped t;o thE; "universe" sort ) . We are currently extending out work in order to overcome this disadvantage (\[BP 88\]).
Other a:¢eas of future work are the treatment of disjunctJ ons and of functional uncertainty (\[KR 86\], \[Jo 86\]).
References \[Ai e#\] Ait.-Kaci, H.
: A Lattice Theoretic Approach to Computai;ion based on a Calculus of Partially Ordered Type Structures.
\]?hD thesis, University of Pennsylw~nia, 1984 \[BP ss\] Beierle, C., Pietat, U.: %'he Algebra of Feature Graph Specifications.
(in preparat:ion) \[BPu 88\] Beierle, C., Pletat, U., Uszkoreit, If.: An Algebraic Characterization of STUF.
Proc. Symposium "Computerlinguistik und ihre theoretischen Grundlagen", Saarbr~cken 1988.
\[EM 88\] Ehrig, H.
and Mahr, B.: Foundations of Algebraic Specification I.
Springer Verlag, Berlin 1985.
Goguell, J.
G. and Meseguer, J.: Order-Sorted Algebra i: Partial and Overloaded Operators, Errors and Inheritance° Computer Science Lab., SRI International, 1987.
\[OTW 78\] Goguen, J.
A. and Thatcher, J.
W. and Wagner, E.: An Initial Algebra Approach to The Specification, Correctness and Implementation of Abstract Data Types.
In: Current Trends in Programming Methodology, R.
T. Yeh, (ed)~ Prentice-Hall, 1978.
\[Jo 86\] Johnson, M.: Computing with regular path formulas.
Draft, 1986.
\[Jo 87\] Johnson, M.
: Attribute-Value Logic and Theory of Grammar.
PhD Thesis, Stanford University, 1987.
\[KB 70\] Knuth, D.E.~ Bendix, P.B. : Simple Word _Problems in Universal Algebra.
in: J.
Leech (Ed.): Computational problems in Universal Algebra.
Pergamon Press, 1970.
\[Ka a6\] Kasper, R.T., Rounds, W.C.: A logical semantics for feature structures.
Proc. 24th Annual Meeting, ACL, 1986.
\[Pe 87\] Pereira, Fo : Grammars and Logics of Partial Information.
Proc. 4th Int.
Conf on f, ogic Programming, May 1987.
Pereira, F., Shieber, S.M.: The semantics of grammar formalisms seen as computer languages.
Proc. COLING-84, ACL, 1984.
Rounds, W.C., Kasper, R.: A complete logical calculus for record structures representing linguistic information.
IEEE Symposium on Logic in Computer Science, 1986.
Smolka, G., Ait-Kaci, H.: Inheritance Hierarchies: Semantics and Unification.
MCC Technical Report AI-057-87, 1987.
Uszkoreit, H.: Syntaktische and semantische Generalisierungen im strukturierten Lexikon.
Proc. GWAI-86, (eds.
C.R. Rollinger, W.
Horn), Springer Verlag 1986 .

