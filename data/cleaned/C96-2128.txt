Reversible delayed lexical choice in a bidirectional framework Graham Wilcock* Centre for Computational Linguistics University of Manchester Institute of Science and Technology PO Box 88, Manchester M60 1QD United Kingdom grahamOccl, umist, ac.
uk Yuji Matsumoto Graduate School of In%rmation Science Nara Institute of Science and %chnology 8916-5 Takayama, Ikoma, Nara 630-01,Japan matsu~is, aist-nara, ac.
jp Abstract We describe a bidirectional framework for natural language parsing and generation, using a typed feature formalism and an HPSG-based grammar with a parser and generator derived from parallel processing algorithms.
We present an approach to delayed lexical choice in generation, based on subsumption within the sort hierarchy, using a lexicon of nnderinstantiated signs which at'(; derived fi'om the normal lexicon by lexical rules.
We then show how delayed lexical choice can be used in parsing, so that some types of ill-formed inputs can be parsed, but wellformed outputs are generated, using the same shared linguistic information.
1 A
bidirectional framework In our bidirectional framework for a natural language engine, the linguistic descriptions in the grammar and lexicon are shared resources which are used, in appropriately compiled forms, for both parsing and generation.
Like the Core Language Engine (CLE) (Alshawi, 1992), we use a unification-based phrase structure grammar, a logical form representation, a bottom-up chart parser and a semantic head-driven generation algorithm.
However, we (lifter from CLE by exploiting recent developments in processing algorithms and in linguistic representation formalisms.
We will clarify the similarities and differences at; the relevant points.
1.1 Processing
algorithms The SAX parser is a concurrent SICStus Prolog implementation of the PAX parallel pro'sing algorithm (Matsutnoto and Sugimura, 1987; Matsumoto et al., 1994).
Like the earlier BUP parser to which the CLE parser was closely related, SAX uses partial execution to compile the gramlnar for efficient bottom-up parsing.
However, instead of *Visiting researcher of Information Systems Product Development Lalmratories, Sharp Corporation.
building the chart by asserting edges into the Prolog database, SAX implements the chart by creating concurrent processes.
For compiled rather than interpreted Prolog systems, this is a highly etficient form of chart, parsing, even on sequentim machines.
The terminal and non-terminal symbols of the grammar are realized as processes which communicate via streams to build larger structures.
A meta-process monitors tile strealns and controls l;he whole parsing process.
The SGX generator is a concurrent SICStus Prolog implementation of the BCG parallel bidirectional chart generation algorithm (Haruno et al., :1993; Den, 1.994).
SGX uses partial execution to compile the grammar lot' efficient generation.
Like the CLE generator, SGX follows the semantic head-driven (SHD) generation algoril;hm (Shieber et al., 1990) to ensure efficient ordering of the geImration process.
However, SGX also implements tile suggestion of Shieber et.al, thal; backtracking and recomputation of results should be avoided by using a chart, as in chart parsing.
Like SAX, SGX implements the chart by concurrent processes and coininunication streants monitored by a meta-process.
SAX and SGX accept definite clause grammars, with specific requirements to eliminate nondeterminism.
Prolog code can be added to DCG rules as extra conditions, but tile extra conditions must be deterministic.
Empty categories are not supported in normal processing, 1 and SGX does not allow non-chain rules with uninstantiated logica.1 forms.
1.2 Grammar
formalism Large DCG-t)ased grammars typically have many rules, many categories, and many arguments per category.
Such grammars could be efficiently protossed by SAX and SGX, but are ditficult to del If empty categories are really imcessary, they can be handled in the concurrent processing system via a recta-process.
This approach is described in (hnaichi and Matsumoto, 1995) tbr ill-tbrmcd inputs.
However, we eliminate traces by lexical rule, and welcome tlte proposals of (Sag, 1.995) for eliminating all empty categories from ItPSG.
758 veh)p and debug.
CLE addressed this t)roblem t)y adopting GPSG grammatical theory mid ext)ressing linguistic descriptions as flmture structures, but the CI,E grmnmm' still had many arguments per category and many rules.
We adopt Itl)SG grammatical theory (Pollard and Sag, 1994) and express linguistic descriptions in a l;yI)e(1 feature formalism, lint we still ilnt)le, ii~lent the grammar in 1)CG forln.
Sin(:e HPSG colle('.ts all fe, atures into a strut> tured sign, the many I)CG a.rguments are repla(:ed by a single HPSG sign.
As H1)SG generalizes fl'om category-based rules (for S, NP, el;t:).
to schenms for phrasal signs, the many 1)CG rules are rel)lat;ed 1)y a few generalized rules.
We sl)ecify a sepa.rate logi(:al form (LF) f()r generation, as in (Shieber et al., \]990).
Our I)CG' categories therefore have the fin'mat word(Sign)/LF and phrase (S ign)/LF.
2 phrase(synsem!loc!( cat!(head!HF g subcat!@listl(SubjSynsem) cont!Cont))/if(Cont) # word(synsem!loc!( cat!(head!HF & subcat!@listl(SubjSynsem)) & cont!Cont))/If(Cont).
Figure 1: The sour(:e form of a grammar rule Figure 1 shows the source form of a simplified version of ItPSG Scheina 2 with zero eoint)h',nmnt daughters.
~list 1 is a l;emplate which ext)ands to a list; wil;h one meml)ei'.
The # symbol is required by SGX to identify the semantic, head of ~ chain rule for SlID generation.
1.3 Grammar
compilation The ProFIT system (Erbaeh, 1995) iv an extension of fq'olog whic, h SUl)ports a typed feature formalisin with multiple inheiitalwe.
CLE used a sort hierarchy only for senlantie seleetional restrictions.
HPSG uses a sort hierarchy also for syntactic resl;rictions, aim exploits multiple inheritmme for lexicon organization.
2In this pape, r we follow (Shieber et al., 1990) and (Pollard add Sag, 1.994) in equating logical form with semmltic content.
A separate logical form is therefore redundant, as the.
content fe.ature could /)e used to <:ontrol SHD generation.
Itowever, logical form may need to include other inforination, suet, as unscot)ed quantifiers (HPSG qstore), i)resul)positions (IIPSG context), pragmatic and discourse factors (in fact Shieber et al.include mood ot)erators ).
An important consequence of this is that a semmttic head in the sense of the IIPSG Content Princil)le is not necessarily a semantic head in the sense of the StID generation algorithm.
ProFIT compiles the, typed hmture formalism into Prolog terlns, which can be used with any appropriate parser or generator.
We therefore use I)roFIT in order to combine I\[PSG g~ra,lrllIl&r with the SAX l)a,i'ser and the SGX generator, 1)y (;{)titpiling the grmnmar in two separate stages.
In the tirst stage, the typed feature structures in the I)CG rules are compiled by I'roFIT into efficient Prolog terms.
Like CI,E, ProFfl' t:ompiles feature, structures into terms, so that relatively slow unification of fe, ature strucl;ures is ret)laced t)y relatively fast mfitication of terins.
Also like CLE, l'rol!Tl' uses the technique of (Mellish, 1988) tbr compiling finite domains such as index agreement into booh;an vectors for fast unification.
In the second stage, tlle resulting I)C(\] containing only Prolog terms is COml)ih',d sel)a.rately by the SAX l, rmmlator t'or pa,rsing mid 1)y the SGX trallsl&tor for generation.
(~rgtHin&r rules Call 1)e labelled to be compiled only by SAX or only by SGX, st) thai, parsing could for e, xaml)le use some rules with wider coverage l;han others used in genergttion, while sharing I\[IOSt of the gra, innl&r.
Like the earlier BUP parser, the SAX translat;or uses t)art;ial execution to t)roduee efficient code for bol;1;om-ut) (:hart t)arsing.
The SGX transla, tor eontl)iles tal)les of chain rules and also uses partial ex(~eution to l)rt)dut:e efliehmt code for Sill) (:ha,rt ge, ncration.
1.4 Lexicon
compilation We, do not compile tile lexicon off:line ill/;() a static list of signs.
Instead, the existence of a lexieal sign is proved on-line by lexical inlhrence rules.
We specify a morph, ological lexicon inl;erfiu:e morph_lex(Forn,, Cat, \[LF, Sign\]) where N)rm is ~.~ specific morl)hological form, and Sign is a typed li,~atut'e structure.
A lexieal inference ruh, is shown in simplified form in Figure 2.
In ProFIT, sorts axe writl;en as <sort and features as feature ! value.
morph_lex(Vbse, word, \[if(Cont), synsem!loc!( cat!(head!(vform!<bse & aux!<n & inv!<n) & subcat!@listl(loc!( cat!(head!<noun subcat!<elist cont!(Subj g index!<ref)))) cont!(Cont ~ <psoa & quants!<elist & nucleus!(reln!Reln Role!Subj)))\]) verb(Vbse, Rein, \[np/Role\]).
Figure 2: A morphJex rule for a verb base form 759 We use lexical inference rules to derive flfll HPSG lexical signs from a database of simple Prolog clauses.
Such rules can partially re-use available non-HPSG lexical information.
The example assumes a lexical entry such as verb(walk, walk1, \[np/agent\]) specifying a verb with base form walJg and sense, walk1, which subcategorizes for a noun phrase subject assigned to a thematic role agent.
We also use rules like normal HPSG lexical rules, to derive new signs fl'om other lexical signs for morphological derivations, complement extraction and so on.
We have no automatic defaults, so these rules must be written carefully.
The simplified example in Figure 3 instantiates nominative and 3rd singular in the first subcat item, and copies the rest of subcat by unification.
morph_lex(V3sg, word, \[if(Cont), synsem!loc!( cat!(head!(vform!<fin aux!<n & inv!<n) subcat!(first!loc!( cat!(head!case!<nom subcat!<elist) cont!(Subject index!agr!(3&sg))) rest!Rest)) cont!(Cont & nucleus!reln!Reln))\]) morph_lex(Vbse, word, \[if(Cont), synsem!loc!( cat!(head!(vform!<bse aux!<n & inv!<n) subcat!(first!loc!( cat!(head!<noun subcat!<elist) cont!Subject) g rest!Rest)) cont!Cont)\]), morph_infl(verb_3sg, Vbse, Reln, V3sg).
Figure 3: Lexical rule for 3rd singular verb form The typed feature structures in the lexical rules are compiled by ProFIT into Prolog terms.
The resulting rules arc then compiled by SICStus Prolog, together with the database of simple lexical entries.
2 Delayed
lexical choice Delayed lexical choice is an established technique in natural language generation.
When a backtracking algorithm is combined with a lexicon of morphological forms, there is considerable nondeterminism during syntactic generation, because features required for a deterministic choice of morphological form are not yet instantiated.
With delayed lexical choice, a lexicon of stems is used during syntactic generation, and the choice of morphological form is delayed to a postprocess.
Instead of producing a string of word forms, syntactic generation produces a string of lexical items.
The morphological postprocess converts the lexical items to final lexical forms, when all required syntactic features have become instantiated.
2.1 Monotonicity
Describing the implementation of delayed lexical choice in the MiMo2 system, Shieber et al.(1990) pointed out that only monotonic rules (which tiltther instantiate the feature structure of a lcxical item but do not change it) can be delayed.
For example, the choice of singular or plural verb i'orm can be delayed until after the subject has been generated, by perforIning syntactic generation with a lexical item based on the verb stem, which does not specify singular or plural.
By contrast, a lexical rule for passivization which changes the order of items on the subcat list is nonmonotonic.
Both the active and the passive variants must be made available as distinct lexical items during syntactic generation, a In an inheritance-based typed feature formalism, monotonicity is tmilt into the subsumption relation in the sort hierarchy.
A sort subsumes its subsorts, which may further instantiate its features, but cannot change them.
We exploit tile monotonicity of subsumption in the sort hierarchy in our implementation of delayed lexical choice.
2.2 Syntactic-semantic lexicon In place of the MiMo2 lexicon of stems, we specify a syntactic-semantic lezicon interface synsemJex(Lex, Cat, \[LF, Sign\]) where Lex has no significance for generation.
Entries in tile syntactic-seInantic lexicon are derived by a small number of lexical rules from entries in the morphological lexicon.
Like the morphJex rules, the synsem_lex rules are compiled first, by ProFIT and then by SICStus Prolog.
To implement delayed lexical choice, we use the synsem_lex interface during syntactic generation, and then use the morph_lex interface in the morphological postprocess.
We must therefore ensure that the delayed morph_lex rules will be monotonic.
We do that by ensuring that tile synsem_tex entries subsume the morphJex entries from which they are derived.
Figure 4 shows a simplified form of a synsem_lex rule for verbs.
The rule derives the synsemJex entry from tile morphJex base form entry, in which vform has a vahm of sort <bse.
The subcat of the synsem_lex entry is unified with the subcat of the awe currently make such variants available via alternative forms of the lexicon access rule (Section 2.3).
This could be improved by using constraints to enable subcat-changing rules to be delayed (van Noord and Bouma, 1994; Meurers and Minnen, 1995).
760 morph_lex entry, so that the synsem_lex entry subcategorizes for the appropriate synt;actic compleinents.
The morptl_lex base form entry is used so that the agreement Datures of tile subject, will not t)c restricted.
The content vahte, s are also unified, so that the synseni_lex entry inchldes the approI)riate semantic roles.
However, the head Datures are not unified.
Tile synsemJex vform has a value.
of sort <vform, wtfich is tim immediate supersort of the mort)hJex vform sort, <bse.
Instead of flfll unification, the synselnJex hea(l feat,ures sut)sumc those of the morI)hJex entry.
synsem_lex(Lex, word, \[If(Cont g <psoa), synsem!loc!( cat!(head!(vform!<vform aux!<n & inv!<n) subcat!Subcat) cont!Cont)\]) morph_lex(Lex, word, \[if(Cont), synsem!loc!( cat!(head!(vform!<bse aux!<n & inv!<n) subcat!Subcat) cont!Cont)\]).
Figure. 4: A synsem_le.x rule for verbs 2.3 Grammar-lexicon interface In I)CG-based systems, the interface between the grammar and the lexicon can often }m speciiied by a DCG rule which accesses the lexicon by means of an extra condition.
In our fl'amework, such a rule might, be: word (Sign)/LF --> \[Word\], {morph_lex(Word, word, \[LF, Sign\])}.
Ilowevcr, since our concurrent t)roeessing algorithms require extra conditions to be deterministic, such a rule would find only one lexical entry (the first unifiable one), which would depend on the order of lexical rules and lexical entries.
For parsing this is not a problem because, like CLE, wc use a morphological preprocess which performs lexicon access, building a morpheme lattice to be passed to the syntactic parsing protess.
Lexicon access is therefore separated from the parsing algorithm, and is not required to be deterministic.
For generation with delayed lexical choice, we use a modified form of the nile: sgx word(Sign)/LF --> \[Sign\], {synsem_lex(Word, word, \[LF, Sign\])}.
The label 'sgx' shows that the rule is to be compiled only by SGX, not by SAX.
It differs from the previous rule not only by accessing the synt,act,icsemantic lexicon instead of dm morphological lexicon, but also by speci\[ying that the lexical item is \[Sign\] instead of \[Word\].
That is, the output of syntactic geueration is a string of HPSG signs.
2.4 Semantic
head-driven generation When syntactic generation begins, the StlD algorithm uses chain rules (like the rule ill Figure 1) to identify tim piw)t, the semantic head of the scnt,ence.
The synsem lex entry for the pivot is then accessed by the.
extra condition in tile DCG rule above..
Since the synsem_lex entry for verbs (Figure 4) does not specify subject agreement or vform subtype, but does specify subcategorization and semantic roles, it can be used equally well as the sc.mantle head to drive syntactic generation of, say, a 3rd-singular finite clause or an infinitival eomt)lemt;nt.
Since a single entry ('.all be used in this way, the extra condition can be detcrtninist,ic, as required.
If the verb is the head of an infinitiwll con> p\]enlent, its vfornl l/econles ilmtant,iat,ed to <bse fl'om subcategorization by the auxiliary to.
If t,hc vert) is the head of tlte main clause, its vform beeonms instantiated to <fin (finite) by a rule R)r grammatical mfit,s in our grantmar.
4 After
syntactic generation, the string of IPSG signs is conw~rted to a string of word forms by a morphological t)ostprocess, which unifies the signs with entries in the.
inorphological lexicon.
As the signs are t\]llly instantiated during syntactic generation, this postprocess is also deterministic.
a Reversible delayed lexical choice Most forms of robust parsing are based on coilstraint, relaxation.
Our approactl to delayed lexical choice is based on using less instantiated signs flom the syntactic-semantic lexicon, rather than the more instant,iated signs from the morphological lexicon.
Tiffs can be viewed as equivalent to constraint, re.laxation.
It therefore seelns reasonable to consider reversing the approach, using delayed lexical choice for parsing.
Constraint, relaxer,ion in parsing typically has a two-pass approach.
Strict parsing is attempted with normal gralmnar rules and the normal parsing algorithm.
If strict parsing fails to produce a parse, relaxed parsing is attempted, using a modified algorithm or modified grammar rules.
With a lexicalist grammar like HPSG it seems more appropriate to use modified lexical rules, as in our syntactic-semantic lexicon.
4In addition to the HPSG categories word and phrase, we have a category gram_unit for grammatical units which can be uttered independently.
These include finite sentences, accusative NPs, and others.
The rule for gram_unit thus instantiates certain thaI, ures which arc" required for well-formed generation.
761 However, in our approach to delayed lexieal ehoice we do not start with strict constraints and then relax them.
On the contrary, we start with relaxed constraints from less instantiated signs and then further instantiate the signs as other constraints become available.
Our approach is therefore incremental description refinement (Mellish, 1988) rather than constraint relaxation.
3.1 Parsing
and generation with delay When the syntactic-semantic lexicon is used for generation, tile logical form is the retriewfl key, and the name of the lexeme is irrelewmt.
In tile interface synseIn_lex(Lex, word, \[LF, Sign\]), the variable Lex does not need to be unified with the name of the morpheme in tile morph_lex entry, and could be given another value, such as "verb".
However, if we use the syntactic-semantic lexicon for parsing, tile value of this variable will be the retrieval key.
If the value is taken directly from the words of the input string, it will not necessarily unify with the name of the morpheme in the morph_lex entry.
In the case of verbs (Figure 4), where the input word may be an inflected form but the synsem_lex entry uses the morphJex entry for the base form, we nmst first use the morphological preprocess to obtain tile "root" form of the word, which is the same as the base form.
We then use tile root form instead of the input form as the retrieval key.
In the ease of pronouns, which take different forms according to case and reflexivity but have no natural root form, the input form is used directly as the retrieval key (Section 3.2).
Since the synsem_lex entry for verbs in Figure 4 does not restrict subject agreement, an illformed input with ineorrect subject-verb agreement is parsed in exactly the same way as a wellformed intmt.
The'subject agreement in the verb's sign remains uninstantiated until the subject and the verb phrase are combined by Schema 1, when the agreement features are instantiated to those of the subject.
So "she swim" is accepted, but only "she swims" is generated ill a finite clause.
Tile synsemAex entry in Figure 4 also does not, restrict vform, which remains uninstantiated until the verb phrase is combined into a larger phrase.
So "she can swimming" is accepted, but only "she can swim" is generated, since "can" subeategorizes for a VP with vform of sort, <bse.
3.2 Experimenting
with delay Of course, difl'erent specifications in tile rules for the syntactic-semantic lexicon produce different etfects.
In tile synsem_lex entry for pronouns in Figure 5, instead of unifying tile head feature case with the morphJex entry, the head is specified only as sort <noun, leaving the case unspecified.
There are distinct morphJex entries for nominative and accusative forms of personal pronouns, but it is irrelevant which one happens to be found when the rule is executed, because the rule does not unify the head features which include case.
So the synsem_lex entry can be used deterministi(:ally for syntactic generation, leaving tile case to be instantiated from subcategorization by a verb or preposition.
In parsing, tile effect of this form of the rule is that the case of an input, pronoun is ignored.
Whether this is good or bad depends oil both the language and tile level of relaxation desired.
This form of the rule would clearly be unsuitable tbr free word order languages, but seems useful for English, accepting "for yon and I" but generating '~for you and nle '~. synsem_lex(Lex, word, \[if(SynsemCont), synsem!loc!( cat!(head!<noun subcat!<elist) cont!(SynsemCont & <pron index!Index restr!<elist))\]) :morph_lex(Lex, word, \[if(MorphCont), synsem!loc!( cat!(head!<noun subcat!<elist) cont!(MorphCont ~ <pron index!Index restr!<elist))\]).
Figure 5: A synsem_lex rule for pronouns In Figure 5, the synsem_lex content value is not unified with the morphJex content vahm.
Only the index values are unified, including tile gender, number and person features essential for pronouns (tile restr vahms are elnpty lists).
The contant values are constrained only to be of sort <pron (pronominal).
Ill the sort hierarchy, <pron has subsorts <ana (anaphoric) and <ppro (personalpronominal), and <ana has its own subsorts <ref 1 (reflexive) and <recp (reciprocal).
HPSG binding theory is based on these sortal distinctions, which are part of the content value.
Again, there are distinct morphJex entries for reflexive and personal-pronominal forms, but, it is irrelevant which one happens to be found when the rule is executed, because the rule does not unify the content values.
Therefore the synsemJex entry can be used deterministically for syntactic gem eration before the sort, becomes instantiated to <ana or <ppro by the binding principles.
Tile effect of this form of tile rule is to relax the binding constraints in parsing, accepting "I saw me" but generating "I saw myself".
Of course tile distinction between "They saw themselves" (coindexed) and "They saw them" (eontra-indexed) is also lost in parsing with this version.
The bind762 ing constraints can l)e re-instated simply by unifying the content values in the rule, but the above version is not neee.ssarily bad, for example in parsing non-native English.
The rule could t)e imt)roved by having alternative forms which distinguish ard and non-ard person.
4 Conclusion
Our fralnework seeks to combille the elegance of a typed feature fornlalisln and IIPSG syntactic theory with efficient processing.
The ProFIT system gives an efticient encoding of typed feature structures.
The SAX and SGX systems use an efficient (:hart implementation, and their concurrent processing algorithms give turther motivation for eliminating enlpty categories and reducing nondeterminism.
Wc have addressed the issue of bidirectional use of shared linguistic descril)tions, rather than robust parsing.
Itowevcr, the idea of using delwed lexical choice in reverse makes it possible, widlout modifying the parsing and generation algorithms, to parse certain types of ill-formed inputs and to generate corresponding well-formed outpul, s, using the same shared linguistic descril)tions.
Acknowledgements The first author would like to thank Mr Ilitoshi Suzuki (Sharp Cort)oration ) and Prof aun-ichi Tsujii (UMIST) for making this work possible.
We also thank Dr Kristiina aokinen (NAIST) and the anonymous reviewers for valuable conlinetll;s.
References Hiyan Alshawi, editor.
1992. The Core Language Engine.
The MIT Press.
Yasuharu l)en.
1994. Generalized chart algorithm: an efficient t)rocedure for cost-based abduction.
In 32nd Annual Meeting of the Association for Computational Linguistics, pages 218 225.
Association for Computational Linguistics.
Gregor Erbaeh.
1995. ProFIT: Prolog with Features, Inheritance, and Templates.
In Seve'nth Conference of the European Chapter of the Association fin" Computational Linguistics.
Association for Computational Linguistics.
Masahiko Haruno, Yasuhm'u Den, Yuji Matsumote, and Makoto Nagao.
1993. Bidirectional chart gene.ratioil of natural language texts.
In Proceedings of the Eleventh National Conferertcc on Artificial lntclligence, pages 350 356.
AAAI Press/The MIT Press.
Osamu hnaichi and Yuji Matsumoto.
1995. Integration of syntactic, semantic and contextual information in processing grammaticMly ill-fi)rmed inputs, in I)~vccedings of the Fourteenth International Joint Conference on Artificial lntelligenes, pages 1435 40.
Yuji Matsumoto and \]{yoichi Suginmra.
1987. A parsing system based on logic programming.
In Proceedings of the Tenth International Joint Conference on ArliJieial Intelligence, volmne 2, pages 671 4.
Yuji Matsumoto, Yasuharu l)en, and Takehito Utsuro, 199,1.
Koubun kaiseki shisutem'a SAX, shiyou setsumcisho (Parsing system SAX Manhal) w'.rsio'u 2.1.
Nm'a Institute of Sci('nc(~ and Technoh)gy.
Christoph(:r S.
Mellish. 1988.
hnph'mcnting systemic classification |)y mfitication.
Compv.tational Linguistic, 14(1):40 51.
W. Detmar Meurers an(\[ Guido Minnen.
1995. A (:omputational treatment of IIPSG lexical rules as cow~riation in lexical entries.
In Proceedings of the I~fth International Workshop on Natural Language Understanding and Logic l'rogramruing, Lisbon, Portugal.
Carl Pollard and Ivan Sag.
1994. Head-driven Phrase Structure Grammar.
University l'ress, Chicago.
Ivan Sag.
1995. English relativ( • (:lausc construedons.
Unpublished inanuscript.
Stuart M.
Shiet)er, Gertjan wm Noord, Fernando C.N.
P(;reira, and lobert C.
Moore. 1990.
Semantic head-driven generation.
Con> putational Linguistics, 16(1):30 42.
Gertjan van Noord and Gosse Bouina.
1994. Adjuncts and the 1)recessing of lexical rules.
In 15th International Conference on ComFurational Linguistics.
Association for Computational IAnguistics. 763

