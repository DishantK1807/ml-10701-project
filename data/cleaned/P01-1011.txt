Underspecified Beta Reduction Manuel Bodirsky Katrin Erk Joachim Niehren Programming Systems Lab Saarland University D-66041 Saarbr¨ucken, Germany {bodirsky|erk|niehren}@ps.uni-sb.de Alexander Koller Department of Computational Linguistics Saarland University D-66041 Saarbr¨ucken, Germany koller@coli.uni-sb.de Abstract For ambiguous sentences, traditional semantics construction produces large numbers of higher-order formulas, which must then be a0 -reduced individually.
Underspecified versions can produce compact descriptions of all readings, but it is not known how to perform a0 -reduction on these descriptions.
We show how to do this using a0 -reduction constraints in the constraint language for a1 -structures (CLLS).
1 Introduction
Traditional approaches to semantics construction (Montague, 1974; Cooper, 1983) employ formulas of higher-order logic to derive semantic representations compositionally; then a0 -reduction is applied to simplify these representations.
When the input sentence is ambiguous, these approaches require all readings to be enumerated and a0 reduced individually.
For large numbers of readings, this is both inefficient and unelegant.
Existing underspecification approaches (Reyle, 1993; van Deemter and Peters, 1996; Pinkal, 1996; Bos, 1996) provide a partial solution to this problem.
They delay the enumeration of the readings and represent them all at once in a single, compact description.
An underspecification formalism that is particularly well suited for describing higher-order formulas is the Constraint Language for Lambda Structures, CLLS (Egg et al., 2001; Erk et al., 2001).
CLLS descriptions can be derived compositionally and have been used to deal with a rich class of linguistic phenomena (Koller et al., 2000; Koller and Niehren, 2000).
They are based on dominance constraints (Marcus et al., 1983; Rambow et al., 1995) and extend them with parallelism (Erk and Niehren, 2000) and binding constraints.
However, lifting a0 -reduction to an operation on underspecified descriptions is not trivial, and to our knowledge it is not known how this can be done.
Such an operation – which we will call underspecified a0 -reduction – would essentially a0 reduce all described formulas at once by deriving a description of the reduced formulas.
In this paper, we show how underspecified a0 -reductions can be performed in the framework of CLLS.
Our approach extends the work presented in (Bodirsky et al., 2001), which defines a0 -reduction constraints and shows how to obtain a complete solution procedure by reducing them to parallelism constraints in CLLS.
The problem with this previous work is that it is often necessary to perform local disambiguations.
Here we add a new mechanism which, for a large class of descriptions, permits us to perform underspecified a0 -reduction steps without disambiguating, and is still complete for the general problem.
Plan. We start with a few examples to show what underspecified a0 -reduction should do, and why it is not trivial.
We then introduce CLLS and a0 -reduction constraints.
In the core of the paper we present a procedure for underspecified a0 -reduction and apply it to illustrative examples.
2 Examples
In this section, we show what underspecified a0 reduction should do, and why the task is nontrivial.
Consider first the ambiguous sentence Every student didn’t pay attention.
In first-order logic, the two readings can be represented as a2 a3a4a6a5 a7 a8 a2 a9a11a10a13a12 a14 a4a16a15 a2 a14 a4a16a15 a14 a4a16a15 a3a4a6a5 a2 a17 a4a19a18a20a4 a10a13a10 a14 a4a16a15 a21 a22a24a23 a25a27a26 a25a27a28 a25a27a29 a25a31a30a25a32a23 a25a27a33 a25a35a34 a25a37a36 a7 a8 a2 a9a11a10a38a12 a14 a4a16a15 a2 a3a4a6a5 a2 a17 a4a19a18a20a4 a10a39a10 a14 a4a16a15 a14 a4a16a15 a21 a22a40a33 a41a43a42 a41a43a26 a41 a28 a41a43a36 a41a43a29 a41a44a30 a7 a8 a2 a9a11a10a13a12 a14 a4a16a15 a2 a17 a4a19a18a20a4 a10a13a10 a14 a4a45a15 a21 a22a40a28 Figure 1: Underspecified a0 -reduction steps for ‘Every student did not pay attention’ a2 a2 a46 a14a48a47 a15a49a18 a9a11a10a13a12 a3a4a6a5 a2 a17 a4a19a18a20a4 a10a39a10 a14 a4a16a15 a21 a22a50a26 a51a52a26 Figure 2: Description of ‘Every student did not pay attention’ a7a27a53a55a54 a9a11a10a38a12 a53 a8 a21 a54 a17 a4a19a18a20a4 a10a39a10 a53a57a56a11a56 a21 a54a58a7a27a53a55a54 a9a11a10a38a12 a53 a8 a17 a4a19a18a20a4 a10a39a10 a53a57a56a11a56 A classical compositional semantics construction first derives these two readings in the form of two HOL-formulas: a54a38a46 a14a48a47 a15a49a18 a9a11a10a13a12 a56 a1 a53a59a54 a21 a17 a4a60a18a61a4 a10a13a10 a53a31a56 a21 a54a11a54a38a46 a14a48a47 a15a62a18 a9a11a10a38a12 a56 a1 a53a59a54 a17 a4a60a18a61a4 a10a13a10 a53a31a56a11a56 where a46 a14a48a47 a15a49a18 is an abbreviation for the term a46 a14a16a47 a15a49a18a64a63 a1a66a65a67a1a27a68 a54a58a7a27a53a55a54 a65 a53 a8 a68 a53a31a56a11a56 An underspecified description of both readings is shown in Figure 2.
For now, notice that the graph has all the symbols of the two HOL formulas as node labels, that variable binding is indicated by dashed arrows, and that there are dotted lines indicating an “outscopes” relation; we will fill in the details in Section 3.
Now we want to reduce the description in Figure 2 as far as possible.
The first a0 -reduction step, with the redex at a51a52a26 is straightforward.
Even though the description is underspecified, the reducing part is a completely known a1 -term.
The result is shown on the left-hand side of Figure 1.
Here we have just one redex, starting at a25 a26, which binds a single variable.
The next reduction step is less obvious: The a21 operator could either belong to the context (the part between a22a64a23 and a25a37a26 ) a2 a3a4a6a5 a69 a2 a70 a14 a4a16a15 a71 a21 a69 a2 a70 a71 a21 a51 a25 a72 a73 Figure 3: Problems with rewriting of descriptions or to the argument (below a25a35a34 ).
Still, it is not difficult to give a correct description of the result: it is shown in the middle of Fig.
1. For the final step, which takes us to the rightmost description, the redex starts at a41a44a42. Note that now the a21 might be part of the body or part of the context of this redex.
The end result is precisely a description of the two readings as first-order formulas.
So far, the problem does not look too difficult.
Twice, we did not know what exactly the parts of the redex were, but it was still easy to derive correct descriptions of the reducts.
But this is not always the case.
Consider Figure 3, an abstract but simple example.
In the left description, there are two possible positions for the a21 : above a51 or below a25 . Proceeding na¨ıvely as above, we arrive at the right-hand description in Fig.
3. But this description is also satisfied by the term a69 a54 a21 a54a74a70a16a54 a71 a56a11a56a11a56, which cannot be obtained by reducing any of the terms described on the left-hand side.
More generally, the na¨ıve “graph rewriting” approach is unsound; the resulting descriptions can have too many readings.
Similar problems arise in (more complicated) examples from semantics, such as the coordination in Fig.
8. The underspecified a0 -reduction operation we propose here does not rewrite descriptions.
Instead, we describe the result of the step using a “a0 -reduction constraint” that ensures that the reduced terms are captured correctly.
Then we use a saturation calculus to make the description more explicit.
3 Tree
descriptions in CLLS In this section, we briefly recall the definition of the constraint language for a1 -structures (CLLS).
A more thorough and complete introduction can be found in (Egg et al., 2001).
We assume a signature a75 a63 a76 a69a37a77a38a78a35a77a80a79a80a79a80a79a82a81 of function symbols, each equipped with an arity a4a16a15a13a54 a69 a56a84a83a86a85 . A tree a87 consists of a finite set of nodes a88a90a89a59a91a93a92, each of which is labeled by a symbol a94a95a92 a54 a88 a56 a89a96a75 . Each node a88 has a sequence of children a88a43a97 a77a80a79a80a79a80a79a55a77 a88a31a98a84a89a99a91a93a92 where a98 a63a100a4a16a15a38a54 a94a101a92 a54 a88 a56a11a56 is the arity of the label of a88 . A single node a102, the root of a87, is not the child of any other node.
3.1 Lambda
structures The idea behind a1 -structures is that a a1 -term can be considered as a pair of a tree which represents the structure of the term and a binding function encoding variable binding.
We assume a75 contains symbols a14 a4a45a15 (arity 0, for variables), a3a4a103a5 (arity 1, for abstraction), a2 (arity 2, for application), and analogous labels for the logical connectives.
Definition 1.
A a1 -structure a104 is a pair a54 a87 a77 a1 a56 of a tree a87 and a binding function a1 that maps every node a88 with label a14 a4a16a15 to a node with label a3a4a6a5, a7, or a105 dominating a88 . a3a4a6a5 a2 a69 a14 a4a16a15 The binding function a1 explicitly maps nodes representing variables to the nodes representing their binders.
When we draw a1 -structures, we represent the binding function using dashed arrows, as in the picture to the right, which represents the a1 -term a1 a53 a79a106a69 a54a107a53a57a56 . A a1 -structure corresponds uniquely to a closed a1 -term modulo a108 -renaming.
We will freely consider a1 -structures as first-order model structures with domain a91a93a92 . This structure defines the following relations.
The labeling relation a88a110a109 a69 a54 a88 a23 a77a80a79a80a79a80a79a32a77 a88a35a111 a56 holds in a87 if a94a95a92 a54 a88 a56a112a63 a69 and a88a66a113 a63 a88a31a114 for all a97a116a115a117a114a93a115a117a98 . The dominance relation a88a57a118a120a119a60a88a31a121 holds iff there is a path a88a31a121a121 such that a88a57a88 a121a121 a63 a88 a121 . Inequality a122 a63 is simply inequality of nodes; disjointness a88a32a123a50a88a31a121 holds iff neither a88a57a118a120a119a60a88a31a121 nor a88 a121a118 a119 a88 . 3.2 Basic constraints Now we define the constraint language for a1 structures (CLLS) to talk about these relations.
a51 a77 a25 a77 a41 are variables that will denote nodes of a a1 -structure.
a124 a109a49a109 a63 a51 a118 a119 a25a126a125a61a51 a122 a63 a25a126a125a61a51 a123 a25a126a125 a124a116a127a116a124 a121 a125 a51 a109 a69 a54a51a128a23 a77a80a79a80a79a80a79a32a77 a51 a111 a56 a54a74a4a16a15a11a54 a69 a56a43a63 a98 a56 a125 a1 a54a51 a56a11a63 a25a129a125 a1a57a130 a23 a54a51a52a26 a56a11a63a64a76 a51a128a23 a77a80a79a80a79a80a79a82a77 a51 a111 a81 A constraint a124 is a conjunction of literals (for dominance, labeling, etc).
We use the abbreviations a51 a118a120a131 a25 for a51 a118a120a119 a25 a127 a51 a122a63 a25 and a51 a63 a25 for a51 a118 a119 a25 a127 a25 a118 a119 a51 . The a1 -binding literal a1 a54a51 a56a11a63 a25 expresses that a25 denotes a node which the binding function maps to a51 . The inverse a1 -binding literal a1a57a130 a23 a54a51a52a26 a56a11a63a64a76 a51a128a23 a77a80a79a80a79a80a79a32a77 a51 a111 a81 states that a51 a23 a77a80a79a80a79a80a79a32a77 a51 a111 denote the entire set of variable nodes bound by a51a52a26 . A pair a54 a104 a77a133a132 a56 of a a1 structure a104 and a variable assignment a132 satisfies a a1 -structure iff it satisfies each literal, in the obvious way.
a3a4a6a5 a14 a4a45a15 a14 a4a16a15 a51 a51 a23 a51 a33 Figure 4: The constraint graph of a1 a130 a23 a54a51 a56a11a63a67a76 a51a128a23 a77 a51a52a33 a81 a127 a51 a118a120a119 a51a128a23 a127 a51 a118a120a119 a51a52a33 We draw constraints as graphs (Fig.
4) in which nodes represent variables.
Labels and solid lines indicate labeling literals, while dotted lines represent dominance.
Dashed arrows indicate the binding relation; disjointness and inequality literals are not represented.
The informal diagrams from Section 2 can thus be read as constraint graphs, which gives them a precise formal meaning.
3.3 Segments
and Correspondences Finally, we define segments of a1 -structures and correspondences between segments.
This allows us to define parallelism and a0 -reduction constraints.
A segment is a contiguous part of a a1 -structure that is delineated by several nodes of the structure.
Intuitively, it is a tree from which some subtrees have been cut out, leaving behind holes.
Definition 2 (Segments).
A segment a108 of a a1 structure a54 a87 a77 a1 a56 is a tuple a88 a26a74a134 a88 a23 a79a80a79a80a79a32a77 a88a35a111 of nodes in a91a93a92 such that a88 a26 a118 a119 a88a35a113 and a88a35a113a74a123a50a88a136a135 hold in a87 for a97a129a115a137a114a138a122 a63a137a139 a115a137a98 . The root a140 a54 a108 a56 is a88 a26, and a141a35a142a136a54 a108 a56a143a63 a88 a23 a77a80a79a80a79a80a79a32a77 a88a66a111 is its (possibly empty) sequence of holes.
The set a144 a54 a108 a56 of nodes of a108 is a144 a54 a108 a56a95a63a100a76 a88a145a89a59a91a147a146 a125 a140 a54 a108 a56 a118a120a119a60a88 a77 and not a88 a113 a118a120a131a110a88 for all a97a148a115a149a114a95a115a150a98 a81 To exempt the holes of the segment, we define a144 a130 a54 a108 a56a148a63 a144 a54 a108 a56a152a151a150a141a27a142a6a54 a108 a56 . If a141a27a142a6a54 a108 a56 is a singleton sequence then we write a141a32a54 a108 a56 for the unique hole of a108, i.e. the unique node with a141a153a54 a108 a56 a89 a141a35a142a136a54 a108 a56 . For instance, a108 a63 a88 a23a154a134 a88 a33 a77 a88 a28 is a segment in Fig.
5; its root is a88 a23, its holes are a88 a33 and a88 a28, and it contains the nodes a144 a54 a108 a56a95a63a155a76 a88 a23 a77 a88 a36 a77 a88 a33 a77 a88 a28 a81 . Two tree segments a108 a77a11a0 overlap properly iff a144a120a130 a54 a108 a56a157a156 a144a120a130 a54a0 a56 a122 a63a159a158 . The syntactic equivalent of a segment is a segment term a51a52a26a80a134a82a51a128a23 a77a80a79a80a79a80a79 a51 a111 . We use the letters a160 a77a133a161a162a77a164a163a50a77 a91 for them and extend a140 a54 a160 a56, a141a27a142a6a54 a160 a56, and a141a32a54 a160 a56 correspondingly.
A correspondence function is intuitively an isomorphism between segments, mapping holes to holes and roots to roots and respecting the structures of the trees: Definition 3.
A correspondence function between the segments a108 a77a11a0 is a bijective mapping a165 a109a166a144 a54 a108 a56 a8 a144 a54a0 a56 such that a165 maps the a114 -th hole of a108 to the a114 -th hole of a0 for each a114, and for every a88a90a89a90a144a120a130 a54 a108 a56 and every label a69, a88a110a109 a69 a54 a88a43a97 a77a80a79a80a79a80a79a82a77 a88a31a98 a56a110a167 a165 a54 a88 a56 a109 a69 a54 a165 a54 a88a43a97 a56 a77a80a79a80a79a80a79 a165 a54 a88a31a98 a56a11a56 a79 There is at most one correspondence function between any two given segments.
The correspondence literal coa54 a163a40a77 a91 a56a60a54 a51 a56a11a63 a25 expresses that a correspondence function a165 between the segments denoted by a163 and a91 exists, that a51 and a25 denote nodes within these segment, and that these nodes are related by a165 . Together, these constructs allow us to define parallelism, which was originally introduced for the analysis of ellipsis (Egg et al., 2001).
The parallelism relation a108a149a168 a0 holds iff there is a correspondence function between a108 and a0 that satisfies some natural conditions on a1 -binding which we cannot go into here.
To model parallelism in the presence of global a1 -binders relating multiple parallel segments, Bodirsky et al.(2001) generalize parallelism to group parallelism.
Group parallelism a54 a108 a23 a77a80a79a80a79a80a79a32a77 a108a32a111 a56 a168 a54a0 a23 a77a80a79a80a79a80a79a32a77a11a0 a111 a56 is entailed a3a4a6a5 a78 a69 a2 a3a4a103a5 a2 a14 a4a16a15 a14 a4a16a15 a71 a69 a2 a14 a4a16a15 a71 a88 a26 a88a31a121 a26 a88 a23 a88 a36 a88 a121 a23 a88 a33 a88 a34 a88 a28 a88a31a121 a28 Figure 5: a69 a54a11a54 a1 a53 a79a170a169 a54a107a53a57a56a11a56a60a54 a71 a56a11a56 a8a172a171 a69 a54 a169 a54 a71 a56a11a56 by the conjunction a127 a111 a113a62a173 a23 a108 a113 a168 a0 a113 of ordinary parallelisms, but imposes slightly weaker restrictions on a1 -binding.
By way of example, consider the a1 structure in Fig.
5, where a54 a88 a26a20a134 a88 a23 a77 a88 a33a61a134 a88 a34 a77 a88 a28a20a134 a56 a168 a54 a88a31a121 a26 a134 a88a31a121 a23 a77 a88a31a121 a23 a134 a88a31a121 a34 a77 a88a31a121 a34 a134 a56 holds.
On the syntactic side, CLLS provides group parallelism literals a54 a160 a23 a77a80a79a80a79a80a79a32a77 a160 a111 a56 a168 a54 a161 a23 a77a80a79a80a79a80a79a174a77a133a161 a111 a56 to talk about (group) parallelism.
4 Beta
reduction constraints Correspondences are also used in the definition of a0 -reduction constraints (Bodirsky et al., 2001).
A a0 -reduction constraint describes a single a0 reduction step between two a1 -terms; it enforces correct reduction even if the two terms are only partially known.
Standard a0 -reduction has the form a163 a54a11a54 a1 a53 a79a170a161 a56 a160 a56 a8a172a171 a163 a54 a161a176a175a53 a134 a160a178a177 a56a179a53 free for a160 a79 The reducing a1 -term consists of context a163 which contains a redex a54 a1 a53 a79a170a161 a56 a160 . The redex itself is an occurrence of an application of a a1 -abstraction a1 a53 a79a170a161 with body a161 to argument a160 . a0 -reduction then replaces all occurrences of the bound variable a53 in the body by the argument while preserving the context.
We can partition both redex and reduct into argument, body, and context segments.
Consider Fig.
5. The a1 -structure contains the reducing a1 term a69 a54a11a54 a1 a53 a79a170a169 a54a107a53a31a56a11a56a60a54 a71 a56a11a56 starting at a88 a26 . The reduced term can be found at a88 a121a26 . Writing a180 a77 a180 a121 for the context, a0a44a77a11a0 a121 for the body and a108 a77 a108a32a121 for the argument tree segments of the reducing and the reduced term, respectively, we find a180 a63 a88 a26a181a134 a88 a23 a0 a63 a88 a33a181a134 a88 a34 a108 a63 a88 a28a181a134 a180a27a121 a63 a88a31a121 a26 a134 a88a31a121 a23 a0 a121 a63 a88a31a121 a23 a134 a88a31a121 a28 a108a32a121 a63 a88a31a121 a28 a134 Because we have both the reducing term and the reduced term as parts of the same a1 -structure, we can express the fact that the structure below a88 a121a26 can be obtained by a0 -reducing the structure below a88 a26 by requiring that a108 corresponds to a108a32a121, a0 to a0 a121, and a180 to a180 a121, again modulo binding.
This is indeed true in the given a1 -structure, as we have seen above.
More generally, we define the a0 -reduction relation a54 a180 a77a11a0a44a77 a108 a56 a171 a151 a8 a54 a180 a121 a77a11a0 a121 a77 a108 a121 a23 a77a80a79a80a79a80a79a153a77 a108 a121 a111 a56 for a body a0 with a98 holes (for the variables bound in the redex).
The a0 -reduction relation holds iff two conditions are met: a54a180 a77a11a0a44a77 a108 a56 must form a reducing term, and the structural equalities that we have noted above must hold between the tree segments.
The latter can be stated by the following group parallelism relation, which also represents the correct binding behaviour: a54 a180 a77a11a0a44a77 a108 a77a80a79a80a79a80a79a110a77 a108 a56 a168 a54 a180a37a121 a77a11a0 a121 a77 a108a32a121 a23 a77a80a79a80a79a80a79a174a77 a108a32a121a111 a56 Note that any a1 -structure satisfying this relation must contain both the reducing and the reduced term as substructures.
Incidentally, this allows us to accommodate for global variables in a1 -terms; Fig.
5 shows this for the global variable a169 . We now extend CLLS with a0 -reduction constraints a54 a163a40a77a133a161a182a77 a160 a56 a171 a151 a8 a54 a163 a121 a77a133a161 a121 a77 a160 a121 a23 a77a80a79a80a79a80a79a174a77 a160 a121 a111 a56 a77 which are interpreted by thea0 -reduction relation.
The reduction steps in Section 2 can all be represented correctly by a0 -reduction constraints.
Consider e.g. the first step in Fig.
1. This is represented by the constraint a54 a22a64a23a19a134a136a25a27a26 a77 a25a37a33a20a134a136a25a27a28 a77 a25a27a34a20a134 a56 a171 a151 a8 a54 a22a50a33a20a134a80a41a43a26 a77 a41a43a26a20a134a80a41a44a28 a77 a41a43a28a20a134 a56 . The entire middle constraint in Fig.
1 is entailed by the a0 -reduction literal.
If we learn in addition that e.g. a25a31a30 a118a120a119 a25a27a26, the a0 -reduction literal will entail a41 a30 a118a120a119 a41 a26 because the segments must correspond.
This correlation between parallel segments is the exact same effect (quantifier parallelism) that is exploited in the CLLS analysis of “Hirschb¨uhler sentences”, where ellipses and scope interact (Egg et al., 2001).
a0 -reduction constraints also represent the problematic example in Fig.
3 correctly.
The spurious solution of the right-hand constraint does not usb(a124, X) = if all syntactic redexes in a124 below a51 are reduced then return a54 a124 a77 a51 a56 else pick a formula redexa183 a54 a163a40a77a133a161a182a77 a160 a56 in a124 that is unreduced, with a51 a63 a140 a54 a163 a56 in a124 add a54 a163a40a77a133a161a182a77 a160 a56 a171 a151 a8 a54 a163 a121 a77a133a161 a121 a77 a160 a121 a23 a77a80a79a80a79a80a79a174a77 a160 a121 a111 a56 to a124 where a163 a121a77a133a161 a121a77 a160a184a121a23 a77a80a79a80a79a80a79a32a77 a160a184a121 a111 are new segment terms with fresh variables add a51 a123a50a140 a54 a163 a121 a56 to a124 for all a124 a121a57a89 solvea54 a124 a56 do usba54 a124 a121a77 a140 a54 a163 a121a56a11a56 end Figure 6: Underspecified a0 -reduction satisfy the a0 -reduction constraint, as the bodies would not correspond.
5 Underspecified
Beta Reduction Having introduced a0 -reduction constraints, we now show how to process them.
In this section, we present the procedure usb, which performs a sequence of underspecified a0 -reduction steps on CLLS descriptions.
This procedure is parameterized by another procedure solve for solving a0 reduction constraints, which we discuss in the following section.
A syntactic redex in a constraint a124 is a subformula of the following form: redexa183 a54 a163a40a77a133a161a182a77 a160 a56a95a63 df a141a32a54 a163 a56 a109a2 a54 a25 a77 a140 a54 a160 a56a11a56 a127 a25 a109 a3a4a6a5a64a54 a140 a54 a161 a56a11a56 a127 a1 a130 a23 a54 a25 a56a43a63a185a141a35a142a136a54 a161 a56 A context a163 of a redex must have a unique hole a141a153a54 a163 a56 . An a98 -ary redex has a98 occurrences of the bound variable, i.e. the length of a141a35a142a136a54 a161 a56 is a98 . We call a redex linear if a98 a63 a97 . The algorithm a186a57a187a20a188 is shown in Figure 6.
It starts with a constraint a124 and a variable a51, which denotes the root of the current a1 -term to be reduced.
(For example, for the redex in Fig.
2, this root would be a22 a26 ).
The procedure then selects an unreduced syntactic redex and adds a description of its reduct at a disjoint position.
Then the solve procedure is applied to resolve the a0 reduction constraint, at least partially.
If it has to disambiguate, it returns one constraint for each reading it finds.
Finally, usb is called recursively with the new constraint and the root variable of the new a1 -term.
Intuitively, the solve procedure adds entailed literals to a124, making the new a0 -reduction literal more explicit.
When presented with the left-hand constraint in Fig.
1 and the root variable a22a64a23, usb will add a a0 -reduction constraint for the redex at a25a174a23 ; then solve will derive the middle constraint.
Finally, usb will call itself recursively with the new root variable a22a50a33 and try to resolve the redex at a41a44a28, etc.
The partial solving steps do essentially the same as the na¨ıve graph rewriting approach in this case; but the new algorithm will behave differently on problematic constraints as in Fig.
3. 6 A single reduction step In this section we present a procedure solve for solving a0 -reduction constraints.
We go through several examples to illustrate how it works.
We have to omit some details for lack of space; they can be found in (Bodirsky et al., 2001).
The aim of the procedure is to make explicit information that is implicit in a0 -reduction constraints: it introduces new corresponding variables and copies constraints from the reducing term to the reduced term.
We build upon the solver for a0 -reduction constraints from (Bodirsky et al., 2001).
This solver is complete, i.e. it can enumerate all solutions of a constraint; but it disambiguates a lot, which we want to avoid in underspecified a0 -reduction.
We obtain an alternative procedure solve by disabling all rules which disambiguate and adding some new non-disambiguating rules.
This allows us to perform a complete underspecified a0 reduction for many examples from underspecified semantics without disambiguating at all.
In those cases where the new rules alone are not sufficient, we can still fall back on the complete solver.
6.1 Saturation
Our constraint solver is based on saturation with a given set of saturation rules.
Very briefly, this means that a constraint is seen as the set of its literals, to which more and more literals are added according to saturation rules.
A saturation rule of the form a124 a26 a8 a189a55a111 a113a62a173 a23 a124 a113 says that we can add one of the a124 a113 to any constraint that contains at least the literals in a124 a26 . We only apply rules where each possible choice adds new literals to the set; a constraint is saturated under a set a190 of saturation rules if no rule in a190 can add anything else.
solve returns the set of all possible saturations of its input.
If the rule system contains nondeterministic distribution rules, with a98a192a191a193a97, this set can be non-singleton; but the rules we are going to introduce are all deterministic propagation rules (with a98 a63 a97 ).
6.2 Solving
Beta Reduction Constraints The main problem in doing underspecified a0 reduction is that we may not know to which part of a redex a certain node belongs (as in Fig.
1). We address this problem by introducing underspecified correspondence literals of the form coa54a39a76a6a54 a163 a23 a77 a91 a23 a56 a77a80a79a80a79a80a79a153a77 a54 a163 a111 a77 a91a147a111 a56 a81 a56a60a54a51 a56a11a63 a25 a79 Such a literal is satisfied if the tree segments denoted by the a163 ’s and by the a91 ’s do not overlap properly, and there is an a114 for which coa54 a163 a113 a77 a91a147a113 a56a60a54a51 a56a101a63 a25 is satisfied.
In Fig.
7 we present the rules UB for underspecified a0 -reduction; the first five rules are the core of the algorithm.
To keep the rules short, we use the following abbreviations (with a97a24a115a149a114a95a115a149a98 ): beta a63a50a194a19a195a197a196a198a54 a163a50a77a133a161a162a77 a160 a56 a171 a151 a8 a54 a163 a121 a77a133a161 a121 a77 a160a184a121 a23 a77a80a79a80a79a80a79a32a77 a160a184a121 a111 a56 coa113 a63a50a194a19a195a197a196 coa54a39a76a6a54 a163a40a77a164a163 a121a56 a77 a54 a161a182a77a133a161 a121a56 a77 a54 a160 a77 a160 a121 a113 a56 a81 a56 The procedure solve consists of UB together with the propagation rules from (Bodirsky et al., 2001).
The rest of this section shows how this procedure operates and what it can and cannot do.
First, we discuss the five core rules.
Rule (Beta) states that whenever the a0 -reduction relation holds, group parallelism holds, too.
(This allows us to fall back on a complete solver for group parallelism).
Rule (Var) introduces a new variable as a correspondent of a redex variable, and (Lab) and (Dom) copy labeling and dominance literals from the redex to the reduct.
To understand the exceptions they make, consider e.g.
Fig. 5.
Every node below a88 a26 has a correspondent in the reduct, except for a88 a28 . Every labeling relation in the redex also holds in the reduct, except for the labelings of the a2 -node a88 a23, the a3a4a6a5 -node a88 a28, and the a14 a4a16a15 -node a88 a34 . For the variables that possess a correspondent, all dominance relations in the redex hold in the reduct too.
The rule (a1 .Inv) copies inverse a1 binding literals, i.e. the information that all variables bound by a a1 -binder are known.
For now, (Beta) a199a49a200a37a201a203a202a55a201a203a204a37a205a101a206a207 a199a208a200a37a209a210a201a107a202a31a209a210a201a107a204a27a209a211a38a201a197a212a181a212a197a212a48a201a107a204a27a209a213a82a205 a207 a199a208a200a37a201a74a202a55a201a107a204a32a201a197a212a197a212a39a212a82a201a210a204a31a205a103a214a162a199a49a200a37a209a58a201a203a202a31a209a58a201a107a204a35a209a211a11a201a197a212a181a212a181a212a48a201a210a204a35a209a213a16a205 (Var) beta a215 redexa216a32a199a208a200a37a201a74a202a55a201a107a204a31a205a20a215a95a217a19a199a208a200a57a205a49a218a164a219a154a220a184a215a166a220a110a221a173 a183 a207a112a222 a220 a209a212coa223a74a199a49a220a27a205a173 a220 a209 (Lab) beta a215 redexa216 a199a208a200a37a201a74a202a55a201a107a204a31a205a20a215a166a220a103a224a19a225a226a48a199a49a220 a211 a201a39a212a197a212a197a212a16a201a107a220a120a227a39a205a82a215a166a228 a227a229a13a230 a224 coa223a203a199a208a220 a229 a205a173 a220a35a209a229 a215a101a220a103a224a20a221a173a31a231 a199a208a200a57a205a48a215a101a220a6a224a82a232a233 a231a20a234 a199a208a202a174a205 a207 a220a66a209 a224 a225a226a48a199a49a220a66a209a211 a201a181a212a197a212a181a212a48a201a107a220a35a209 a227 a205 (Dom) beta a215 a228a110a235a229a38a230 a211 coa223a203a199a208a220 a229 a205a173 a220a35a209a229 a215a166a220 a211 a218 a219 a220 a235 a207 a220a35a209a211 a218 a219 a220a66a209 a235 (a236 .Inv) betaa215 redexa216 a199a49a200a37a201a203a202a110a201a210a204a37a205a39a215a66a236a16a237 a211 a199a49a220a103a224a133a205a173a174a238 a220 a211 a201a197a212a181a212a181a212a48a201a107a220a103a239a44a240a60a215 a228 a239a229a38a230 a224 coa211 a199a49a220 a229 a205a173 a220 a209a229 a207 a236a16a237 a211 a199a208a220 a209 a224 a205 a173a174a238 a220 a209a211 a201a197a212a39a212a197a212a82a201a203a220 a209a239 a240 redex linear (Par.part) betaa213 a215 coa223a203a199a49a220a27a205a173 a220 a209 a215 a183 a233a152a241 a199a208a204a37a205a16a215a166a220a66a218a164a219 a183 a207 a220 a209 a232a233a152a242a199a208a202 a209a205 a23a57a243 a113 a243 a111 (Par.all) coa199 a238 a199a49a244a101a201a203a244 a209a205a203a201a197a212a39a212a197a212a74a240a38a205a74a199a208a220a37a205 a173 a220 a209 a215a166a220 a233a245a241 a199a208a244a43a205 a207 a220 a209 a233a245a241 a199a208a244 a209a205a48a215 coa199a208a244a101a201a203a244 a209a205a203a199a49a220a27a205 a173 a220 a209 Figure 7: New saturation rules UB for constraint solving during underspecified a0 -reduction.
it is restricted to linear redexes; for the nonlinear case, we have to take recourse to disambiguation.
It can be shown that the rules in UB are sound in the sense that they are valid implications when interpreted over a1 -structures.
6.3 Some
Examples To see what the rules do, we go through the first reduction step in Fig.
1. The a0 -reduction constraint that belongs to this reduction is a54 a163a40a77a133a161a182a77 a160 a56 a171 a151 a8 a54 a163 a121 a77a133a161 a121 a77 a160a178a121 a23 a56 with a163 a63 a22a64a23a164a134a136a25a37a26 a77 a161 a63 a25a174a23a164a134a136a25a37a28 a77 a160 a63 a25a35a34a20a134 a77 a163 a121 a63 a22a50a33a61a134a80a41a43a26 a77a246a161 a121 a63 a41a44a26a61a134a80a41a43a28 a77 a160a178a121 a23 a63 a41a44a28a20a134 Now saturation can add more constraints, for example the following: a199 a23 a205 a183a61a247 a221 a173 a183 a211 a199 a36 a205 a183a61a247 a221 a173 a183a61a248 a199 a33 a205 a183a20a249 a221 a173 a183 a211 a199 a29 a205a250a220 a247 a225a251a252a199a208a220 a249 a205 (Lab) a199 a28 a205 a222 a220 a247 a212co a211 a199 a183a61a247 a205 a173 a220 a247 (Var) a199 a30 a205a250a253 a235 a218 a219 a220 a247 (Dom) a199 a34 a205 a222 a220 a249 a212co a211 a199 a183a20a249 a205 a173 a220 a249 (Var) We get (1), (2), (5) by propagation rules from (Bodirsky et al., 2001): variables bearing different labels must be different.
Now we can apply (Var) to get (3) and (4), then (Lab) to get (6).
Finally, (7) shows one of the dominances added by (Dom).
Copies of all other variables and literals can be computed in a completely analogous fashion.
In particular, copying gives us another redex starting at a41a44a42, and we can continue with the algorithm usb in Figure 6.
Note what happens in case of a nonlinear redex, as in the left picture of Fig.
8: as the redex is a254 ary, the rules produce two copies of the a21 labeling constraint, one via coa23 and one via coa33 . The result is shown on the right-hand side of the figure.
We will return to this example in a minute.
6.4 More
Complex Examples The last two rules in Fig.
7 enforce consistency between scoping in the redex and scoping in the reduct.
The rules use literals that were introduced in (Bodirsky et al., 2001), of the forms a51 a89a145a144 a54 a160 a56, a51 a134 a89a155a255 a54 a161 a56, etc., where a160, a161 are segment terms.
We take a51 a89a90a144 a54 a160 a56 to mean that a51 must be inside the tree segment denoted by a160, and we take a51 a89 a255 a54 a161 a56 (i for ’interior’) to mean that a51 a89a145a144 a54 a161 a56 and a51 denotes neither the root nor a hole of a161 . As an example, reconsider Fig.
3: by rule (Par.part), the reduct (right-hand picture of Fig.
3) cannot represent the term a69 a54 a21 a54a74a70a48a54 a71 a56a11a56a11a56 because that would require the a21 operator to be in a255a54 a161 a121a56 . Similarly in Fig.
8, where we have introduced two copies of the a21 label.
If the a21 in the redex on the left ends up as part of the context, there should be only one copy in the reduct.
This is brought about by the rule (Par.all) and the fact that correspondence is a function (which is enforced by rules from (Erk et al., 2001) which are part of the solver in (Bodirsky et al., 2001)).
Together, they can be used to infer that a41a44a26 can have only one correspondent in the reduct context.
7 Conclusion
In this paper, we have shown how to perform an underspecifieda0 -reduction operation in the CLLS framework.
This operation transforms underspecified descriptions of higher-order formulas into descriptions of their a0 -reducts.
It can be used to essentially a0 -reduce all readings of an ambiguous sentence at once.
It is interesting to observe how our underspecified a0 -reduction interacts with parallelism constraints that were introduced to model ellipses.
Consider the elliptical three-reading example “Peter sees a loophole.
Every lawyer does too.” Under the standard analysis of ellipsis in CLLS (Egg et al., 2001), “Peter” must be represented as a generalized quantifier to obtain all three readings.
This leads to a spurious ambigua2 a3a4a6a5 a127 a2 a14 a4a16a15 a17 a47a60a10a38a47 a15 a2 a14 a4a16a15 a5a40a4a45a15a49a18 a3a4a6a5 a3a4a1a0a3a2a5a4 a14 a4a45a15 a21 a41a44a26 a41 a23 a127 a2 a3a4a6a5 a3a4a1a0a6a2a5a4 a14 a4a16a15 a17 a47a60a10a38a47 a15 a2 a3a4a6a5 a3a4a7a0a3a2a5a4 a14 a4a16a15 a5a40a4a16a15a62a18 a21 a21 a41 a121 a26 a41 a121 a23 a41 a121a121 a26 a41 a121a121 a23 Figure 8: “Peter and Mary do not laugh.” ity in the source sentence, which one would like to get rid of by a0 -reducing the source sentence.
Our approach can achieve this goal: Adding a0 -reduction constraints for the source sentence leaves the original copy intact, and the target sentence still contains the ambiguity.
Under the simplifying assumption that all redexes are linear, we can show that it takes time a8 a54a10a9 a98 a28 a56 to perform a9 steps of underspecified a0 reduction on a constraint with a98 variables.
This is feasible for large a9 as long as a98a12a11a14a13 a85, which should be sufficient for most reasonable sentences.
If there are non-linear redexes, the present algorithm can take exponential time because subterms are duplicated.
The same problem is known in ordinary a1 -calculus; an interesting question to pursue is whether the sharing techniques developed there (Lamping, 1990) carry over to the underspecification setting.
In Sec.
6, we only employ propagation rules; that is, we never disambiguate.
This is conceptually very nice, but on more complex examples (e.g.
in many cases with nonlinear redexes) disambiguation is still needed.
This raises both theoretical and practical issues.
On the theoretical level, the questions of completeness (elimination of all redexes) and confluence still have to be resolved.
To that end, we first have to find suitable notions of completeness and confluence in our setting.
Also we would like to handle larger classes of examples without disambiguation.
On the practical side, we intend to implement the procedure and disambiguate in a controlled fashion so we can reduce completely and still disambiguate as little as possible.
References M.
Bodirsky, K.
Erk, A.
Koller, and J.
Niehren. 2001.
Beta reduction constraints.
In Proc.
12th Rewriting Techniques and Applications, Utrecht.
J. Bos.
1996. Predicate logic unplugged.
In Proceedings of the 10th Amsterdam Colloquium.
R. Cooper.
1983. Quantification and Syntactic Theory.
Reidel, Dordrecht.
M. Egg, A.
Koller, and J.
Niehren. 2001.
The constraint language for lambda structures.
Journal of Logic, Language, and Information.
To appear.
K. Erk and J.
Niehren. 2000.
Parallelism constraints.
In Proc.
11th RTA, LNCS 1833.
K. Erk, A.
Koller, and J.
Niehren. 2001.
Processing underspecified semantic representations in the Constraint Language for Lambda Structures.
Journal of Language and Computation.
To appear.
A. Koller and J.
Niehren. 2000.
On underspecified processing of dynamic semantics.
In Proc.
18th COLING, Saarbr¨ucken.
A. Koller, J.
Niehren, and K.
Striegnitz. 2000.
Relaxing underspecified semantic representations for reinterpretation.
Grammars, 3(2/3).
Special Issue on MOL’99.
To appear.
J. Lamping.
1990. An algorithm for optimal lambda calculus reduction.
In ACM Symp.
on Principles of Programming Languages.
M. P.
Marcus, D.
Hindle, and M.
M. Fleck.
1983. Dtheory: Talking about talking about trees.
In Proc.
21st ACL.
R. Montague.
1974. The proper treatment of quantification in ordinary English.
In Formal Philosophy.
Selected Papers of Richard Montague.
Yale UP.
M. Pinkal.
1996. Radical underspecification.
In Proc.
10th Amsterdam Colloquium.
O. Rambow, K.
Vijay-Shanker, and D.
Weir. 1995.
D-Tree Grammars.
In Proceedings of ACL’95.
U. Reyle.
1993. Dealing with ambiguities by underspecification: construction, representation, and deduction.
Journal of Semantics, 10.
K. van Deemter and S.
Peters. 1996.
Semantic Ambiguity and Underspecification.
CSLI Press, Stanford .

