SYNTACTICI\]~EADDRIVEN (zlENERA'I'ION Esther K6nig* Institute for Computational Linguistics, Azenbergstr.12, 70174 Stuttgart,Germany, esther@ims.uni-stuttgart.de Abstract The previously proposed semanlic-head-driw'.n Ken eration methods run into problems if none of the daughter eonstituents in the syntact.o-semantic rule schemata of a grammar fits the definition of a semantic head given in \[Shieber et al., 1990\].
This is the case for the semantic analysis rnles of certain constraintbased semantic representations, e.g.
Underspecified Discourse R,epresentation Structures (UI)RSs) \[l!'rank and R.eyle, 1992\].
Since head-driven generation in general has its me> its, we simply return to a syntactic definition of qmad' and demonstrate the feasibility of synlaclichead-clriveu generation.
In addition to its generality, a syntactic-head-driven algorithm provides a basis for a logically well-defined treatment of the nmvement of (syntactic) heads, for which only ad-hoc solutions existed, so far.
1 Introduction
IIead-driven generation methods combine both, topclown search and bottom-np combination, in an ideal way.
\[Shieber el al., 1990\] proposed to define the 'head' constituent It of phrase with category a~ on semantic grounds: the semantic representations of h and z are identical.
This puts a strong restriction on the shape of semantic analysis rules: one of the leaves must share its semantic form with the.
root node.
IIowever, there are composition rules for semantic representations which violate this restriction, e.g. tim schemata for the construction of Underspecified Discourse It,epresentatim, Structures (UI)ILSs) \[l"rank and Reyle, 1992\] where, in general, the root of a tree is associated with a strictly larger semantic structure (,hal, a,ly of I, he leaves.
Ill order to make at generation method available for grammars wl,ich do not follow the striet notion of a semantic head, a syntactic-headdriven generation algorithm is presented, which can be specialized to generate from UDRSs.
In a second step, the method will be extended in order to handle the movement of (syntactic) heads in a logically well-defined manner.
The (tactical) generation proble.m is tim task to generate a string from a semantic representation according to the syntax-semantics-relation defined in a given grammar.
Let's assume that the latter relation *The research reported here has been funded by the Sonderforsclmngsbereidt 340 "Sprachtheorctische GrmMlagen ffir die Computerllngulstik", a project of the German National Science Foundation I)I,'G.
is stated by pairs of trees.
The left tree stages a local syntactic dependeacy, i.e. the dominance relation between a root node and a set of leaf nodes and the linear precedence relation among the leaves.
The right tree defines the relation among the semantic representation of the root and the semantic representations of the leaves.
We assume that there is a one-to-one map from the nonterminal leaf nodes of the (local) syntax tree on the le.af nodes of the.
(locM) semantic deriw~tion tree.
Example: np vp NP VP i i t I,_ _ _ 5_-55,....
If one assumes a pairwise linking from M't to right then the links between the two trees can be on,itted.
Although such pairs of trees are reminiscent of synchronons trees in TAG's \[Shieber and Schabes, 1991\], they are simpler in wtrious ways, in particular because we will nol make use of the adjunction operM.ion later on.
In essence, pairs of trees are just a graphical notation for what has been put forward as the 'rule-to-rule'-hypothesis, el'.
\[Gazdar el al., 1985\], the fact that in the grammar each syntax rule is related with a semantic analysis rule.
However, on the long run, the tree notation suggests a more general relation, e.g. more internal structure or additional, terminal leaf nodes in the local syntax tree.
An obvkms way to implement a generation procedure (see Fig.l) is to relate the inlmt semantics with the start symbol of the gramnuu" and then to try to exl}and this node in a top-down manner accordiug to the rules specitied in tl,e grammar.
This node expansion corresponds to an application of the (predicl)-rule in the following abstract specification of a Lop-down generator.
Generation terminates successfully if all the leaf nodes are labeled with terminals (s.ucccss).
The question is which method is used to nmke two, possibly complex symbols equal, l'~or the sake of simplicity, we assume that the open leaves at0 resp.
X0 are matched by (feature) term unification with the corresponding mother nodes in the grammar rule.
llowever, for the semantic form Xo, a decidable variant of higher order unification might be used instead, in order Lo inch, de the reduction of .\-expressions.
Of course, the.
necessary precautions have to be taken in order to avoid the confusion between objectand meta-level wtriables, cf.
\[Shieber el al., 1990\].
A clepth-first realization of this abstract top-down algorithm would work line as long ms tl,e semantic rep4Z5 all leaves of the syntax tree are labeled with terminals (success) Xo Xo Figure 1: Top-Down Generation (G grammar description; xl syntactic category; Xi semantic representation) resentations of the leaves are always strictly smaller in size as the semantic form of the root node.
But, if the actual semantic decomposition takes place in the lexicon, the semantic representations of some subgoals will be variables, which stand for semantic representations of any size: X np vp, lambda • \[Y\] sere walk(Y) walks (2) A strict left-to-right, depth-first expansion of subgoals might run into problems with the grammar fragment in (2) if a left..reeursive up-rule exists, because the semantics of the np is only instantiated once the 'scmantic head' of the vp has been looked up in the lexicon.
2 Previous
work A top-down, semantic-structure-driven generation algorithm has been defined by \[Wedekind, 1988\] which gives a basis for dynamic subgoal-reordering guided by the semantic input.
Some proposals have been made for subgoal reordering at compile-time, e.g.
\[Minnen et al., 1993\] elaborating on the work by \[Strzalkowski, 1990\].
But there will be no helpful st, bgoal reordering for rules with semantic head recnrsion: f l ambda : A "~ Obviously, a bottom-up component is required.
One solution is to keep to a top-down strategy hut to do a breadth-first search, ef.
\[Kohl, 1992\], which will be fair and not delay the access to the lexicon forever, as a pure depth-first strategy does.
Alternatively, one could adopt a pure bottom-up strategy like the one which has been proposed in \[Shieber, 1988\] and which is presented in Fig.2 in a lfighly schematic manner.
A lexical entry qualifies as a potential leaf node if its semantic form is a non-trivial substructure of the input semantics (rule (lex)).
The derivation trees are built up by the (complete}-rule.
Generation finally succeeds if the root node of I, he current syntax tree is labeled with the start symbol of the grammar and the root of the semantic analysis trec with the input semantics.
Due to tile exclusion of phr~es with 'empty' semantics (which would be trivial substructures of the input semantics), tile method always terminates, lIowever, tile lack of top-down guidance will lead, in general, to a lot of non-determinism.
The strong substructure condition means that the algorithm will be incomplete for grammars which cover semantically void phrmses like expletive expressions, particles, and sul)phrascs of idioms.
The head-corner generator in \[van Noord, 1993\] is an illustrative instance of a sophisticated combination of top-down prediction and bottom-up structure building, see Fig.3.
The rule (lez) restricts the selection of lexical entries to those which can be 'linked' to the local goal category (visualized by a dotted line).
According to van Noord, two syntax-semantics pairs are liukable if their semantic forms are identical, i.e. llnk((x, X), (z;, X)).
The rule (hc-co,aptete) performs a 'head-corner' completion step for a (linked) phrase zh, which leads to the prediction of the head's sisters.
A link marking can be removed if the linked categories resp.
the linked semantic forms are identical (rule (local-success)).
Generation succeeds if all the leaves of the syntax tree are labeled with terminals and if no link markings exist (rule (global-success)).
In order to obtain completeness in the general c~e, the inference schemata of the head-corner generator must be executed by a breadth-first interpreter, since a depth-first interpreter will loop if the semantic analysis rules admit that subtrees are associated with semantic forms which are not proper substructures of the input semantics, and if these subtrees can be composed recursively.
Such an extreme case would be a recursive rule for semantically empty particles: ('empty' semantics is represented by the empty list symbol El): /~ /~ _ \[\] (~) part part X1 X2 x Ilowcver, if we a.ssume that structures of that kind do not occur, a depth-first interpreter will be sufficient, e.g. the inference rules of the algorithm can be encoded and interpreted directly in Prolog.
Note that van No~ ord's method is restricted to grammars where phrases have always a lexical semantic head.
The algorithm in \[Shleber et al., 1990\] relaxes this condition.
476 (±Z~/ Wl, • • • ~ tt)r (~) if V i, 1 <<_ i <_ r, Xi ~.
G and Xi substructure of X xo Xo xo Xo \ G Figure 2: Bottom-Up Generation (G grammar description; s start symbol; X input semantics; xl syntactic category; X," semantic representatiou) all leaves are labeled with terminals and the tree does not contain any dotted lines (+; +)~, ~' (+ +1 @tol,.l-success) ( /z /z ) ~ ( z~, /z ),, (,!,, x,) ~i ! " E G ~,.1 ti,,k((~, x), (~;, x;)) Xh xo Xo if E G Figure 3: IIead-Corner Generator (G grammar description; xi syntactic category; Xi semantic representation) 477 every dref : X ros : ~F~C8 scope : Scope dre~ : X ros : J~es scope : Scope SeN.
: womaxt sere woman(X) loves sere : love(X,Y) Figure 4: A grammar with UDRS-eonstruction rules lexicon 3 Underspecified Discourse Representation Structure In the following, we will present shortly a semanLic representation formalism and a corresponding set, of analysis rules wlfich resist to the definition of 'semantic head' as it is required in van Noord's beadcorner algorithm.
\[Reyle, 1993\] developed an inference system for Underspecified Discourse Representation Structures (UDRS's), i.e.
Discourse Representation Structures \[Kamp and Reyle, 1993\] which are underspecified with respect to scope.
The following UDll.S represents simultaneously the two readings of the sentence 'every woman loves a man' by leaving the exact structural embedding of the quantified phrases underspecified.
\[ lovo(~, v) \] (~) An arrow pointing from X2 to XI is called a subordination constraint and means that the formula X2 must not have wider scope than Xa.
\[Frank and 1Zeyle, 1992\] proposed rules for the construction of UDRS's in an ItPSG-style syntax, of.
\[Pollard and Sag, 1993\], which are shown in Fig.4 and 5 in a somewhat adapted manner.
Semantic composition is performed by the coindexing of the features dre:f, res, subj, etc.
which serve as an interface to the value of the sore feature, the actual semantic representation.
For the phrasestructure tree rooted with s, there is no leaf which would fulfill the definition of a semantic head given in \[Shieber et al., 1990\] or \[van Noord, 1993\].
IIence, the head-corner generator of Fig.3 with a link relation based on semantic beads will not be applicable.
4 Syntactic-head-driven generation 4.1 A new link relation One could define a weak notion of o semantic head which requires that tile semantic form of the semantic head is a (possibly empty) substructure of the root semantics.
But this is rather meaningless, sincc now every leaf will qualify ms a semantic head.
As a way out, there is still tile notion of a syntactic bead, which can serve as the pivot of the generation process.
Assmne that Lhe syntactic head leaf for each local syntax trec has been defined by the grammar writer.
We get the following preliminary version of a syntaxbased link relation: N,~k( (~,, X), (x,, Xd ) (6) 1.
if either x = xi 2.
0r x d is a possible syntactic head of x and link( ('~j, Xj), 0", X,) ) This is the kind of link relation which is used for parsing.
In general, it works line there, because with each lexlcal lookup a part of the input structure, i.e. of the inl)ut string, is consumed.
In order to reduce the number of non-termhiating cases for generation, a similar precantlon tl~ to be added, i.e. tile hipu~ structure h~ to be taken into account.
The final version of a syntax-based link relation incorporates a test for the weak notion of a semantic bead: li,,k((~,,X), (x;,Xd) g (7) 1.
either x = x; and X; is a (possibly empty) substructure of X 2.
or zj is a possible syntactic head of x and link((xj, X), (x;, Xd) The substructure check makes only sense if the semantics X of the current goal is instautiated.
This might 478 <Z, dro:\[ : X ) scope : Scope sem : Quant res : J ( . ); X scope : S pe sere . Rcs sere : Quant / 8 v2 np s elll : scope : SA'c subj : X dref : sere : Subj obj : Y scope : sere : Verb sere : Y) OSc Obj Figure 5: A grammar with UDl(S-construction rules syntax rules > not be the case, when the proper semantic head and the syntactic head differ, and a sister goal of the semantic head is to be expanded before the head itself.
IIence, in general, the sister goals must be reordered according to the degree of instantiation of their semantic representations.
In addition to the improved termination properties, the condition on the semantic representation helps to filter out useless candidates from the lexicon, i.e. lexical entries which will never become part of the final derivation because their semantic representations do not tit.
4.2 Grammars
with head movement In order to simplify the representation in the following, we assume that each syntax tree in a grammar is isomorphic to the corresponding semantic analysis tree.
This means that both trees can merged into one tree by labeling the nodes with syntax-semantics-pairs: (xo, Xo) (~,x,) (~, x2) (s) In \[Shieber el al., 1990\] an ad-hoc solutiori was proposed to enforce termination when the semantic head has been moved.
By adopting a syntactic-head-driven strategy, head-movement does not canse a problem if the landing site of the head is the 'syntactic bead' (or rather: the main fiinctor category of the chmse, in categorial grammar terminology) of a superordinate clause.
This is postulated by syntactic descriptions like (cPS, X0) cp~ e~ spcc~~ I (vp, Xo)lr(v~,X,)\] I ~Ps/E.~ps\] (~, X1) vp s (9) where vp/r,.1 means that the deriwttion of the vp* uvlJ node ll~s to include all empty v-leaf.
Ill the example ill Fig.6, the syntactic head (the c-position) of the cpf will be visited before the vp is to be derived, hence the exact information of the verb trace will be available in time.
Similarly for the movement to the 'vorfehl'.
l\[owever, if verb second coufign,'ations are described by a single structure (cp,, Xo) (cp I, Xo) spe e c_..----------'--~~ ( 10 ) I (xs'~,x~) I ~v/D s, (xI-~,x~)\] vj the algorithm runs into a de.i~dlock: the vp-node cannot be processed completely, because the semantics of the XP-trace is unknown, and the expansion of the XP-filler position wile be delayed for tile same reason.
If this syntactic description had to be preferred over the one in (9), the link relation should be further modified.
The substructure test wrt.
the semantics of the current goal should be replaced by a substructure test 479 spec I vpl v dp I I Bananen gegessen eaten cps cp\] vp c I vp ~2 I,lp I vpl v2 hat Peter I I has Figure 6: Movement of a complex non-head wrt.
the global input semantics, which leads to a loss of tlexibility, as it has been discussed in connection with the pure bottom-up approach.
4.3 Implementation
Since the algorithm has been implemented in the CUF language t, which includes a wa±t-mechanism, the reodcring of subgoMs can be delegated to CUF.
Instead of a full-blown substructure test which might be quite complicated on graphs like UDI~S's, only the predicate names (and other essential 'semantic' keywords) of the lexical entry are mapped on the current goal semantics.
If such a map is not feasible, this lexical entry is dropped.
We restrict the grammars to lexicalized ones.
A grammar is lexiealized if for every local syntax tree there is at least one preterminal leaf, cf.
\[Sehabes and Waters, 1993\].
Note that lexicalization does not affect the expressibility of the grammar \[Bar-llillcl el al., 1960\], \[Schabes and Waters, 1993\].
Ilowever, the generation algorithm turns much simpler and hence more efficient.
There is no need for a transitive link relation, since a goal can match immediately the mother node of a preterminal.
The lexicon access and the headcorner completion step can be merged into one rule schema 2.
A version of the Non-Local-Feature principle of IIPSG has been integrated into the algorithm.
Every non-head nontcrminM leaf of a local tree must come with a (possibly empty) multiset of syntax-semantics pairs as the value of its to_bind:slash-feature (feature abbreviated as /), cf.
example (9).
From these static values, the dynamic inherited:slash-values IThe CUF-system is an implementation of a theorem prover for a Horn clause logic with typed feature terms \[Dt;rre and Dorna, 1993\].
2An instance of our head-corner generator (without an integrated treatment of movement) is the UCG-generator by Calder et al.\[Calder et al., 1989\] (modulo the use of unary category transformation rules) which relies, in addition, on the symmetry of syntactic and semantic head.
A syntactic-head-drlven generator for a kind of lexlcallzed grammars has been proposed independently by \[Kay, 1993\].
Another variant of a lexlcMized grammar by \[Dymetman ctal., 1990\] does not make use of the head-corner idea but rather corresponds to the top-down generation schema presented in Fig.1.
(feature abbreviated ms //) can be calculated during generation, see rule (lex) in Fig.7.
(la) Choose a lexical entry as the head Xh of the current goal x0.
Then the substructure condition must hold for the corresponding semantic forms Xh and Xo.
The//-value Th mnst be empty.
(lb) Or choose an element of the //-value 7b of the current head z0.
Then the //-value Th becomes \[(xh, Xh)l.
The associated string wh is empty.
(2) There must be a lexicalized tree which connects the goal z0 and the chosen head xh.
The//-value To is split into disjoint sets 7'1, ..., 7',, The//-values of the new subgoals xl, ..., :Co are the disjoint set unions T~ ~ 7~ where 7~ ~ is the /-value of zi in the local tree given in the grammar.
Note that this version of the Non-LocM-Feature principle corresponds to the hypothetical reasoning mechanism which is provided by the Lambek eategorim grammars \[Lambek, 1958\], \[KSnig, 1994\].
This is illustrated by the fact that e.g. the left tree in example (9) can be rendered in categorial grammar notation as cpl/(vp/v ).
IIeuce, the algorithm in Fig.7 has a clear logical basis.
5 Conclusion
This paper gives a syntactic-bead-driven generation algorithm which includes a well-defined treatment of moved constituents.
Since it relies on tile notion of a syntactic head instead of a semantic head it works also for grammars where semantic heads are not available in general, like for a grammar which includes semantic decomposition rules of (scopally) Underspecitied Discourse Representation Structures.
By using the same notion of head both for parsing and for generation, both techniques become even closer.
In effect, the abstract specifications of the generation algorithms which we gave above, could be read as parsing algorithms, modulo a few changes (of the success condition and the link relation).
Generation from Underspecified DI/,S's means that sentences can be generated from meaning representations which have not been disambiguated with regard to quantifier scope.
This is of particular importance for applications in machine translatiou, where 480 all leaves are labeled with terminals (zh, Xh) 1.
if I Wh (Sll ccegs) ~el,x~)//7'~ w'q ('~h, Xh)//7;, (~,.,X.)//Tt;, ...... uJT",, I Wh C= G and Xh substructure of Xo and 7), := I\] or q (~,,, X,,) e 7; .,,a 7;, := \[(~,,, Xh)\],,,,d .),, := c (~o, Xo) 2.
and ~__~ G G and "I}~ := 7'I U...U'\[~ Figure 7: IIead-Corner Generator for lexicalized grammars (G grammar description; xl syntactic category symbol; Xi semantic representation; 7} zlash-values) one wants to avoid the resolution of scope relations as long as the underspeeified meaning can be rendered in the source and in the target language.
Future work should consider more the strategic part of the generation problem, e.g. try to find heuristics and strategies which handle situations of 'scope mismatch' where one language has to be more precise with regard to scope than the other.
References \[Bar-llillel et al.~ 1960\] Yehonhua Bar-llillel, Chaim GMfman, and E.
Sb.amir. On categorial and phrt~e structure grammars.
Bull. Rea.
Council Israel, Sec.
F., 9:1-16, 1960.
\[Calder el al., 1989\] Jonathan Calder, Mike Reape, and Henk Zeevat.
An algorithm for generation in Unification Categorlal Grammars.
EACL, 1989.
\[D~irre and Dorna, 1993\] Jochen DSrre and Michael Dorua.
CUF a formalism for linguistic knowledge representathm, l)eliverable R.1.2A, I)YANA 2, August 1993.
\[Dymetman et aL, 1990\] l)ymetman, Isabelle, and Perrault.
A symmetrical approach to parsing and generation.
COLING, 1990.
\[I'¥ank and Reyle, 1992\] Anette Frank and Uwe Heyle.
flow to cope with scrambling and scope.
KONVENS, 1992.
\[Gazdar et al., 1985\] Gerald Gazdar, Ewan Klein, G.I(.
Pullure, anti Ivan Sag.
Generalized Phrase Structure G'rammar.
Blackwell, Oxford t UI(~ 1985.
\[l(amp and Reyle, 1993\] liana Kamp and Uwe l/eyle, l'¥om Discourse to Logic.
Introduction to Modeltheoretlc Semantlc~ oJ Natural Language, Formal Logic and Discourse Representation Theory.
Studies in Linguistics and 1)hilosophy 42.
Kluwer Academic Publishers, Dordrecht, The Netherlands, 1993.
\[Kay, 1993\] Martin Kay.
Machine translation.
Lecture Notes, lnstitut flir Masdfinelle Spracllvcrea'l)eitut~g, June 1993.
\[l(ohl, 1992\] Dieter Kohl.
Generation front underand overspecified structures.
COLING, 1992.
\[K3nig, 199,1\] Esther KSnig.
A hypothetical reasoning algorithm for linguistic analysis.
Journal o\] Logic and Computallon,,l(i), 1994.
\[l~aml)ek, 1958\] Joachim Lam|)ck.
The mathemaLics of sentence structure.
American Mathematical Monthly, 65:15,1-170, 1958.
\[Minnen et al., 1993\] Guido Minnen, Dale Cerdemann, and Erhard liinrichs.
Direct automated inversion of logic grammars.
In Yuji Matsumoto~ editor~ Proceedings of the Fourth International Workshop on Natural Language Understanding and Logic Programming, pages 17-38, Nora, Japan, 1993.
Nara Institute of Science and Technology.
\[Pollard and Sag, 1993\] Carl Pollard and Iwm A.
Sag. Head Driven l'hrase Structure Grammar.
University of Chlcag~) Press, Chicago, 1993, \[Reyle, 1993\] Uwe l~-eyle, l)ealing with ambiguities t)y underspeclfication: Construction, representation, and deduction.
Journal of Semantics, 10(2), 1993.
\[Schabes and W~ters, 1993\] Yves Schahes and lt.ichard Waters.
Lexicalized context-free grammars.
ACL, 1993.
\[Shieber and Schabes, 1991\] Stuart M.
Shiel)er and Yves Schabes.
(\]eueration and synchronous Tree-Adjoining Grall\[tnlal'S.
Computational Intelligence, 7(,I):220-228,199l, \[Shleher et al., 1990\] Stuart M.
Shiel)er, Gertjan van Noord, lobert C.
Moore, and Fernando C.N.
Pereira. Semantlc-headdriven gencratlon.
Computational Linguistics, 16(1):30-12p 1990.
\[Shicber, 1988\] Stuart M.
Shleber. A mfiform architecture for parsing and generation.
COLIN(I, 1988.
\[Strzalkowski, 1990\] Tomek Strzalkowski.
llow to invert a naturM language parser into an elliclent generator: An all¢oritlun fiw logic grammars.
COLING, 1990.
\[van Noord, 1993\] Gertjan van Noord.
Reversibility in Natural Language Processgng.
Phi) thesis, University of Utrecht, Utrecht, Netherlands, 1993.
\[Wedeklnd, 1988\] J\[irgen Wedeklud.
Generation as structure driven derivation.
COL1NQ, 1988. 481

