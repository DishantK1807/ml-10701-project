A Chart-Parsing Algorithm for Efficient Semantic Analysis Pascal Vaillant ENST/TSI 46, rue Barrault, 75634 Paris cedex 13, France E-mail: vaillant@tsi.enst.fr Abstract In some contexts, well-formed natural language cannot be expected as input to information or communication systems.
In these contexts, the use of grammar-independent input (sequences of uninflected semantic units like e.g. languageindependent icons) can be an answer to the users’ needs.
However, this requires that an intelligent system should be able to interpret this input with reasonable accuracy and in reasonable time.
Here we propose a method allowing a purely semantic-based analysis of sequences of semantic units.
It uses an algorithm inspired by the idea of “chart parsing” known in Natural Language Processing, which stores intermediate parsing results in order to bring the calculation time down.
Introduction As the mass of international communication and exchange increases, icons as a mean to cross the language barriers have come through in some specific contexts of use, where language independent symbols are needed (e.g.
on some machine command buttons).
The renewed interest in iconic communication has given rise to important works in the field of Design (Aicher and Krampen, 1996; Dreyfuss, 1984; Ota, 1993), on reference books on the history and development of the matter (Frutiger, 1991; Liungman, 1995; Sassoon and Gaur, 1997), as well as newer studies in the fields of Human-Computer Interaction and Digital Media (Yazdani and Barker, 2000) or Semiotics (Vaillant, 1999).
We are here particularly interested in the field of Information Technology.
Icons are now used in nearly all possible areas of human computer interaction, even office software or operating systems.
However, there are contexts where richer information has to be managed, for instance: Alternative & Augmentative Communication systems designed for the needs of speech or language impaired people, to help them communicate (with icon languages like Minspeak, Bliss, Commun-I-Mage); Second Language Learning systems where learners have a desire to communicate by themselves, but do not master the structures of the target language yet; Cross-Language Information Retrieval systems, with a visual symbolic input.
In these contexts, the use of icons has many advantages: it makes no assumption about the language competences of the users, allowing impaired users, or users from a different linguistic background (which may not include a good command of one of the major languages involved in research on natural language processing), to access the systems; it may trigger a communication-motivated, implicit learning process, which helps the users to gradually improve their level of literacy in the target language.
However, icons suffer from a lack of expressive power to convey ideas, namely, the expression of abstract relations between concepts still requires the use of linguistic communication.
An approach to tackle this limitation is to try to “analyse” sequences of icons like natural language sentences are parsed, for example.
However, icons do not give grammatical information as clues to automatic parsers.
Hence, we have defined a method to interpret sequences of icons by implementing the use of “natural” semantic knowledge.
This method allows to build knowledge networks from icons as is usually done from text.
The analysis method that will be presented here is logically equivalent to the parsing of a dependency grammar with no locality constraints.
Therefore, the complexity of a fully recursive parsing method grows more than exponentially with the length of the input.
This makes the reaction time of the system too long to be acceptable in normal use.
We have now defined a new parsing algorithm which stores intermediate results in “charts”, in the way chart parsers (Earley, 1970) do for natural language.
1 Description
of the problem Assigning a signification to a sequence of information items implies building conceptual relations between them.
Human linguistic competence consists in manipulating these dependency relations: when we say that the cat drinks the milk, for example, we perceive that there are well-defined conceptual connections between ‘cat’, ‘drink’, and ‘milk’—that ‘cat’ and ‘milk’ play given roles in a given process.
Symbolic formalisms in AI (Sowa, 1984) reflect this approach.
Linguistic theories have also been developed specifically to give account of these phenomena (Tesnière, 1959; Kunze, 1975; Mel’ˇcuk, 1988), and to describe the transition between semantics and various levels of syntactic description: from deep syntactic structures which actually reflect the semantics contents, to the surface structure whereby messages are put into natural language.
Human natural language reflects these conceptual relations in its messages through a series of linguistic clues.
These clues, depending on the particular languages, can consist mainly in word ordering in sentence patterns (“syntactical” clues, e.g. in English, Chinese, or Creole), in word inflection or suffixation (“morphological” clues, e.g. in Russian, Turkish), or in a given blend of both (e.g.
in German).
Parsers are systems designed to analyse natural language input, on the base of such clues, and to yield a representation of its informational contents.
S VP ‘‘Aquam bibit.’’homo nominative accusative V Syntactical analysis based on word order Morphological analysis based on word inflexion accusative : agent: agentNP 0 NP 0 NP 1 nominative : object: objectNP 1 ‘‘[The man] [drinks] [the water].’’ In contexts where icons have to be used to convey complex meanings, the problem is that morphological clues are of course not available, when at the same time we cannot rely on a precise sentence pattern.
We thus should have to use a parser based on computing the dependencies, such as some which have been written to cope with variable-word-order languages (Covington, 1990).
However, since no morphological clue is available either to tell that an icon is, e.g., accusative or dative, we have to rely on semantic knowledge to guide role assignment.
In other words, an icon parser has to know that drinking is something generally done by living beings on liquid objects.
2 The
semantic analysis method The icon parser we propose performs semantic analysis of input sequences of icons by the use of an algorithm based on best-unification: when an icon in the input sequence has a “predicative” structure (it may become the head of at least one dependency relation to another node, labeled “actor”), the other icons around it are checked for compatibility.
Compatibility is measured as a unification score between two sets of feature structures: the intrinsic semantic features of the candidate actor, and the “extrinsic” semantic features of the predicative icon attached to a particular semantic role (i.e.
the properties “expected” from, say, the agent of kiss, the direct object of drink, or the concept qualified by the adjective fierce ).
The result yielded by the semantic parser is the graph that maximizes the sum of the compatibilities of all its dependency relations.
It constitutes, with no particular contextual expectations, and given the state of world knowledge stored in the iconic database in the form of semantic features, the “best” interpretation of the users’ input.
The input is a sequence of icons a0a2a1, a0a4a3,. . . a0a6a5, each of which has a set of intrinsic features: a7a9a8a11a10 a0a13a12a15a14a17a16a19a18a20a12 (where a18 a12 is a set of simple Attribute-Value semantic features, used to represent intrinsic features of the concept—like {<human,+1>,<male,+1>} for Daddy).
Some of the symbols also have selectional features, which, if grouped by case type, form a case structure:a21a23a22 a10 a0 a12 a14a9a16a25a24a27a26a29a28a4a1a6a30a31a18 a12 a1a33a32a34a30a13a26a29a28a33a3a35a30a31a18 a12a3a36a32a34a30a38a37a38a37a38a37a36a26a29a28a39a5a40a30a31a18 a12a5a41a32a43a42 (where each of the a44 a28a46a45 is a case type such as agent, object, goal..., and each a18a20a12a47a45 a set of simple Attribute-Value semantic features, used to determine what features are expected from a given casefiller—e.g.
<human,+1>is a feature that the agent of the verb write should possess).
Every couple a26a29a28 a45 a30a31a18 a12a47a45 a32 present in the case structure means that a18 a12a47a45 is a set of Attribute-Value couples which are attached to a0 a12 as selectional features for the case a28 a45 :a22 a8a48a10 a0 a12 a30a31a28 a45 a14a17a16a19a18 a12a47a45a50a49a52a51 a26a29a28 a45 a30a31a18 a12a47a45 a32a54a53 a21a55a22 a10 a0 a12 a14 For example, we can write:a22 a8 (write,agent) a16 {<human,+1>} The semantic compatibility is the value we seek to maximize to determine the best assignments.
1. At the feature level (compatibility between two features), it is defined so as to “match” extrinsic and intrinsic features.
This actually includes a somehow complex definition, taking into account the modelling of conceptual inheritance between semantic features; but for the sake of simplicity in this presentation, we may assume that the semantic compatibility at the semantic feature level is defined as in Eq.
1, which would be the case for a “flat” ontology1.
2. At the feature structure level, i.e. where the semantic contents of icons are defined, semantic compatibility is calculated between two homogeneous sets of Attribute-Value couples: on one side the selectional features attached to a given case slot of the predicate icon—stripped here of the case type—, on the other side the intrinsic features of the candidate icon.
The basic idea here is to define the compatibility as the sum of matchings in the two sets of attributevalue pairs, in ratio to the number of features being compared to.
It should be noted that semantic compatibility is not a symmetric norm: it has to measure how good the candidate actor fills the expectations of a given predicative concept in respect to one of its particular cases.
Hence there is a filtering set ( a22 a8 ) and a filtered set (a7a9a8 ), and it is the cardinal of the filtering set which is used as denominator: a21 a10a56a7a9a8 a30 a22 a8 a14a57a16 a21 a10 a24a4a58a27a1a46a1a6a30a38a37a38a37a38a37a13a30a43a58a27a1a60a59a61a42a2a30a33a24a4a58a35a3a39a1a4a30a38a37a38a37a38a37a6a30a43a58a35a3a62a5a40a42a36a14 a16a64a63 a45a38a65a67a66a1a46a68a5a13a69 a63 a12a70a65a67a66a1a46a68a59a71a69 a21 a10 a58 a1 a12a62a30a43a58 a3 a45a4a14 a44 (2) (where the a58a27a1 a12 and the a58a35a3 a45 are simple features of the form a26a29a72a73a1 a12 a30a46a74a67a1 a12 a32 and a26a29a72a67a3 a45 a30a46a74a75a3 a45 a32, respectively).
A threshold of acceptability is used to shed out improbable associations without losing time.
Even with no grammar rules, though, it is necessary to take into account the distance between two 1The difference in computing time may be neglected in the following reasoning, since the actual formula taking into account inheritance involves a maximum number of computing steps depending on the depth of the semantic features ontology, which does not vary during the processing.
icons in the sequence, which make it more likely that the actor of a given predicate should be just before or just after it, than four icons further, out of its context.
Hence we also introduce a “fading” function, to weight the virtual semantic compatibility of a candidate actor to a predicate, by its actual distance to the predicate in the sequence: a76a61a10 a0a6a12a77a30a31a28a46a45a2a30a43a0a4a78a36a14a9a16a19a79 a10 a0a13a12a77a30a43a0a13a78a75a14a34a37 a21 a10a56a7a9a8a80a10 a0a13a78a75a14a34a30 a22 a8a81a10 a0a13a12a82a30a31a28a46a45a36a14a46a14 (3) where: a76a61a10 a0 a12 a30a31a28 a45 a30a43a0a4a78a35a14 is the value of the assignment of candidate icon a0a13a78 as filler of the role a28 a45 of predicate a0 a12 ; a79 is the fading function (decreasing from 1 to 0 when the distance between the two icons goes from 0 to a83 ); and a21 a10a56a7a71a8a80a10 a0a4a78a35a14a34a30 a22 a8a81a10 a0a6a12a77a30a31a28a46a45a4a14a46a14 the (virtual) semantic compatibility of the intrinsic features of a0a13a78 to the selectional features of a0 a12 for the case a28 a45, with no consideration of distance (as defined in Eq.
2). 3.
Eventually a global assignment of actors (chosen among those present in the context) to the case slots of the predicate, has to be determined.
An assignment is an application of the set of icons (other than the predicate being considered) into the set of cases of the predicate.
The semantic compatibility of this global assignment is defined as the sum of the values (as defined in Eq.
3) of the individual case-filler allotments.
4. For a sequence of icon containing more than one predicative symbol, the calculus of the assignments is done for every one of them.
A global interpretation of the sequence is a set of assignments for every predicate in the sequence.
3 Complexity
of a recursive algorithm In former works, this principle was implemented by a recursive algorithm (purely declarative PROLOG).
Then, for a sequence of a84 concepts, and supposing we have the (mean value of) a85 (valency) roles to fill for every predicate, let us evaluate the time we need to compute the possible interpretations of the sequence, when we are in the worst case, i.e. the a84 icons are all predicates.
1. For every assignment, the number of semantic compatibility values corresponding to a single role/filler allotment, on an a26a29a72a27a28a39a86a62a87a4a88a36a30a31a28a33a72 a44a90a89a92a91a15a89 a72a27a86a46a93a4a32 couple (i.e.
at the feature structure level, as defined in Eq.
2) is: a10 a84a95a94a97a96 a14a54a98 a85 . 2.
For every icon, the number of possible assignments is: a21 a10 a26a29a72a40a1a6a30a46a74a27a1a39a32a34a30a13a26a29a72a67a3a75a30a46a74a75a3a13a32a46a14a99a16 a100 if a72a40a1a102a101a16a19a72a67a3 a21 a10 a26a29a72a103a30a46a74a27a1a38a32a34a30a13a26a29a72a40a30a46a74a75a3a4a32a46a14 a16 a104 a96 if a74a67a1 and a74a75a3 are equal integers a94a105a96 if a74a67a1 and a74a75a3 are distinct integers a74a67a1a6a37a106a74a75a3 if one of the values is real (1) a107a109a108 a1a43a110a102a111 a16 a10 a84a95a94a97a96 a14a34a112 a10 a84a113a94a114a96a115a94a116a85 a14a34a112 (4) (we suppose that a84a117a94a118a96a97a119a120a85, because we are only interested in what happens when a84 becomes big, and a85 typically lies around 3).
3. For every assignment, the a84a121a94a52a96 allotment possibilities for the first case are computed only once.
Then, for every possibility of allotment of the first case, the a84a122a94a123a96 possibilities for the second case are recomputed—hence, there are a10 a84a124a94a52a96 a14 a3 calculations of role/filler allotment scores for the second case.
Similarly, every possible allotment for the third case is recomputed for every possible choice set on the first two cases—so, there are a10 a84a125a94a126a96 a14a77a127 computations on the whole for the third case.
This goes on until the a85a105a128a130a129 case.
In the end, for one single assignment, the number of times a case/filler score has been computed is a63 a111 a78a33a131 a1 a10 a84a132a94a114a96 a14 a78 . Then, to compute all the possible interpretations: 1.
Number of times the system computes every possible assignment of the first icon: 1.
2. Number of times the system computes every possible assignment of the second icon: a107a109a108 a1 a110a102a111 (once for every assignment of the first icon, backtracking every time—still supposing we are in the worst case, i.e. all the assignments pass over the acceptability threshold).
3. Number of times the system computes every possible assignment of the third icon: a107a109a108 a1 a110 a111 a98 a107a109a108 a1 a110 a111 (once for every possible assignment of the second icon, each of them being recomputed once again for every possible assignment of the first icon).
( . . . ) 4.
Number of times the system computes every possible assignment of the a84a81a128a130a129 icon: a10 a107a109a108 a1 a110a102a111 a14 a107a109a108 a1 . 5.
Number of assignments computed on the whole: every assignment of the first icon (there are a107a133a108 a1 a110a102a111 of them) is computed just once, since it is at the beginning of the backtracking chain; every assignment of the second icon is computed a107a109a108 a1 a110a134a111 times for every assignment of the first icon, so a10 a107a109a108 a1 a110a102a111 a14 a3 times, . . . every assignment of the a84 a128a130a129 icon is computed a10 a107a109a108 a1 a110a102a111 a14 a107 times.
Total number of assignment calculations: a63 a107 a78a33a131 a1 a10 a107a109a108 a1 a110a102a111 a14 a78 . 6.
Every calculation of an assignment value involves, as we have seen, a63 a111 a78a33a131 a1 a10 a84a132a94a114a96 a14 a78 calculations of a semantic compatibility at a feature structure level.
So, totally, for the calculation of all possible interpretations of the sentence, the number of such calculations has been:a111 a135 a78a33a131 a1 a10 a84a132a94a114a96 a14 a78 a98 a107 a135 a78a38a131 a1 a10 a107a109a108 a1 a110a134a111 a14 a78 7.
Lastly, the final scoring of every interpretation involves summing the scores of the a84 assignments, which takes up a84a136a94a137a96 elementary (binary) sums.
This sum is computed every time an interpretation is set, i.e. every time the system reaches a leaf of the choice tree, i.e. every time an assignment for the a84 a128a130a129 icon is reached, that is a10 a107a133a108 a1 a110a134a111 a14 a107 times.
So, there is an additional computing time which also is a function of a84, namely, expressed in number of elementary sums: a10 a84a132a94a124a96 a14a54a98 a10 a107a109a108 a1 a110a134a111 a14 a107 Hence, if we label a72 the ratio of the computing time used to compute the score of a role/filler allotment to the computing time of an elementary binary sum2, the number of elementary operations involved in computing the scores of the interpretations of the whole sequence is: a10 a84a116a94a102a96 a14a34a37 a10 a107a133a108 a1 a110a134a111 a14 a107 a104a138a72 a111 a135 a78a38a131 a1 a10 a84a95a94a114a96 a14 a78 a37 a107 a135 a78a38a131 a1 a10 a107a109a108 a1 a110a102a111 a14 a78 (5) 4 The chart algorithm To avoid this major impediment, we define a new algorithm which stores the results of the low-level operations uselessly recomputed at every backtrack: 2a139 is a constant in relation to a140 : the computation of the semantic compatibility at the feature structure level, defined in Eq.
2, roughly involves a141a143a142a102a144 computations of the semantic compatibility at the feature level, defined in Eq.
1 (a141 being the average number of selectional features for a given role on a given predicate, and a144 the average number of intrinsic features of the entries in the semantic lexicon), which itself involves a sequence of elementary operations (comparisons, floating point number multiplication).
It does not depend on a140, the number of icons in the sequence.
a. The low-level role/filler compatibility values, in a chart called ‘compatibility_table’.
The values stored here correspond to the values defined at Eq.
2. b.
The value of every assignment, in ‘assignments_table’.
The values stored here correspond to assignments of multiple case slots of a predicate, as defined at point 3 of Section 2; they are the sum of the values stored at level (a), multiplied by a fading function of the distance between the icons involved.
c. The value of the interpretations of the sentence, in ‘interpretations_table’.
The values stored here correspond to global interpretations of the sentence, as defined at point 4 of Section 2.
With this system, at level (b) (calculation of the values of assignments), the value of the role/filler couples are re-used from the compatibility table, and are not recomputed many times.
In the same way, at level (c), the computation of the interpretations’ values by adding the assignments’ values does not recompute the assignments values at every step, but simply uses the values stored in the assignments table.
Furthermore, the system has been improved for the cases where only partial modifications are done to the graph, e.g. when the users want to perform an incremental generation, by generating the graph again at every new icon added to the end of the sequence; or when they want to delete one of the icons of the sequence only, optionally to replace it by another one.
In these cases, a great part of the information remains unchanged.
To take this property into account, the system stores the current sequence and the charts resulting from the parse in memory, allowing them to be only partially replaced afterwards.
Finally, we have implemented three basic interface functions to be performed by the parser.
The first one implements a full parse, the second partially re-parses a sequence where new icons have been added, the third partially re-parses a sequence where icons have been removed.
The three functions can be described as follows.
Parsing from scratch: 1.
Spot the icons in the new sequence which are potential predicates (which have a valency frame).
2. Run through the sequence and identify every possible pair a26a46a26 predicate,rolea32,candidatea32 . For each one of them, calculate the semantic compatibility a21 a10a56a7a9a8a48a10 candidate a14a34a30 a22 a8a145a10 predicate,role a14a46a14 . Store all the values found in compatibility_table: predicate 1 role 1 candidate 1 value predicate 1 role 1 candidate 2 value . . . predicate a146 role a85 candidate a84 value (and eliminate values under the threshold as soon as they appear).
3. Go through the sequence and identify the set of possible assignments for each predicate.
For every assignment, compute its score using the values stored in compatibility_table, and multiplying by the fading coefficients a79 a10 a96 a14, a79 a10a148a147 a14, . . . Store the values found in: assignments_table(Tab.
1). 4.
Calculate the list of all the possible interpretation (1 interpretation is 1 sequence of assignments).
Store them along with their values in interpretations_table.
Add a list of icons to the currently stored sequence: 1.
Add the icons of list of icons to the currently stored sequence.
2. For every pair a26a46a26 predicate,rolea32,candidatea32 . where either the predicate, or the candidate, is a new icon (is a member of list of icons), calculate the value of a21 a10a56a7a9a8a48a10 candidate a14a34a30 a22 a8a145a10 predicate,role a14a46a14 . and store the value in: compatibility_table.
3. Calculate the new assignments made possible by the new icons from list of icons: a149 the assignments of new predicates; a149 for every predicate already present in the sequence before, the assignments where at least one of the roles is allotted to one of the icons of list of icons.
a26 predicate 1, { a26 role a96, candidate a58a27a1a46a1 a10 a96 a14a150a32, . . . a26 role a85, candidate a58a27a1a46a1 a10 a85 a14a151a32 } a32 value a26 predicate 1, { a26 role a96, candidate a58a27a1a15a3 a10 a96 a14a150a32, . . . a26 role a85, candidate a58a27a1a15a3 a10 a85 a14a151a32 } a32 value . . . a26 predicate a146, { a26 role a96, candidate a58a35a78 a5 a10 a96 a14a150a32, . . . a26 role a85, candidate a58a35a78 a5 a10 a85 a14a151a32 } a32 value Table 1: Assignments Table For each of them, calculate its value, and store it in assignments_table.
4. Recompute the table of interpretations totally (no get-around).
Remove a list of icons from the currently stored sequence: 1.
Remove the icons of list of icons from the sequence stored in memory.
2. Remove the entries of compatibility_table or assignments_table involving at least one of the icons of list of icons.
3. Recompute the table of interpretations.
5 Complexity
of the chart algorithm First, let us evaluate the complexity of the algorithm presented in Section 4 assuming that only the first interface function is used (parsing from scratch every time a new icon is added to the sequence).
In the worst case: the a84 icons are all predicates; no possible role/filler allotment in the whole sequence is below the threshold of acceptability.
a149 For every predicate, every combination between one single role and one single other icon in the sequence is evaluated: there are a10 a84 a94a152a96 a14a124a98 a85 such possible couples a26a29a72a67a28a39a86a77a87a36a88a36a30a31a28a33a72 a44a90a89a92a91a15a89 a72a27a86a62a93a36a32 . a149 Since there are (worst case) a84 predicates, there are a84 a98 a10 a84a153a94a25a96 a14a105a98 a85 such combinations to compute for the whole sequence, in order to fill the compatibility table.
a149 After the compatibility table has been filled, its values are used to compute the score of every possible assignment (of surrounding icons) for every predicate (to its case roles).
Computing the score of an assignment involves summing a85 values of the compatibility table, multiplied by a value of the fading function a79, typically for a small integer.
Thus, for every line in the assignments table (Table 1), the computing time is constant in respect to a84 . a149 For every predicate, there are a107a133a108 a1a43a110a102a111 a16 a10 a84a132a94a114a96 a14a34a112 a10 a84a113a94a124a96a109a94a116a85 a14a34a112 possible assignments (see Section 3).
Since there are a84 predicates, there is a total number (in the worst case) of a84 a98 a107a109a108 a1 a110a102a111 different possible assignments, i.e. different lines to fill in the assignments table.
So, the time to fill the assignment table in relation to a84 is a84 a112a155a154 a10 a84a156a94a157a96a20a94a11a85 a14a34a112 multiplied by a constant factor.
a149 After the assignments table has been filled, its values are used to compute the score of the possible interpretations of the sentence.
The computation of the score of every single interpretation is simply a sum of scores of assignments: since there possibly are a84 predicates, there might be up to a84 figures to sum to compute the score of an interpretation.
a149 An interpretation is an element of the cartesian product of the sets of all possible assignments for every predicate.
Since every one of these sets has a107a109a108 a1 a110a102a111 elements, there is a total number of a10 a107a109a108 a1 a110a102a111 a14 a107 a16 a10 a84a95a94a114a96 a14a34a112 a107 a10 a84a95a94a114a96a133a94a116a85 a14a34a112 a107 interpretations to compute.
As each computation might involve a84a153a94a118a96 elementary sums (there are a84 figures to sum up), we may conclude that the time to fill the interpretations table is in a relation to a84 which may be written so: a10 a84a95a94a114a96 a14a54a98 a10 a107a109a108 a1 a110a102a111 a14 a107 . a149 In the end, the calculation time is not the product, but the sum, of the times used to fill each of the tables.
So, if we label a72 and a158 two constants, representing, respectively, the ratio of the computing time used to get the score of an elementary role/filler allotment to the computing time of an elementary binary addition, and the ratio of the computing time used to get the score of an assignment from the scores of the role/filler allotments (adding up a85 of them, multiplied by values of the a79 function), to the computing time of an elementary binary addition, the total computing time for calculating the scores of all possible interpretations of the sentence is: a10 a84a159a94a160a96 a14a34a37 a10 a107a133a108 a1a34a110a134a111 a14 a107 a104a52a72 a85a105a84 a10 a84a159a94a160a96 a14a13a104 a158a34a84 a10 a107a109a108 a1a43a110a102a111 a14 (6) 6 Discussion We have presented a new algorithm for a completely semantic parse of a sequence of symbols in a graphbased formalism.
The new algorithm has a temporal complexity like in Eq.
6, to be compared to the complexity of a purely recursive algorithm, like in Eq.
5. In the worst case, the second function is still dominated by a function which grows hyperexponentially in relation to a84 : the number of possible interpretations multiplied by the time used to sum up the score of an interpretation3.
In practice, the values of the parameters a72 and a158 are fairly large, so this member is still small during the first steps, but it grows very quickly.
As for the other member of the function, it is hyperexponential in the case of Eq.
5, whereas it is of order a158a34a84 a10 a107a109a108 a1 a110a134a111 a14, i.e. it is a161 a10 a84 a111a90a162 a1 a14, in the case of Eq.
6. Practically, to make the semantic parsing algorithm acceptable, the problem of the hyperexponential growth of the number of interpretations has to be eliminated at some point.
In the system we have implemented, a threshold mechanism allows to reject, for every predicate, the unlikely assignments.
This practically leaves up only a small maximum number of assignments in the assignments table, for every predicate—typically 3.
This means that the number of interpretations is no longer of the order of a107a133a108 a1 a110 a111 a14 a107, but “only” of a163 a107 : it becomes “simply” exponential.
This implementation mechanism makes the practical computing time acceptable when running on an average computer for input sequences of no more than approximately 15 symbols.
In order to give a comprehensive solution to the problem, future developments will try to develop heuristics to find out the best solutions without having to compute the whole list of all possible interpretations and sort it by decreasing value of semantic compatibility.
For example, by trying to explore the search space (of all possible interpreta3Namely, a164a130a140a123a165a143a166a31a167a82a168a169a164a171a170a90a172a27a173a15a174a71a175a55a167a148a170 . tions) from maximum values of the assignments, it may be possible to generate only the 10 or 20 best interpretations without having to score all of them to start with.

