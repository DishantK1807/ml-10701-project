LIST. AUTOMATA WITH SYNTAC'\]\[" I CAL LY STRUCTURED OU~ PU~ ~ karel 0L~VA and Martin PLATEK Faculty of Mathematics and Physics Charles University Nalostransk~ n~m~stl 25 CS-118 00 Praha I -Mal& Strana Czechoslovakia Abstract: A new type of abstract automaton is introduced, and both formal and linguistic implications are discussed, most importantly a new possibility of proving certain formal properties of (natural) languages and their grammars (such as context-freeness) and of refinement of the Chomsky hierarchy.
I. Introduction In this article we want to propose a new type of (abstract) nondeterministic automaton; its most distinguishing feature is that its input data is a l_!inear doubly, linked list and its output is a s~ntac!ic strncture, on condition that the computation was successful, i.e. the word represented by the input list was in the language defined by the automaton, all nondeterministic decisions of the automaton were correct (the automaton "guessed" what to do) and, hence, the computation finished in an accepting configuration.
Apart from other features, this automaton gives a uniform formal environment for the formulation of formal syntax of natural language(s), regardless of the intuitions standing behind the linguistic theory in Question; here, we have in mind first of all the dependency or immediate constituent approach to language description.
The intuition standing behind the de___ep_~D_T dencl approach is based on erasin~ words from the sentence and studying whether the resulting string is grammatical: by means of this, the relative mutual importance of words (i.e., d_~ependency, as the relation between the syntactically "more important" word, governor, and the "less important", den__~%, word) can be stepwise determined and then expressed e.g. in a dependency tree of the sentence.
Clearly, in more complex cases, it is impossible to subsume all these relations in a sentence purely by means of dependency, since there are also other relations to be found between words (such as coordination or apposition), as well as it is impossible to express all possible relations of dependency in the form of a tree, because in certain cases a single dependent word might have more than one governor (e.g., in cases of words depending on coordination of governOrs).
On the other hand, the intuitions standing behind the imediate constituent approach is that of replacing certain groups of words by others, and, again, studying the grammatioality of the result By means of this process, the sentences can be stepwise splitted t 9 smaller and smaller parts from which they are built of, and the structure thus obtained cln be then expressed in an IIC-tree.,498 In fact, we believe that both these intui-~ tions are extremely insightful and that it is a regretful misunderstanding that they are still felt as oppositions rather than complementations by many linguists; though there have been several attempts to merge them into a single theory (T-syntax is surely the most notable case), we are still convinced that the results do not suffice fully.
The type of automaton ("accepter") we propose is in fact able to simulate elegantly any of the two approaches during the process of computation and to reflect them also in the structure of its output.
Thus, it makes no distinction between these two linguistic approaches and allows for formulations of theories based on one or the other approach or even on any their mixture.
2. Descri t~n of the Automaton The list automaton consists of a finite control unl% attached to a (finite) linear list by a head.
The head is always able t0 read or write symbols to the item of the list on which it stands (the current item) and, in addition, it is able to read (but not %o write) the symbol On the item immediatelly to the left in the llst.
Every item of the list (and, generally, any node in the resulting syntactic structure) consists of a set of pointers L,R,C,CH,0,H,ZL and CP and information parts Cat and Lex (see fig I.).
The pointers serve the following purposes: C...serves for "simple" coordination (such as "Peter and Paul") CH..serves for embedded coordination (such as "Paul and Mary and John and Eve played tennis.
") L...at the beginning, this pointer (together with R) serves for connecting the items of the list (see fig 2.
for olarificatlon); after the computation is successfully finished, L points to the item on the left edge of the interval of items on which the current item depends (as in "John and Paul who...", see fig.
3) R...is a pointer analogical to L; serves for connecting the items of the list initially, and after the computation,R paints to the item on the right edge of the interval on which the current item depends (see fig.
3) O.
~.at the beginning, the value of this pointer equals %o L; however, it does not change during the whole computation and, hence, keeps the information about the in-put order of the items in the input list N.°.during and after the computatio n, the value of this pointer is the "head" (in the sense used in X-syntax) of the phrase re.Presented by the daughter nodes of the current node (current item) in the syntactic (sub)tree ZI,,CP~ose:rve as auxiliary pointers in processing complicated syntactic constructions (coordinations, non-projective constructions) Fig.
2 Fig.
3 Fur%her, let P be set of pointers ~C,CH,L,R,O,H,ZL,ZP},and, in addition, let THIS be a special pointer the value of which :is always the current item.
Let NIL be a special "empty" value of a pointer.
Then, we define the following basic operations of the automaton : DEL(x,y)o.ofor x~P,y~P u \[THIS}; this operatlon takes the item which is the value of y and sets the value of its pointer x to NIL CON(x,y,z)oo.for xgP,.
y,zmp uTHIS}; performing this operation means setting the pointcr,x of the item y to the value z G0(x)o.ofor x~P; the head of the automaton moves from the current item to the item which is the value of x.
If x=THIS or x=NIL the state of the centre} unlt becomes undefined (i.e., an error occurs) NEW(x) .... for x6P; a new item is created and • the value of x is set to this new item.
All pointer values of the new item are set to NIL, the information part of the item is copied from the current item WRITE(1)...i is a symbol fro~ the alphabet of the automaton; the value of Cat of the current Item Is set to i All oper~tlons are performed relatively to the current item (i.eo, "x" in their descriptlon means "x of the current item").
Their intuitive sense is reshaping the input lls% to a more complex structure by means of setting and changing the values of pointers.
Further, these basic operations can be combined to complex operations.
For the purposes of description of Czech syntax, we defined complex operations of the following types (again, the pointers are those of the current item): Z.
GO(R) II.
WRITE(a) III.
CON(R,L,R) CON(L,R,L) DEL(R,THIS) GO(L) iv.
GO(L) CON(R,L,R) CON(L,R,L) DEL(L,THIS) Go(~) v.
NEW(H) CON(R,L,H) CON(~,H,R) CON(L,H,L) CON(L,R,H) DEL(R,THIS) DEL(H,THIS ) GO(L) and other eight complex operations serving for processing coordination, non-projective constructions etc.
The automaton performs each of these operations in one step of the computation; the next operation to be performed is chosen according to the current internal state of the control unit and the information read by the head (i.e., information contained in the current item and its left neighbour in the llst).
Performing one step of the computation means performing one of the complex operations and, possibly, changing the internal state of the control unit, both according to the transition function of the automaton.
The set of complex operations introduced has two important features: first, with the help of this set, we are convinced, it is possible to describe sufficiently complete surface syntax of Czech.
Second, the set of complex operations of the automaton we use for the description of Czech syntax guarantees that any language accepted by the automaton with these operations is context-free.
This point probably deserves further discussion: the matter is that by changing the set !of basic operations (i.e., by adding some new basic operations and/or by removing the current ones) and/or by limiting the choice and ordering of basic operations in an appro.priate Way and/or by limiting the number of "visits" of the head on an item of the llst, it is possible to characterize the explicative power of different subtypes of the automaton and, hence, to characterize different types of grammars strongly equivalent with the automaton in question.
Thus, e.g., categorial grammars can be shown to be strongly equivalent with automata with operations I-IV and with the number of "visits" limited by Jconstant; context-free grammars are strongly 499 equivalent with automata with complex opera%ions.
I-III and V and c6nstant number of visits, generalized dependency grammars (this term suspiciously resembles the title of (Gazdar,Klein Pullum and Sag,85), but was in fact introduced as early as in (G}adkij,73)) are strongly equivalent with the automaton with operations I-IV etc.
For automata using complex operations different from I-V we have not find any strongly equivalent type of grammars in literature.
But probably the most important point concerns weak equivalence: any automaton using the complex operations defined is weakly equivalent to some ~ contextfree grammar.
(And extending this ' weak generative capacity will be possible only on condition of adding some new complex operation(s)).
3. Conslusions The type of automaton introduced is, in our opinion, important for several reasons.
First, it allows for stepwise refinemen~ of the set of its complex operations: first, only an acceotor might be constructed, and only later its operations can be augmented to a real parser.
Of course, the augmentation of the primary acceptor and turning it into the parser might be performed in most different ways, which allows for incarnating various linguistic theories over the initial acceptor.
Cenerally, we can start the process of creating the automaton by cor~structing the csmplex operations from basic operations DEL and GO only, applying these two basic operations,to the pointers L,R and THIS solely (i.e., only pointers from the input list).
D'ring its computation, such an accept or will simulate the derivation of the input string (string represented by the'input list).
In the second step, i.e. in building the parser, we augment these primitive complex operations by adding other basic operations and/or using other pointers, to get, eventually, the intended parser.
Second, from the linguistic viewpoint, it enables to construct a recognizing automaton a full syntactic parser (i.e., an automaton which gives a syntacticstructure as its output) which, in addition, allows to prove the context-freeness of the processed languages, but on grounds profoundly different than those of (Gazdar,Klein,Pullum and Sag,85).
Third, from the formal viewpoint, it allows to describe the whole Chomsky hierarchy of languages by a sln__i_nnf~ abstract automaton with differently limited set of operations rather than with a whole set of relatively unrelated types of machines (Turing machine, linearly bounded automaton, pushdown automaton, finite automaton): this is because the operations of the proposed automaton are in fact Just refined operations of the llst automaton proposed in (Chytil, Pl&tek and Vogel,86).
References Chytil M.P., Pl&tek M.
and Vogel J.: A note on the Chomsky hierarchy, Bulletin of EATCS 28, 1986 Gazdar G., Klein E., Pullum G.
and Sag I.: Generalized Phrase Structure Grammar, Basil Blackwell, Oxford, 1985 GladkiJ A.V.: FormalmyJe grammatiki i Jazyki, Mir, Moscow, 1973 Pl&tek M.
and Vogel J.: Deterministic list automata and erasing graphs, in The Prague Bulletin of Mathematical Linguistics ~5, Prague, 1986

