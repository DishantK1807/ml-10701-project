Vers l'utilisation des m6thodes formelles pour 
le d6veloppement de linguiciels 
Bilel Gargouri, Mohamed Jmaiel, Abdelmajid Ben Hamadou 
Laboratoire LARIS 
FSEG-SFAX, B.P. \] 088 
3018 SFAX, TUNISIA 
E-mail: {Abdelmajid.Benhamadou@fsegs.rnu.tn} 
Abstract 
Formal methods have'nt been applied enough in 
the development process of lingware although 
their advantages have been proved in many 
other domains. In this framework, we have 
investigated some applications dealing with 
different processing levels (lexical analyses, 
morphology, syntax, semantic and pragmatic). 
These investigations has mainly led to the 
following observations. First of all, we have no
ticed a lack of use of methodologies that cover 
all the life cycle of a software development. The 
formal specification has not been used in the 
first development phases. In addition, we have 
noticed the lack of formal validation and 
consequently the insufficient guarantee of the 
developed software results. Moreover, there 
has been no appeal to rigorous methods of 
integration to solve the dichotomy of data 
and processing problem. However, the use of 
the formal aspect in the Natural Language 
Processing (NLP) has generally been limited to 
describing the natural language knowledge (i.e., 
grammars) and specifying the treatments using 
algorithmic languages. Few are those who have 
used a high level specification language. 
This paper focuses on the contributions of 
formal methods in developing natural language 
software starting fl'om an experimentation 
carried out on a real application and which 
consists in specifying and validating the sys
tem CORTEXA (Correction ORthographique 
des TgXtes Arabes) using the VDM formal 
method. 
First of all, we review the advantages of formal 
methods in the general software development 
process. Then, we present the experimentation 
and the obtained results. After that, we place 
the formal methods advantages in the context 
of NLP. Finally, we give some methodological 
criteria that allow the choice of an appropriate 
formal method. 
438 
R6sum6 : 
Les mfthodes formelles n'ont pus 6t6 surf
isamment utilis6es duns le processus de 
d6veloppement des linguiciels, alors qu'elles 
ont fait leurs preuves duns d'autres domaines. 
Le prfsent article essaye de mettre en relief 
les avantuges des m&hodes formelles duns le 
contexte des langues naturelles, partant des 
r6sultats d'une exp6rience rgalisge sur une ap
plication r6elle. Duns un premier temps, nous 
rappellons les avantages globaux des mfthodes 
formelles duns le processus de dfveloppement 
d'un logiciel. Ensuite, r, ous plagons ces 
avantages duns le contexte des langues na
turelles. Enfin, nous donnons les crit~res 
m6thodologiques pour le choix d'une re&bode 
formelle appropride. 
1 Introduction

L'automatisation des langues naturelles a 
b6n6fici6 jusqu'g nos jours de nombreuses 
annfes de recherches et continue encore ~/. 
faire l'objet de plusieurs travaux, notamment 
duns le domaine du gdnie linguistique pour le 
ddveloppement d'applications spdcitiques. 
L'&ude des approches de d6veloppement des 
applications li6es au Traitement Automatique 
des Langues Naturelles (TALN), 5~ tous ses 
niveaux (i.e., lexical, morphologique, syntax
ique, s&nantique et pragmatique), (Fuchs, 1993; 
Sabah, 11989) nous a permis de constater une 
quasi-absence de l'utilisation de m&hodologies 
de dfveloppement qui int~grent routes les 
phases du cycle de vie d'un logiciel. En par
ticulier, au niveau des premi~res dtapes, nous 
avons constatfi l'absence quasi-totale de la phase 
de sp&ification formelle. 
D'un autre c6t~, nous avons constat~ une dif
ficult6, voire absence de validation formelle 
des approches utilis~es duns le d6veloppement 
et par consdquent de garantie sur les perfor
mances des r&ultats obtenus. De m~me, nous 
avons remarqu6 le non recours g des m6thodes 
rigoureuses d'int6gration pour r&oudre le 
problSme de la diehotomie donn~es-traitements. 
L'utilisation des outils formels s'est limit&, 
duns la plupart des cas, "£ la description du lan
gage (i.e., les gramma.ires) et ~ la sp&itication 
des traitements r6duite, gdn6ralement, 5. l'usage 
d'un langage algorithmique. Rares sont ccux 
qui ont utilis6 un langage de sp&ilication 
formelle de haut niveau (Za.iac, 1986; Jensen 
et al., 1993). 
Apr~s u ne pr6sentation des avantages qu'offrent 
les m6thodes formelles duns le processus de 
d6veloppement d'un logieiel, d'une mani~re 
g6nfirale, cet article essaye de mettre en re
lief les avantages specifiques au doma,ine de 
TALN partant d'une exp6rience men~e au sein 
de notre dquipe en utilisant 1~ m6thode VDM 
(Dawes, 1.991; Jones, 1986). I1 donne, ~ la fin, 
des crit~res permettant le choix d'une m6thode 
formelle appropri6e. 
2 Rappel
des principaux avantages 
des m6thodes formelles 
L'int6gration des m6thodes formelles duns le 
processus de d6veloppement de certaines at)
plications critiques comme les systhlnes temps 
r6el et les syst~mes distribu'fs a donnd ses 
preuves ces dernihres annfes (Barroca and Der
mid, 11992; Dick and Woods, 1997; l,edru, 
1993). C'est ce qui a Inotiv6 leur utilisation 
dans le ddveloppemer, t de logiciels traitant des 
problSmes complexes au niveau industriel (tlui 
et al., 1997). 
Une mfthode formelle est consid(~rde comlne 
une ddmarche de dfiveloppement de logiciels 
bas6e sur des notations mathdmatiques et des 
preuves de validation formelles (Habrias, 1995). 
Cette dfmarche utilise un processus de raf\[ine
mer, t qui part d'une sp&iiication abstraite des 
besoins pour ddboucher sur une st)fcification 
ratfin6e et ex6cutable (ou directement codable 
en un langage de programmation). I,es princi
paux avantages des m6thodes formelles peuvent 
6tre r6sum6s duns les points suivants : 
La prgcision et la non ambiguitd : l'utilisation 
d'un langage bus6 sur des notations formelles 
et pr6cises permet d'6viter route ambiguit6 et 
toute redondance duns la sp6cifieation. 
La d~tection d'erreurs conceptuelles le plus tat 
possible : l'application de preuves de wtlidation 
de la sp&ification tout le long du processus 
de rafl\]nement de cette derniSre, garanti la 
d&ection des erreurs de conception le plus tgt 
possible duns le processus de ddveloppemeI~t 
de l'application. En l'absence d'une telle 
validation, les erreurs de conception ne seront 
439 
dfitect~es qu'aprhs la phase d'implfimentation 
ee qui engendrera un c6ut suppl~mentaire. 
La satisfaction de la conception 
(gventuellernent de l'impldrnentation ) par 
rapport aux besoins : elle est garantie gr£ee 
au processus de raffinement qui part d'une 
sp&ification des besoins et applique des r~gles 
coh&entes de transformation pour aboutir ~ la 
conception finale. 
Le contr61e de la cohgrence donn&s
traitements : qui est directement pris en charge 
grgce aux preuves de validation. 
La rdutilisation : le raffinement des 
specifications formelles et leurs dficompositions 
successives permettent de mettre en fividenee 
des niveaux d'abstraction intfiressants pour la 
rfisolution du problbme et pour promouvoir la 
r~utilisation (des sp&ifieations). 
3 Presentation
et rdsultats de 
l'exp~rimentation 
3.1 Choix
et d4marehe utilise!e 
Pour mesurer l'impact de l'utilisation des 
re&bodes formelles dans le contexte du TALN, 
nous avons effectu~ la sp~cification complhte 
et valid& du systbme CORTEXA (Correction 
ORthographique des TEXtes Arabes) (Ben
Hamadou, 1993) d~velopp~ au sein de notre lab
oratoire. 
Outre la disponibilit~ de la documentation, en 
matihre de conception et d'impl~mentation, le 
choix du syst~me CORTEXA est aussi motiv~ 
par la diversit5 des approches utilis~es pour la 
reprgsentation des connaissances et des traite
ments. En effet, il se compose : 
• d'un module de d6tection des erreurs basil 
sur une analyse aftixale qui utilise un 
systhme g 6tats finis (les r&eaux de tran
sitions augmentfies : ATN). L'analyse af
fixale effectue la d~composition d'un mot 
en ses composants premiers : pr~fixe, in
fixe, sutfixe et racine en se r~f4rant 5. un 
ensemble de lexiques et de structures de 
donnfies, 
• d'un module de correction des erreurs or
thographiques qui utilise un systhme ~. base 
de rhgles et 
• d'un autre module de correction des erreurs 
typographiques qui se base sur un syst~me 
mixte. 
Le choix de VDM pour la spclcilicatiou de COR
TEXA est motiv~, d'une part, par le fait que 
cette re&bode se base sur les pr~dicats qui don
nent un haut pouvoir expressif, et d'autre part, 
pour sa notation simple et riche. Aussi, VDM 
a fair ses preuves dans le d~veloppement de 
plusieurs systhmes d'information. Contra.ire
ment aux environnements de specification des 
donn~es linguistiques tels que D-PATR (Kart
tunen, 1986), EAGLES (Erbach et al., 1996), 
etc, VDM permet de spScifier £ la fois des traite
ments et des donn~es (dans notre contexte des 
donnfies linguistiques) et offre une m~thodologie 
de dfiveloppement d'applications se basant sur 
des raflinements et des transformations valid&s. 
Partant de la description informelle des be
soins, nous avons d6velopp6 la sp6cification 
abstraite du systhme CORTEXA (appel6e 
aussi sp6cification implicite) qui engh)be, en
tre autres, la sp&ification formelle de ses fonc
tions, de ses actions et de ses rhgles de correc
tion. Cette sp6cification a 6td, ensuite, validde 
en utilisant des preuves formelles. Enfin, nous 
avons g6n6ralis6 la sp6cification de conception 
(appel6e aussi sp6cification explicite ou directe) 
partir de la sp6cification abstraite moyen
nant des rhgles relatives £ la m6thode VDM. 
Cette sp6cification de conception est facile
ment transform6e en code pour r6aliser la phase 
d'impl6mentation. 
3.2 R~sultats obtenus 
L'utilisation de la. m6thode formelle VDM pour 
la sp6cification complhte et valid6e du systhme 
CORTEXA a conduit, entre autres, aux con
stats suivants : 
lnsuffisance en r~qles : l'utilisation des preuves 
formelles nous a permis de mettre en relief, par 
rapport 'X la sp&ification initiale, certaines situ
ations non prises en compte. En particulier, les 
preuves qui permettent de s'assurer que pour 
chaque type d'erreur doit exister au moins une 
r~gle de correction nous ont permis de constater 
que l'ensemble des r~gles de correction, initiale
ment proposS, ne permet pas tie prendre en 
charge toute la typologie d'erreurs. 
Exemple 1: preuve relative g l'erreur de sup
440 
pression Exemple 3: 
(w.' ¢ cit, vw < 
Lcx : le lexique de rffdrence 
CH: l'ensemble des sfquences de chaines de 
ca ra.ct~zl'es 
Re.g: l'ensemble des r6gles de correction 
R(w) : l'applieation de la rbgle R sur la chaine 
w. On reprfsente une rSgle ell VDM par une 
fonction 
Dcl 0 : un pr&tieat qui vdrifie rerreur de 
suppression de ('~r~tet~re. 
La prdcision et la concision dc la 
spc;cification : en comparant la spdcitication in
formelle du syst{;me COI~I'EXA, t)r~sentde da.ns 
la. documenta.tion, avec la sp&ification formelle 
ddveloppde, nous rem~rquons que cette derniSre 
est plus prdcise et plus concise, l,'exemple 
2, donnd ('i-apr¢,.s, qui l)rdsente la Sl)&:ilication 
formellc' de la fonction de g(Sndration (los 
ddcompositions ai\[ixales possibles d'llll \[not w, 
ilhstre ce constat. 
Exemple 2: 
lsdecomp(w, p, i, ~s, root : CH)r : t~ 
pre True 
post ~a, bc CH (w= p,.a®i.b,,sA 
root = a • b) A (S'prefixe(w,p) A 
Ssuf fix (w, ,s) A Sinfixe(w, i)) 
/3' : le type boolden ,s ,i ji  O ( r sp  tiwment @re:i,eO ot 
£'sujSfixe()): un pr6dicat qui vfrifie la. 
propridt~ d'un infixe (respectivementd'un 
pr6fixe et d'un suffixe) pour une cha.ine. 
t"acilit(~ du &~veloppement du code : la 
spdcilica.tion de conception obtenue est StllFlS~tln
ment explMte pour les donndes ct a.lgorith
mique pour les traitements. Elle est done facile
ment codable en un langage de programmation. 
I2exemple 3, illustre l'us~Lge d'une notation al
gorithmique dans la sp6citication des fonctions. 
I1 pr6.sente la fonction S-Radic~fl de vdrifica.tion 
de la propridt6 d'un radical (formd par la racine 
et l'infixe). 
Sradical : CH x CH ---e, 13 
S,'adieal(s~,s, 2 =v~: if Sl = \[\] 
then False 
else if Sprefixe(sl, .s'e) 
then Y'rue 
else Sradical(tl(sl) , s,2) 
tl 0 : une fonction VDM qui retourne la 
sdquenee en entr6e privfe de s;~ ti'~te. 
Unicitd dc la notation : les m(~thodes formelles 
permettent d'utiliser la m5me notation pour 
ddcrire ~ussi bien les donndes que les trail;e
ments. En effet, a vec le langage VI)M-SL, as
socid g VDM, nous avons pu spdcifier toutes les 
fonctions et les donndes de r(;f6rence (le (~()I{
TEXA. l,es exemples 4 et 5 illustrent cette 
unicitd pour la reprdsentation des donndes com
t)osdes et des fonctions. 
Exemple 4 : l'enregistrement relatif a ux 
donndes d'une ddcomposition d'un mot en un 
pl'dfixe, un infixe, un suffixe et une racine. 
Deeomp :: p : CtI 
i: CH 
s: CH 
r : CII 
Exemple 5: spfcification de l'action qui g;dn~'re 
les prot)ositions de correction des suffixes pa.r 
SUl)I)ression de caract~re 
A3s(p : CH, e : CHAR)SCand : set of Cll 
pre True 
post ~ a,b, pl CCHp=a.c-b 
Apl = a. b A Pl ~ Suff ~ {Pl} ~ ,5"Cand 
CIIAR:l'ensemble des caract~res 
SCand : les suffixes candidats "~ l~r 
correction 
Surf: l'ensemble des suffixes. 
(:oh:rencc donndcs-traitemcnts : l'unicitd de 
1~ notation, a perlnis d'a, ppliquer des preuves 
formelles h, 1~ lois sur des donn6es et des 
traitements el; pa.r cons6quent de contrdler ta. 
cohgrence de ces derniers. L'exemple 1 illustre 
ce contrSle dans le cas d'un syst@m i~ base de 
d@es. 
441 
La validation de chaque composant du 
syst~me : pour chaque composant ou module 
du systhme CORTEXA, nous avons appliqufi les 
preuves de validation appropri~es, ee qui nous a 
permis de valider tous lea r~sultats partiels du 
systhme. Le th5orhme de l'exemple 6, donnfi 
ci-apr~s, permet de prouver qu'£ la suite de 
l'application de la rhgle de correction d'une er
reur de substitution, les propositions de correc
tion obtenues appartiennent au lexique. 
Exemple 6: 
Vw' E CH, Vw E Lex.Sub(w, w') 
3R E Reg.R(w') C Lex 
oh 
Sub : un prSdicat qui v~rifie l'erreur de 
substitution de caracthres. 
4 Intfir~ts des m~thodes formelles en gfinie 
linguistique 
Cette exp~rimentation, bien qu'elle soit assez 
limitde dans le temps (elle a dur~ une annie en
viron) et dans son contexte (elle s'est int&ess6 
£ un seul syst~me et non 5~ plusieurs), elle nous 
a permis d'appr&ier 5~ juste titre l'intfirSt de 
recourir aux m&hodes formelles dans le pro
cessus de dfiveloppement des applications li6es 
au TALN. Elle nous a aussi permis de dfigager 
certains avantages globaux d~di& au domaine 
du TALN qui viennent consolider ceux que 
nous avons ddjg cit& dans un cadre g~n6ral 
de d~veloppement des logiciels. Ces avantages 
sp~cifiques peuvent ~tre r~sum~s et argumentgs 
dana les points qui suivent. 
D'abord, au niveau de la sp&ification des 
besoins, les applications du TALN sont 
ggn&alement tr~s ambitieuses au d@art. Or 
on connait aujourd'hui les limites des modgles 
linguistiques et des ontils de repr&entation des 
connaissances. L'utilisation d'outils formels 
dans les premihres &apes de d~veloppement 
(i.e., analyse) permet de mettre tr~s vite en 
~vidence les limites du systhme ~ d~velopper, en 
particulier, sur le plan de la couverture linguis
tique et par consfquent de partir pour l'&ape de 
conception sur une version valid& du syst~me 
qui sera impl~mentfi et de pr6voir d'embl6 les 
possibilitfis d'extention et de r~utilisation. 
Par ailleurs, la complexit~ des traitements li6s 
au langage naturel et la diversit6 des donnfes 
linguistiques et des fortes intdractions qui ex
istent entre donn6es et traitements rendent 
la t~che de conception tr~s diIficile et pou
vant engendrer des probl~mes d'incohdrence. 
L'utilisation des m6thodes formelles au niveau 
de la conception permet d'abord, de g6rer 
la dichotomie donn6es-traitements soit par 
l'int6gration (i.e., en utilisation l'approehe ob
jet), soit par le contr61e de eohdrenee (i.e., 
par des preuves de validation) et ensuite de 
mettre en 6vidence, par des regroupements 
et des raffinements successifs, des abstractions 
intfiressantes r&ltilisables telsque des modules 
ou des sous-syst~mes pouvant ~tre disponibles 
dans une biblioth~que (Darricau et al., 1997). 
Ces abstractions correspondent par exelnple h 
des modules standards du TALN traitant le 
niveau phon&ique, morphologique, syntaxique, 
etc. Notons ~ ce propos que, la rdutilisation 
de sp&ifications (i.e., de conception) peut se 
faire directement ou moyennant des adapta
tions. Les mgthodes formelles offrent des 
environnements qui facilitent ces adaptations 
(6diteurs,..) et qui permettent la validation des 
nouvelles sp6.cifications. 
Enfin, l'utilisation d'une notation uniforme 
donne la possibilit6 d'intfgrer dans la m6me 
application une varidt6 de connMssances sur la 
langue sp~cifi~es avec des formalismes difDrents 
(i.e., grammaires d'unification, HPSG, Gram
maires Formelles, etc). Ce qui permet
tera d'avoir une meilleure cohdrence dans la 
spficification finale g produire. 
5 Les
crit~res de choix d'une 
m~thode formelle pour le TALN 
L'utilisation de la m&hode VDM pour la 
specification complete et valid~e du systhme 
CORTEXA a ~t~ g titre d'essai. ~lk)ute
fois, le choix d'une m&hode formelle pour 
le dfiveloppement d'une application de TALN 
reste crucial. Ce choix doit tenir eompte des 
spficificitfis du domaine des langues naturelles 
sur le plan du langage de sp~cification et sur 
celui de la m&hodologie appliqufie. Dans ce qui 
suit, nous donnons quelques crithres que nous 
jugeons pertinents dans le choix d'une m~thode 
formelle dana le contexte de TALN : 
442 
* Le pouvoir expressif de la 
m&hode : possibilitfi d'int~grer dans la 
m~rne spfieification des connaissances lin
guistiques writes d&rites avec des formal
ismes diff&ents. Le langage de spdeification 
dolt pouvoir unifier la repr&entation des 
diff&entes expressions. Le pouvoir expres
sir concerne aussi la sp&itication conjointe 
des donn~es linguistiques et les traitements 
qui leurs sont a.ppliquds. 
• Simplicit6 de la. notation et de In 
mdthodologie de ddveloppement. 
• Couverture max\[male du cycle de vie du 
logic\[el ~ dfivelopper. 
. Existance d'Ateliers de Gdnie Logic\[el 
(AGLs) qui supportent la m6thode. 
• Possibilit6 de supporter l'architecture du 
syst~rne envisag~ (i.e., s~quentielle, dis
tribude, parall;Ae, etc). 
6 Conclusion

l,'utilisation des m(%hodes formelles dans le 
contexte des langues naturelles permet, non 
seulement de consolider les avantages globaux 
de ces methodes dans le cadre gSn&al de 
d6veloppement de logiciels, mais aussi de rap
porter de nouveaux profits sp6cifiques au do
mMne. Cette utilisation conce.rne aussi bien 
le processus de d~Sveloppement des applications 
que leur maintenance. Cependant, le choix 
d'une m6thode a.t)propride reste lid ~la, disponi
bilit6 d'outils logiciels associ~s qui facilitent sa 
raise en oeuvre et "~ la. construction d'une bib
lioth~que de sp&ifications rfiutilisables. 
actuellement, nos travaux se concentrent sur 
la final\[sat\[on d'une approche que nous avons 
dfiveloppfie pour gdn6raliser l'utilisation des 
m&hodes formelles (VDM ou autres) dans 
le processus de d6veloppement des linguiciels. 
Cette approche int~gre les principaux formal
\[sines existants de descriI)tion des connaissances 
linguistiques (i.e., Grammaires d'Unification, 
Grammaires Formelles, HPSG, etc). 

References 

L. M. Barroca and J. A. Mc Dermid. 1992. Forreal methods : use and relevance for the development of sM'ety-criticM systems. The Computer Journal, 35(6). 

A. BenHamadou. 1993. Vdrification ct corrcction automatiqucs par analyse aflixalc des textcs dcrits en langage naturel : le cas dc l'arabe non voyelld. Ph.D. thesis, F~cult5 des Sciences de 

Tunis. Th~se Es-Sciences en lnformatique. M. Darricau, It. liadj MM)rouk, and J.G. 

Ganascia. 1997. Une approche pour la, rfutilisation des spg~cifications de logicMs. G(:nic Lwiciel, (45):21---27, Set)tember. 

J. Dawes. 1991. The VDM-,5'L refcT,:nce guide. Pitman I%blishing. 

J. Dick and E. Woods. 1997. Lessons learned from rigorous system software development. Information and Software 7~chnology, 39:551 560. 

G. Erbach, J. l)orre, S. Manandhar, and II. Uszkoreit. 1996. A report on the draft eagles encoding standard for ht)sg. In Aclcs de TALN-96, Marseille, France, May. 

K. Jensen, G.E. lie\[dora, and S. D. Richardson. 1993. NLP: 7'he PLNLP Approach,. Kulwer academic t)ublishers. 

C. B. Jones. 1986. Systematic software development using VDM. Printice t1311. 

L. Karttunen. 1986. D-parr : A develot)ment environment for unification-based grammars. In In Proceedings of the J ith International Cm@r-once on Computational Linguistics, \[)ages 74~80~ Bonn, Germany. 

Y. Ledru. 1993. Developing reactive systems in a. vdm framework. Science of Computer Programming, 20:51-71. 

G. Sabah. 1989. L'intelligence artificiellc ct le langagc, llermes. 

R,. Za.jac. 1986. Scsl : a, linguistic specitication language tbr rot. In Procedings of COI, ING'86, pages 25-92, Bonn, Germany, August. 443 

