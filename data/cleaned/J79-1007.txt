American Journal of Computational Linguistics H.
William Buttelmann Ohio State university Microfiche 7 Cogyright 1974 by the Association for Computational Linguistics ABSTRACT A formal definition for the semantics of a context free language, called a phrase-structure semantics., is given.
The definition is a model of the notion that it is phrases which have meaning and that the meaning of a phrase is a function of its syntactic structure and of the meanings of its constituents.
Next we give a definitim for translation on context free languages.
We then study a certain kind of translation on cf 1's.
which proceeds by translating on the phrase trees of the languages, and is specified by a finite set of tree-replacement rules.
We present a procedure which, given a cfg and phrase-structure semantics for a source language and a cfg and phrase-structure semantics for a target language, will (usually) produce the finite set of ttee-replacement rules for tne translation, if the translation exists.
The procedure may be viewed as a computer program which is a translator generator, and which produces another program that is a translator.
TABLE OF CONTENTS Abstract............................ 2 Tableof Contents ........................ 3 ............ 1 . Phrase Structure Syntax and Semantics 5 .........
Definition 1 (phrase-structure semantics) 6 .......
Example 1 (cfg and phrase-s tructure semantics) 7 Definition of semantic functions 4: T(G) -+ CP .a.a.... 8 U Definktionof meaning function;: L(G) +2 ........ 9 2 . Translations as Tree Mappings ................ 12 Dgfinition of general translation r: L(G1) + 2 L(G.2) .... 12 DefinitionofgenCT) .................... 13 Example2 (gen(T)) ..................... 13 Definition of translatioh r: T(G ) -t 2 T (G2) ........ 14 LCG2) Definition of translation 7: L(G1) + 2 ........ 15 Example 3 (finitely specified translation) ......... 16 3 . A Procedure for Finding Translations (Usually) ...a.a..
17 PROCEDURE
......................... 19 Proof that the function defined by PROCEDURE is a ...
22 translatiotl . ....
Figure 1 Translator Generator and Translator 25 . 4 Sample Translations .....a.a............. 27 TRANSLATION I (Postfix to Precedence Infix) ........ 27 TRANSLATION XI (Cxpliclt * to Implicit *) ....a.m..
31 TRANSLATIONIII(2.+to1.
+) ................ 32 TRANSLATIONIV(1.
+t02.+) . • 4 . 33 5 . Conclusion and Further Research ............. 33 Selected Btbliography ama...a-...am.o**.*.~.
36 SEMANTIC DIRECTED TRANSLATION t OF CONTEXT FREE LANGUAGES H.
William Buttelmam Department of Computer and Information Science Ohio State University Columbus, Ohio 43210 0.
Introduction. This paper presents a formal model of the translation of context free languages.
The model is admittedly inadequate to provide for all the intricacies and complexities of the problem of language translation.
Nevertheless, I hope that practicing apfllied and computational.
linguists will find it intuitively satisfying in its simplicity.
At the same time, the model should give us a basis for proving some theoretical results about the nature of language translation.
Translation is necessarily concerned with both syntax and semantics, so we begin with a formal definition of semantics for context free grammars.
In Section 2, a simple algorithm for translating from one context free language to another is given.
The algorithm is "controlled" by a finite set of rules which specify how to replace phrases in the source language with semantically equivalent phrases in the target language.
The translation algorithm, it turns out, is sttaightforward.
The key proble~ is in "finding" the finite set of rules which carrectly specify the trans'lation . The main part of this paper, Section 3, is concerned with that problem.
Throughout t& paper, we assume that grammars and semantics are given.
There is nothing in this paper that tells you.
how to go about writing the "right" grammar and semantics for a given cf 1.
t An earlier version of this paper was presented to the Eleventh Annual Meeting of the Association for Computational Linguistics at Ann Arbor, Michigan, August, 1973.
This research was supported in part by NSF grant GN-534.1.
Much of the presentation is formal.
Some readers may find it helpful to read only through Example 1, and then to peruse Section 4 (Sample Translations) to pick up some intuition, before proceeding with the rest of the paper.
1. Phrase Structure Syntax and Semantics.
I assume the reader is familiar with the notions of "derivation" and I1 syntax tree1' (alias "derivation tree", alias "phrase marker") for cf g ' s . Several good texts on these subjects are listed in the bibliography.
The definition of semantics which I am about to give is based oa the following two simple notions: 1) it is phrases which have mewg (paragraphs, sentences, clauses, and morphs are special cases of' phrases), and 2) the meaning of a phrase is a function of its syntactic structure and of the meanings of its constitumts.
Keeping in mind that a function is nothing but aq assignment of elements in its csdemain to elements in its domain, this definition will provide for idiomatic and emotive meaning, as well as denotative or referential meaning, provided such meanings are specified in the universe of di,scourse.
I wish to add before giving the definstion that, although I have never seen it in this form before, I do not believe this definition of semantics is original with me.
I believe it incorporates the notions of semantics in Benson (1970), Knuth (1968, 1971), some statements attributed to Thompson (cf Benson, 1970), and in* Tarski (1936).
Now the definition: Definition 1.
Let. G = (V, z, P, S) be a context free grammar where: V is the finite nonempty vocabulary, C c V is the terminal alphabet, S € (V C) is the axiom, and P is the finite nonempty set of grammar rules, having the form + A -t B, for A € (V C) and B 6 V . A phrase-structure semantics for G is a 7btuple d = (u, M, u, X, A, F, R), where: U is a set, the universe of discourse, TT M c 2" is a finite set of atomic morphemes, M p: V + 2 is the vocabulary meaning function, X =, 1,,, xl, X29 ..
., XI ) for some integer n, R A is a finite set of nbes of partial recursive functions, F is a finite set of definitions for the partial recursive functions named in A, R is a finite set of semantic rules, with the property that to each grammar rule A -t B . . .B there is assigned one 1 n semantic rule, having the form r A + B1.
. .B (xl,*..,X ~l = P, n + where p € (M U X U A), and r A + B1.
.B (x~,~~~,x n 1 = P n specifies a partial recursive function: We also require that X fI (M u A) = 0.
There is an example on the next page.
Example 1.
Coxfsider a cfg and phrase-structure semantics for well-formed addition expressions over the alphabet Z = {I, +).
L(G) = {I, I+I, I+I+I, . . .I.
G = (V, Z, P, S), and d = (U, M,, X, 4, F, R), where: semantics v = {S, I, +) + U = N U {f } U {I}, where: c = {I, +) N is the set of non-aegatiue integers, 3and f and I are recursive functions defined in F below, +t M = {N, 1, f 1 F contains just the following definitions: 1 (identity function on N + N): 1 (x) = x + f (integer addition on N x N + N) : 1) f+(x,Y) = (f+(X,Y)) (' is the successor fn).
Note that rS4+S (x1,x2,x3) = x (X,X ) does indeed specify a recursive 213 function on v(S) xu(+) xv(S) -+ v(S), since if x, and x, are in p(S) = N and if + + .I.
J + X2 is in v(+) = {f 1, then x2(x1,x3) = f (X x ) is in N and f is defined 1' 3 primitive recursive, Before explaining the example, let's first consider what the semantics is used for.
We will need the following notation for trees: 0) a is a tree, for all a f C.
1) act ...
t > is a tree, for all a c Z and trees tl, ..., t . 1 n n t For readability, we write the members of M without unnecessary braces -i.e., "1" instead of "{l)".
The above inductive definition gives a "standard" parenthebized notation for trees.
Let us denote the root of a tree t, rt(t) and the frontier, fr(t).
We shall also need the following non-standard notation: t It ...
t ] is a tree if t 0 1 n 0' n . . ., t are trees and if Informally, to[ tl.
. . t ] is the tree formed by "graf tiagl' each ti at the +I.
n i"' node of the frontier of to, which can be done since this node has the same label as the root of ti.
For example, the tree -A is denoted a<b<de>c>, and it has all the following non-standard representations: a<bc> [b<de>c], a<b<de> c> [dec], and a[a<bc>] [b<de>cL As the reader can see, the "box notation" is useful for isolating any rooted subtree.
In particular, note that S<S+S> [s<I>+s<I>] is the syntax tree S<S<I>+S<I>> of the grammar of Example 1, with its dominating suhtree S<S+S> isolated.
Now back to the semantics.
The semantic rules R are used to define a function 4 on the trees of the grammar which assigns to each syntax tree t a semantic function 4(t).
Then 4 and the meaning function p are used to define a meaning function p on the sentences of G.
First, we define 4, then u.
To define $, we must first define the codomain of @, @.
Informally, U u + is the set of all n-ary functions on 2 X***XZ~ + 2, for arbitrary n.
U Formally, let +n = {f:2 x*a*~2~ + 2 U f is a function of n arguments).
Then @ = U n=1,2, ..
. @n . t The function @:T(G) + @ assigns to each t in T(G) a semantic fu~ction $(t) on IJ(B~)x*.~x~(B ) + p(rt(t)), where B1...B = fr(t).
To specify a n n semantic function we will use the notathn f(x **8,\) :D + C, where f is 1' the name of the function, (xl,.
. .,x ) is the vector of arguments, D is the n domain, and C is the codomain.
$ is defined by the following inductive definition: t T(G) is the set of syntax trees (partial and complete) of G.
= r (xl, ..., x ):p(~ )x***xp(B ) + p(A), where A+B1..
.B n 1 a n A .+ B1...B is a grammar rule.
n 1) Let t tO[t t 1 T(G), n and let Bi +l...Bi = fr(t ) for j = 1, ..., n, where i = 0.
j j 0 j -1 Then @(t0Itl...t ])(x1, ..., x ):.~I(B~)x"*x~(B~ ) + v(rt(tO)) n i n n Intuitiv&ly, the semantic function assigned to each tree t is the composition of the semantic functions assigned to the subtrees of which t is composed.
We leave it to the reader to verify that $ is well-defined.
The meaning function p on sentences is a special case of the meaning function v on a larger domain -the set of phrase forms of the grammar.
A phrase form is similar to a sentential form, except that it need not be derived from the axiom.
Formally, the set of phrase.
forms of G is the set * * P(G) = I w I v C V and Aaw for some A 6 v).
The function $ is used to define the meaning function as follows.
The u function p:P(G) +2 is defined by the following rule: Let w = w ..OW be 1 n a phrase form in P (G) and let w have syntax trees tl, . . ., t . Then the m set of tueanings of w is the set L(G), the language of G, is a subset of P(G), so the meaning function on.
u sentences, p:L(G) + 2, is just the restriction of p to L(G) . A Since the three functions v, y, and II have disjoint domains, they can never be confused, so we shall write v for all three.
).I is the meaning function, which assigns to each sentence, phrase form, and symbol, one or more meanings according to the semantics d . Thus, we are assigning meaning to a sentence by assigning to it the meanbgs which are computed by the semantic functions specified by its phrase structures, taking as argu~ ments the meanings of the constituents of the sentence.
The most elementary constituents of a sentence are the members of C which constitute it.
One .may think of these as the lexical items of the language.
Their meanings, wMch are the arguments of the semantic function, are among the morphemes of the language -those morphemes which cannot be furthe-r separated into morphemes (this is the set of "atomic morphemes", M) . Thus, the meaning of a sentence is a function of its morphemes.
lhich function to use tq determined by its syntactic structure.
A sentence can be semantically ambiguous if it has more than one syntax tree or if at least one of its constituents is semantically ambiguous.
We retyrn to Example 1 on the next page.
Now consider Example 1.
Let w be the sentence "L + I' + I".
It has the syntax tree One meaning oE w is 4 (t) (P (I), P (+I, P (I), IJ (+.I, P (I)).
For notational purposes, let tl, tq, 3, and t4 be the subtrees of t circled in the picture.
Now compute this member of P (w) : Note that "I + I + I" also has the syntax tree but the sentenge is not semantically ambiguous since 2.
Translation9 As Tree Mappings.
Consider now any two cfg's and their associated semantics, 9, dl and G2, J2.
A translation of L(G1) tjo L(G ) is a function 2 T: L(G,) + 2 L (G*) defined as follew: The codomain of a translatfon must be the power set of the target language, since every sentence in L(G ) may have many semantically equivalent sen1 tences in L(G2).
In this paper wel focus on banslations which are specified by a finite set of rules.
For these translations, there is a simple algorithm for computing the trans lati011 of any sentence.
This section presents th2 bethod for giving the finite specification of T and the algorithm for computing the translation.
In fact, instead of specifying a translation on the languages, we specify a translation on the trees of the syntaxes.
To make precise what is meant by "translqtions which are specified by a finite set of rules" we Sntroduce the concept of a generating set for trees.
Let T and T2 be two sets bf trees with labels from some alphabet 1 0 C.
Define the set T to be the set of all trees with single nodes and C labels from g, i.e., = { a I a E E}.
Informally, T is a generating.
set 1 0 for T just in case every tree in T7 is either in T or is constructed of a 2 C finite number of trees of T and just in case every tree so constructed is 1' in Tt.
Formally, let T be a set of trees with labpls from Z.
The set gen(T) of trees generated by T is defined inductively %as fol'lows: 0 0) TI: C gen(7) and T c gen(T), 1) tO[tl..
. t ] E gen(T) if it is defined, n for all positive integer$.
n, and for all trees to,, ..., t € gen(T).
n T is a generating set for gen(T).
We leave it to the reader to verify that every tree in gen(T) can be written in the f orin to [ tl.
. . t ], where n n t € (T U T;) and each ti € gen(T), for i = 1, . . . . st.
0 Example
2.
The set of production.trees of a cfg is a generating set for the set of all the syntax trees of the grammar.
Let G = (V, C, P, S), let P (i), B contain k rules, and let P = { A (i) (i) (i) 1 *2 ...B n4 1iE1,2, m.a,kl.
Then the set of production trees of G is the .set The set T(G) of all syntax trees of G is the set gen(T,).
As a more concrete example, consider the cfg G given by the following Tp is the set { S<OS>, S<B2, B<O>, Bcl> 1, or written pictorially: T(G) = gen(Tp) contains all trees of the following forms:: s (COS)" (>p n>0, The tree t = S<OS<OS<B>>> is 111 T(G) = gm(Tp) since t = S~OS~[OS~OS~B~~} and S<OS> € Tp; 0 € gen(Tp), and ScOS<B>> € ges(Tp).
Note that t can also be written as t = s<OS<OS>> [OOS<B>], and again, S<OScOS>> € gen mp), 0 f gen(Tp), and S<B> € gen(~~).
To specify a translation from T(G ) to T(G~) we proceed as fallows: 1 Let r be any partial function on VN -+ V, and let T be a generating set N, I L for T(GI).
Let ; be a function on T + T(Gp) x N + + 0 which satisfies the following properties : if ;(t) = (t', xl...x ) then n i) rtt') = ;(rt (t)), and ii) n = 1 fr(tt) 1, and iii) 0 < x.
< Ifr(t)I, for i = 1, ..., n, and 1 iv) xi # 0 * fr(tr)i = r(fr(t) ), for i = 1, ..., n.
X i T(Gg) Then we define the funktion r: T(G1) + 2 by the following inductive definition: 0) t € T -r(t) = t, where ;(t) = (t', x).
where i) ;(to) = (T (to), XI) 9 and n ii) any member of Note that the codomain of T is the power set of T(G2) because there may be trees in T(G ) whose non-trivial factorings into t [ t . . . t ] are not unique.
1 0 1 m For these trees, ~(t) = { +(t 0 [t 1 ...tm]) 1 tO[tl...t 1 is a repre~entatim m of t ).
As with languages, we will call a translation only if it preT(G2) serves semantics, that is, T: T(G1) + 2 is a transPation iff for every tree t 6 T(G~) and for every tree t' E T(G~), if fr(t) = wl...w and m fr(tt) = w; ...
w', then n t N is the set of non-negative integers.
0 We
will call r fihitely specified (specified by a finite set of rules) iff the generating set T is finite.
Finally, r is used to define a trdnslation r: L(G1) -+ 2 L(%) as follows: Let w € L(Gl) have syntax trees tl, ....
\. Then r(w) = { w' 1 3 t' in T(G2) and 3 t in T(G1) such that t' is a syntax tree of w' and t is a syntax tree of w and tt € ~(t) I.
It follows from the definitions that 7 is a translation if r is.
To see thtis, let w = wl..
.w and w' = wi m . . .w' and let w' E T(w).
Then there exist n sy&tax trees t of w and t' of w' such that t' C df).
Let = @(t)(ul(wl)9".9u 1 (w m )) and E 2 = (tf)(2,..,2(w). Then from the definition of 11, c1 1 ) = (w) I£ r is a G II (w) and c2 translation, then fl E2 # 0, so <(w) fl V~(T(W)) 0, and soris a translation.
The functions ; and i are the method for specifving the function r.
The specif icati.cn is finite just in case the generating set T is finite.
The inductive definition for T gives the algorithm for computing the tpanslation of any tree in T(G ), and the definition of y, together with this 1 algorithm and a general context free parser such as Floyd's or Early's algorithm, gives the algorithm for computing the translation of any sentence in L(G ).
The next example illustrates.
1 (In the following and in all subsequent examples, we shall give explicitly only the grammar rules, the right-hand side of the semantic rules, the universes of discourse, the meaning function, and those definitions of partial recursive functions that are necessary.
The reader can easily determine the rest of the specifications for the grammars and semantics, if he wishes.
For cfg's we shall follow the usual convention that all symbols which do not appear on the left-hand side of some grammar rule are terminal symbols, and that the axiom is the first symbol appearing in the first rule.
) Example 3.
We present two cfg's and their semantics, and a finitely specified translation T on T(G ) + 2 1 T(G2) . To help the intuition, consider that G, 1 describes well-parenthesized subtract ion expressions, and G2, d 11 2 descrfbes subtraction expressions in Polish postfix notation.
E + E-E x2(x1,x3) U1 = U2 = N U {f-1, where N is the set of integers and f-: N x b + N is ordinary subtracfion The translation is specified by: ?(E) = S The sentence 1-2-3 is semantically ambiguous (its meanings are O and -4).
and its two translations are given by: A E-E 1 ' OE I I 1 2 contains 12-39 i . e ., T 123) contains 1239the other hand the sentence 1(2-3) ds and is translated: i.e., ~(1-(2-3)) contains 123-3.
A Pr-ocedure for Finding . . Trznslations (Usually).
Suppose an oracle presents us with two cfg's G and G and their 1 2 respective semantics and d2.
Suppose also that a finitely specified 1 translation froq T(G1) to T(G2) exists.
Can we find it?
That is, can we produce the flnite set ofr rules aefining the functions ? and ;?
Xn this section we consider a procedure which accepts two arbitrary cfg's and their phrase structure semantics and tries to fi~d a description of such a translation.
The procedure may not always work, in thata it may not halt or the Function T it describes may.be only partial.
Kt T is guaranteed to be correct; that is, the definitions of i and ; produced specify a partial function r: T(G,).
+ 2 T(G2) which is a translation A in the sense that, for any t € T(G ), if ~(t) is defined then ~(t) is a 1 translation of t.
First, the procedure is presented; then we give the arguments that t is 3 (partial) translation.
Intuitively, the procedure works as follows: We try to find a finite generatiog set T for T(G1) and a pair of functions i: VNq+V and N..
A t I L T: T + T(G2) x N which have the property that for every tree t E T, if 0 0 A r(tO) = (t, x, then t and t' represent the same semantic function.
What 0 0 I I is meant by to and t; represent the same semantic function" is iust this: If ;(to) = Ct& 5 ...
x ) then 4(tO)(~1,eams~m) = 4(tb)(~i,aaa~'), n n provided y' = i In general, to get semantic equivalence, one has to be careful how the syntactic variables on the frontier of t are associated by the string x 0 with the syntactic variables on the frontier of t;), since these represent possible trees with mceming, and hence the domains of the semantic fwctions for t and t' 0 0 ' If such a generating set T and functions i and ; can be found, the job is finished, since it can then be shown that the function T defined by i and ; is a translation.
The procedure begins with the set Tp of production trees of G which 1' is indeed a finite generating set for T(G1) a If the procedure can find a ?? translation" for each t in T it will be successful, and will halt and P, output T,, and ;.
The procedure systematically picks successive trees t 0 in T and searches T(G ) for a semantically equivalent tree t;) whose fronP 2 tier it can roatch up by some rule x.
If it finds one, it outputs the @a definition ;(to) = (tb, x), deletes t from T and tries one of the remain0 P ing trees.
If it succeeds in exhausting T it is successful.
P' Suppose, however, that for some to in Tp, the procedure can't find a "translation" in T(G2).
Then if we assume that 7 does exist, it must be the case that t is part of a larger tree (or of each of a set of larger 0 trees) which can be "translated".
Furthermore, if we also assume that r is finitely specified, this set is finite.
Thus, the procedure tries to construct a new set of trees, T1, not containing t which is a finite OS generating set for T(G ) {to}.
It cannot be the case that the frontier 1 of to is a sentence if we also assume that the existing '; is total on il So, losing to from T(G ) cannot delete any sentences from the 1 lang,uage represented by T(G1).
The procedure takes the set T as a new 1 generating set to work with and begins again.
It turns out that finding T depends heavily an the sequence in which successive trees are chosen for translation attempts.
Therefore, to guarantee that T will be found if it exists, the procedure tries all possible sequences af trees.
The procedure has the general steuctuxe of a I1 tree search", and is represented by the search tree pictured.
below. Each node in the tree represents a subprocedure which is described below the tree.
-F Given two reduced cfg's G and G and their respective phrase1 2 structure semantics J1 and J2,, execute the search tree below far a14 integerpairs (maxi,maxs)= (1, 11, (1, 21, (2, 11, (2, 2), ...
. Iffor It any pair step 1 halts and outputs success", then halt.
t Reduced in the sense that each nonterminal symbol is derivable from the axiom an'd derives teminal.
strings. It is well-known tht every cfg rlfm be put into this form.
step 1: Set i t Ci.
Define the (finite) set of trees Define the (finite) set of all possible partial functions . I, i,, ..., ; k } such that for each j = 1, 2, ..., k, v + VN, and ;.(S1) = S .and for all A € VN 3 N, J 2 1 pl Execute step 2 for each function ; J (i.e., for each j = 1, 2, . . ., k).
If for some j the execution 11 11 of step 2 returns success", then halt and output success".
If step 2 returns "fail", increase j and continue.
If step 2 returns "fail" for a . (ie, for all j), then halt and output "fail".
J step 2: (Nab..
T, is a finite set) It . If T = (8 then return success".
i If i > maki then return "failtt.
Othewise execute step 3 for each t € T i ' If the execution of 11 step 3 returns success", then return "success".
If step 3 returns "fail", then pick the next t in Ti and execute step 3 againr If step 3 returns "fail" for all t in Ti, then return "fail".
step 3: Execute search.
If search returns "fail" then execute expand.
If expand returns "fail" then return "fail" to step 2.
I I If either search or expand returns success" then return 11 success" to step 2.
search: Generate the first (maxs) trees of T(G2) : T~ = {ti, ti, me a, t' I* maxs Test each tree t' in Tt to see if it satisfies each of the following properties : i) ;(rt (t)) = rt(tl) if) There is a string of non-negative integers x = x x . . .x a,12 n such that each of the following is true: b) xi # O =,fr(tt)i = ;(fr(t) ) for i= 1, 2, ..., n X4 for i = 1, 2, ..., n provided r1 If no such tree t' exists in T', then return fail" to step 3.
If such a tree tt does exist in T' then define ;(t) = (tt, x) set J.+ i+l define the set T i = (Ti-l it)) execute a new version of step 2.
I I I1 If step 2 returns success" return success" to step 3.
1 I
If step 2 returns fail" return "fail" to step 3.
expand: rn Let Dam(;) denote the domain of the current version of the functioh ?, i.e., ~orn()?
= {t I ?it) has been defined bysome execution of search in the current path of the search tree).
Let T$' denote the (finite) set (T.
U ~om(i)).
Define i 1 the set T to be the smallest set of trees which is a generating t set for (gen(~;) It)), and which contains the set (TI It}).
i (Note that Tt does not contain t).
I I If T is not finite, return fail" to step 3.
t Set i + i+l.
Set T + Tto i Execute a new version of step 2.
11 11 If step 2 returns success" return success" to step 3.
1 I
If step 2 retums "fail" return fail" to step 3.
END OF PROCEDURE Now we want to explain how the PROCEDURI$ defines functions (possibly partial functions) on T(G1) -+ 2 T(G2) and on L(G6 ) + 2 1 L(G2', and prove that the functions are translations.
We shall also show that if the PR0CEDZl.G halts, the translation it total, except under certain easily identifiable conditions.
Consider any path in the search tree.
It looks like this: step 1 =? step 3 F step 2 0 (; is defined here ).
(To = Tp is defined here).
(; (t) = (t', x) is defined here if the node is search).
(T1 is defined here).
(T is defined here).
n We need to identify two particular sets of trees associated with this path.
Both are finite.
The first is the domain of the function i, and the second is the set of trees "excluded" by the successive executions of expand.
Note that each execution of the subroutine search adds one item to the definition of the function, ?, and the entire definition of ; is given by the set of all these items defined by executions of search in the path.
The domain of ?, then, is the set ~orn(;) = {k I ;(t) is defined by some execution of the subroutine search in the path}.
Similarly, each execution of the subroutine expand, in its first step, defines a new set, Tts which daes not contain the tree t.
This step has the effect of excluding the tree t from any further consideration in the translation process.
The set of all such trees is the set Excl = {t I T is defined by some execution of the t subroutine exclude in the path}.
Wow, the set om(;) U T ) is a finite generating set for the set n (T(G1) Excl), so the functions i and ? define a partial function T:-T(G~) + 2 T(GZ) according to the definition in Section 2.
Furthermore, if T = b then ; is total on .the generating set, and so T is total on n (T (GI) Excl), and this is j us t the case when the PROCEDURE halts.
Since Excl is a finite set, we have the result that T is defined on all but a finite number of elements in T(G~), when the PROCEDURE halts.
Since T is.
a partial function on T(G ) -+ 2 T(G2) 1, it follows from the p (G2) definition of 7 in Section 2 that ? is a partial function on P(G ) + 2 1 and therefore on L(G1) + 2 L(G*) . Lett P(Excl) denote the set of frontiers of the trees of Excl.
Note that each member of P(Exc1) is a phrase form.
Then when the PROCEDURE halts, since T is total on (T(G,) Exc~), it A follows that is total on (P (G~) P (Excl) ) and on (L(G1) P (Excl) ) . Thus, is total on L(G1) if PROCEDURE halts and if none of the trees excluded by exclude are complete syntax trees.
If complete syntax trees are excluded, then their sentences are the only ones for which 7 is not defined.
We have left only to show that T is a translation.
The reader may recall that there may be several nontrivial factorings of trees into a form for which T is defined, and that this may lead to non-unique translations.
Furthermore, the languages may be semantically ambiguous.
These condi.tions make the proof that r is a translation less lucid, so we shall give here the proof for the case where r is defined for only one factoring of each tree and there is no ambiguity.
It will be helpful in the proof to have the following notation: Let t € T(G1) have fr(t) = wl.
. .w and let m t' C T(G2) have fr(tl) = wi ...
w'. Then by a(t) : $(tl) we mean n Now to the proof.
Let ~(t) = t'.
We wish to show that $(t) r $(tl).
Since t € gen om(;)), t can be written as t [t . . . t ] where to C om(;) 0 1 m and each of the trees t . .,, t C gen(~om(i)).
Let ;(to) = (tb, xl.
. .X ) . 1' m n Then fram the definition of T, ~(t) = t' [t'..
.t'], where for each 0 1 n For inductive hypothesis, assume that for each j = 1,.
. .,m, t (t.
Then we have: J For r E 1, ..., m let y = $(t j(v (W r r 1 jrm1+l *lj r 1, and for i = 1, ..., n let y' = $(y!)(y (v' i ), . ..,u (w' ) Then, if we 1 2 kiWl+l ki define j = kg 0 = 0, the result above demonstrates that Thus, by the defiliigion of in search, = $(t')(p2(~i),...,~2(~A)), or +(t) E $(t').
Thus r is a translatiox.
Finally, as we showed in Section 2, since T is a translation (on the.
syntax trees), r is a translation (on the languages).
In programming terminology a generator is a program whose input is a set of parameters and whose output is a specialized program (cf Brooks and I I Iverson (1969), p.
365). Then PROCEDURE constitutes a translator generator": its input is two cfg's and their associated phrase structure semantics, and its output is a table of tree transformations which "drives" a s&andard tree-mapping program.
The tree mapping program is designed to be part of a translator system composed of a parser, the tree mapper, and a frontier stripper (see Figure 1) . Translation proceeds as follows: Let G and a1 be the cfg and semantics for the source language, L1, and G2 ad 1 d the cfg an& semantics for the target language L3.
The tr~nslator is L.
given a sentence w in7L 1' The parser produces a parse tree t<w) for w.
(If w is syntactically ambiguous, the parser may produce all the parse trees of w).
If t(w) is in the domain of tihe function T defined by the tree mapper, the tree mapper will produce ~(t(w)) whose frontier is a sentence u in L 2' r ---1 transformation TRANSLATOR I table (; and i) I I 9I * T&K FRONTIER MPSPER -------------Figure 1.
Translator generator and translator.
The importance of the argument that the function defined By the PROCEDURE is a translation, is just that w and u are guaranteed to have the sgne meaning.
if they are unambiguous, and if thev are ambiguous, w and u are guaranteed to have meanings in common -i . e ., that u is, a bona f i'de -translation of w, in the ordinary sense of the word The usefulness of such a method of trahslating is that the generator, which has to considet all issues of syntax and semantics, and therefore runs very slowly, need only run once.
The translator which it produces should run very fast, since, other than parsing, it bhly has to transform trees according to the finite set of rules in the tree transformation table (the funct"ion ;).
No seman&c computing is required at transloto time.
This saction presents some examples of translations on context free languages.
The tree search procedure outlined in Section 3 is programmed in CPS and runs on the IBM ~/370/165 at Ohio State.
All of these translations were "found" by the program.
TRANSLATION I (Postfix to Precedence Infix) Postfix: Infix: Grammar Rules Semantic Rules Grammar Rules Semantic Rules S -, sso x3 (*l,x2) E + EOT Universe of discourse R = real numbers = IR~, R2, Rg, ...
1 F
= ~f+~ f-, f*, £'I Meaning function assigning atomic morphemes to lexicaL items and svntactic variables: A1 = A2 = {I}, and F1 = F contains just the definition: I: N + N: ~(x) = x.
2 The
reader should be able to figure out, after reading the definition in +*/ Section 1, that MlaH2= {R, R1, %I R3, F, f, f, f, f 1 and A number of finite specifications far translations are possible.
One is: A TA sso J=( EoT A,, 91002) ;(AJ=(?! sso yl~~]9 EOT + F A ( E A E It is interesting to note that the PROCEDURE does not have to know how + * 1 to corppute the functions f,, f, and f in order to discover this translation.
All that is needed is to assume that if a symbol appears in both semantics, it represents the same semantic entity in each, whatever that entity is.
For example, consider the two trees in the translation involving "+".
Let t = S<S%O<+>>, and t' = E<EO<+>T<F<(E)>>>.
All we need to know is that @(t) : (g(tl>, and it turns out we can find + that out without computing f : that, (g(t) : +(tl).
Consider now the translation of ABC+*.
The following shows that 3 0 T(ABc+*) = A*(w(c)): F TCF II I A F 1 (El 1 TRANSLATION I1 (Explicit * to implicit *) This translation is interesting because it shows the procedure has the ability to "iiiscover" that a word (*) in L(C1) has no translation.
But,it can findsa phrase form involving that word which can be translated to a phrase f om in L(G2).
Explicit *: E -t EOE x2(xI,5Lj) ~~(0) = f* The translation is given by: A (+)= (i+ 13) EOE * A A IA ;.PAE ri m 11 R s A * A* SOS 111 111 A * I f A B*A B*A B A I B n A TRANSLATION 111 (2, + to 1, +) L(G ) is the language of all addition expressions with 2, i.e., the 1 set of all strings of the form 2 + 2 + . . . + 2.
L(GZ) is the set of all strings of the form 1 + 1 + ...
+ 1.
Under a standard semantics, L(G ) 1 expresses the even integers and L(G ) the integers.
The procedure 11 I! 2 "discovers" that the word 2 in L(G ) must be translated as the phrase 1 X = positive integers = 11, 2, . . . ) F1 = F2, which coptains the following definition + 1) f+(x',y) = (f (x, Y)) ' (' is the successor fn+> I :N + N (identity) : I (x) = x The translation is specified by: Note that to "discover1' this translation, the procedure must' be able to + compute the function f, since it needs to know that 2 = 1+1.
Consider, fat example, @(S<2>) (~~(2)) = rS+2(p1(2)) = I (2) = 2, but + + 'S+I+S (l),(f )I() = f (1, = 2 To get the last step in the evaluation of the second semantic function, the procedure must be able to + compute f (1,l).
TRANSLATION IV (1,+ to 2,+) Suppose the procedure were asked to translate from L(G ) to L(G ) in 2 1 the previous example i.e., from the integers to the even integers.
It would never halt, but it would "discover" that the phrase "1 + 1" is to be translated as the word "2", "1 + 1 + 1 + I" as "2 + 2", etc.
It wotild define a translation which is total on the strings in L(G ) whose values 2 are even, and it would continue to look f0reve.r for possible translations for the odd-valued strings.
We leave it as an exercise for the reader to give the functions ; and ; which define this partial translation.
5. Conclusion and Further Research.
At the present time what is needed more than anything else in the area of language translation is an understanding of the fonnal nature of semantics, its relation to syntax in language description, and its role in translation.
I believe this paper provides some of the basis for that understanding.
Incidentally, the reader might have observed that the definition of phrase-s tructure semantics in Section 1 provides for solutions to the semantic projection problem (cf Katz and Fodor (1964), and Langendoen (1969)) . The reqder is certainly aware by now, if not before, that thew are many grammars and semantics for a given language.
After having played with writing grammars and semantics for simple languages for quite a while nov, I believe that, for most languages at least, there are "better" 11 grammars and semantics and worse" ones.
Some just seem to be more 11 elegsnt or simple, or natural" than others, for a given language.
But I can't say much of a specific nature about what it means for a grammar and It semantics to be "elegant", "simple", or natural".
It seems that some study ih this area might give us insight into certain skills for maklng it easier to write linguistic descriptions suitable for.
translation. One phenomenon this model explains is why it is so difficult to compute an inverse translation and get anything like the original.
That is, if one $tarts with sentence w in L and translates to w in L2, then 1 translates w' to w" back in L one would like for-w and w" to have the 1' same meaning.
But the scutt1ebut.t says it isn't so, and this model shows why.
Note that all that is requifed for T: L2 Ll + 2 to Be a translation is that if w' is a tran&@ion of w, then pl(w) fl v2(wt) # fl, i.e., that the source sentence and its translation have some commo'n meaning.
Now -r L suppose T': L -+ 2 1 is also a translation and that w" E r'(wl).
Then we 2 have pl(w) n y (wf) # 0 and -y (wi)! n u (w") # 0, but 3t does not follow 2 2 1 ---that u1(w) n b1(w1') @.
In ~der to get back to the original meaning, each translator must produce the entire set ~(w), rather than just some sentence in T (w), and then all of these must be retranslated in entirety.
Translation programs don' t usually do that.
Neither do human translators, for that matter!
Alternatively, the translator should be able to give with the translation, its parse and the atomic morphemes associated with the sentence.
The 7rocedure in this paper provides for doing that.
The same definition of translation, if it is accurzte, also explains another phenomenon of language translat-ion -haw it is that two very different translati~ns can corn from the same source.
If wt and w" are translations or w, then we have ul(w) n p2(wt) f (b and ul(w) fl u2Cwff) C fi, but it doe; not follaw that p2(~') fl v2(wvt) # 8For natural language, one would like t,opexte i the theory in this paper to arbitrary phrase structure grammars and to transformational grammars.
The ewlarlsion to transformational gramanrs requires only 3The "lore" has it that someone fed.
the following sentence to a translator from L to Lp: 1 "The spirit indeed is will-ing, but the flesh is weak".
Then lie took the translation and fed it into a translator froui L, to L LI, and got: "The liquor is all right, but the meat is spoiled".
formalizing the notion of the transform pf a semantic function to be associated with each syntax transformation.
(For transformational semantic theories which do not allow semantic change in the transformations, the extension to arbitrary phrase structure grammars is sufficient, of course).
The extension to arbitrary phrase structure grammars requires first a formal statement o.f the "phrase structures" of unrestricted grammars, since these structures are not trees.
The author's forthcoming paper, listed in the bibliography, covers the subject of the syntactic structures for unrestricted languages in detail.
There are, of course, schemes for translation other than: the one in this paper.
One might think of computing the meaning of a source sentence, and then having some effective way of generating the target sentence directly from the meaning.
The scheme in this paper, however, is more attractive at present than such a "direct" scheme, for three reasons: 1) It is intuitively satisfying.
I believe I translate by first translating simple phrases and then putting their separate translations together according to some restructuring rules that are guaranteed to preserve seaantics . Thus, one "builds up" the translation of a sentence recursively.
I am more likely to call the result which I get by first computing the whole meaning and then producing a sentence (often it is a sequence of sentences) with the same meaning, a "paraphrase" l I or an interpretation", rather than a tft~anslation".
2) If used much, thss scheme is likely to be more efficient than the "direct" scheme, since no-semantic computation is required at translate t-ime.
AJl the semantic problems are examined once and for all in the translator generator; at translation time, only a sequence of tree mappings is performed simply a structure matching and replacing technique.
3) The "direct" scheme requires knowing how to specify linkuistic descriptions in such a way that, given a meaning in semantic notation, one can produce a sentence having that meaning.
This problem Ts a difficklt one not yet well understood.
Presumably, the research currently under way in the f izld of generative semantics will explicate the issues involved.
Bibliography Bbnson, D.
B. (1970).
Syntax and semantics: a categorial view.
In Information and Control, 16, ~p.
738-773. Benson, D.
B. (forthcoming) Semantic,preserving translations.
Brooks, F.
P., Jr., and Iverson, K.
E. (1969').
Automatic Data Processing.
New ~drk: Wiley.
Buttelmann, H.
W. (forthcoming).
On the syntactic structures of Unrestricted gramark In Information and Control.
Katz, 30, and Fodor, 3.
A. (1964).
The structure of a semantic theory.
In Language, 39, pp.
170-210. Reprinted in Fodor and Katz (eds).
The Structure of Language.
Englewood Cliffs, New Jersey: renti iceall^^^.
479-518. KBtz, J., and Postal, P.
(1964). An Integrated TKeory of ~inguistic Descriptions.
cambridge? MIT Press.
Hopcroft, J.
and Ullmann, J.
(1967). Formal Language-s and their Relatioh to AutomaIt;,a.
Reading, Mass: Addison-Wesley.
Ginsburg, S . (1963) . The Mathematical Theory of coitext -Free Languages.
New York: McGrw-Hill.
Knuth, D.
E. (19.68).
Semantics bf context-free languages.
In Mathemattea1 Sys-terns Theory, 2_, pp.
127-146. Knuth, D.
E. (1971).
Examples of formal semantics.
Symposium on Semantics of Algorithmic Languages.
Engelor, ed.
Lecture Notes i< Math #188.
New York: Springer-'Jarlag, pp.
212-235 Langendoen, D.
T. (1969).
The Study of Syntax.
New york: Holt, Rinehart and ::lington.
Tarski, A.
(1936). Der Wwheitsbergriff in den f~rmalasierten Sprachen.
In Squdia Philosophica, I, pp.
261-304. Originally published in 1933 .

