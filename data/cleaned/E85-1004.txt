MONTAgOVIAN DEFINITE CLAUSE GRAMMAR R.I.
Bainbridge, Dept.
of Computer Science, Teesside Polvtechnic, Middlesbrough, Cleveland, England.
Abstract This paper reports a completed stage of ongoing research at the University oF York.
Landsbergen's advocacy of analytical inverses ~or compositional suntax rules encourages the application of Definite Clause Grammar techniques to the const~uction of a parser returning Montague analysis trees.
A parser MDCg is presented which implements an augmented Friedman Warren algorithm permitting post referencing, and interfaces with a language oF intensional logic translator LILT so as to display the dorivattonal history of corresponding reduced IL Formulae.
Some familiarity with Montague's PTG and the basic DCQ mechanism is assumed.
Keqwords Compositional Semantics, Definite Clause O~amma~, Friedman Warren Algorithm, Intensional Logic, Mont•gue Orammmar, Natural Language Processing, PROLOG.
I Introduct~op Consideration is given by Landsbergen (20\] to the global algorithmic structure of a top down parser demonstrably equivalent to a compositional grammar such as that of PTG \[223.
The method is as Follo~s: 1.
Formulate the original grammar in te~ms of indexed compositional-M rules of form: If syntax trees ~Sk..Sn) satisf~ condition C then combine <Sk..
Sn~ into Sj such that the compositional history may be represented on a derivation tree (i.e.
a skeletal analgsis tree lacking node labels).
~. Subject to specified restraints evolve inverse analytical-M Rules of form: If Sj conforms to condition C" then analgse Sj into <Sk..Sn~.
3. P~ove that the composltional and analytical M ~ules are equivalent.
4. Construct a two stage parser: (i) Parse • sentence using a context free grammar (CFg) thus deriving a syntax tree.
(ii) Traverse the svntax tree in postorder \[19\] under the guidance of the analytical-M rules, constructing the derivation tree which reflects the reverse order application of the inverse rules.
An abstract algorithm describing the parser is given in the Form of procedural pseudo code, however the problem of establlshing that an implementation conForms to the algorithm is deferred, a problem perh•ps aggravated bv the absence Of • Formal notation for M rules which might otherwise have suggested appropriate data structures.
The postorder traverse in (ii) of a preorder ere•tiDe involves a duplication which may be •voided by •dopting the PROLOG Definite Clause grammar (DCg) formalism, (C28\] of.
\[3\], £4\], C5\], \[21\]), which, as has been observed \[32\] virtually forces the methodology of syntax directed translation coupled with compositional semantics.
A DCG may be ingenuously characterised as a CFQ having category sumbols augmented by argument places, and cont•ining supplementary goals not limited in function to input consumption..
Logical variables in argument places permit synthesised and inherited attributes (18\] to be handled with equal Facilit U.
The clauses of • DC~ may be directlu executed by a PROLOG interpreter, hence if combined CFg+analytical-M rules are presented in the form of Definite Clauses, the problem of mapping algorithm to implementation does not arise: the algorithm and program are one and the s•me.
The pa~sers of both Landsbergen (20\] and Friedman ~ Warren \[9\] generate only skeletal trees, other details being recoverable from the le•ves and operation indices: however the tedium of such recover v may properl~ devolve on the computer, and For ped•gogical purposes at 25 least the production of Full analgsis trees ~ould be advantageous.
This pape~ outlines a DCO implementation of a version o~ the compositional suntax o~ PTG ~hich ~etu~ns Full Montague analusis trees in the Form of vine d;agrams modified at most b~ additional.~eatu~e marking on variables.
Given an input sentence, MDCg returns sets oF trees, optionally passing members to a language of intensional logic t~anslator (LILT) ~hich generates corresponding IL Formulae.
The tndete~minacg of PRQLOg implies that a DCO written with circumspection mau also be used in reverse, but it remains to be investigated ~hether the model could be so modified as to achieve the recent obJectives of Friedman \[8\].
To handle quantification MDCO emplous a variation oF the Friedman-Warren algorithm (FWA) \[9\].
The programs are implemented in Universit~ oF Edinburgh DEC-IO PROLQG and ~un on the Universitu of York DEC-IO computer ~ Imolied Modifications to PT~ The version o~ PTO grammar implemented ;n MDCg has both significant and cosmetic changes.
As ~egards the First, Partee observes ((24\], C25\]) that a version of 51~ which inse~ts labelled bracketing, and a version oF $4 sensitive to such bracketing and generalised to add subject agreement to the first verb in each conjunct of a conjoined verb phrase, is needed in o~dey.to distinguish (1) ~rom (2).
(1) ~ohn t~ies to valk and talks.
(2) ~ohn tri#s to ~alk and talk.
Without labelled bracketing, PTG has dtFF4~ if if if if if if if if 4~ 4~ if 4~ if and then constrains the predicate to be a conjunction of one or mo~e verb phrases identifiable as commencing ~ith concordant Finite Forms.
Likewise the p~ocedure ~h|ch pa~ses infinitival complements in accordance with $8 accepts a conjunction of one or more verb phrases starting ~ith infinitives.
MDCG successFull~ generates the trees illustrated in Fig i, thus tacltlu assuming compositional counterparts adopting modifications such as the b~acketin9 o~ Partee ((24\], \[~5\])0 or the headverb Flagging convention of Bennett \[2\].
Bennett's simplified semantic tuping, ~hich results F~om t~eating IV and CN as primitive categories, is also exploited in LILT as illustrated in the appendix.
The MDCG post referencing Facilitq requires the admission oF alternative caoitaltse~ variables, and an amended #I0 ~hich undertakes the replacement bQ term T OF the earlier o#: Ca) the First uncapitalised variable with index n or (b) the last occurring variable ~ith index n.
Whethe~ capitaltsed : va~iables would prove popular ~ith advocates OF the "well Formedness constraint" \[~7\] is uncertain Feature matching, ~hich is achieved b9 PROLOg's c~oss 9oal variable instantiation conventions, plainlg affords a simple mechanism, From the suntactic viewpoint, Fo~ handling numbe~ concord and selectional restrictions on the basis o~ Feature marked lexicel entries.
Indeed since the alternative operations licenced bU 52 a~e also identified in the lexicon, MDCO has the #acilitu without amendment to produce analusis trees For plural sentences such if4~4~4~4~4~4~4~4~41-~4~4~4~4i 4~4k41-g 4k4kakak4~4~4~ 4Hl~4~4kak4~4~.4~4~ak4~akak.aka~ ~.~~ ~.~.~ ~ (a) #4:4 john tries to ~alk and talks el: m john #12:8 trg to ~alk and talk #8:6 tr U to walk #l:m walk #l:u talk (b) #4:4 JOhn tries to walk and talk #1: ~ JOhn #8:6 trg to malk and talk el: ~ tr U #12:8 ~lk and talk #I:~ walk el:= talk if if if if tk t if * fig 1.
icult~ identifying head verbs, but since a DCg works top down it encounters no such problems.
The MDCG analogue 'of identifies the aS; (3) The men have not eaten the Fishes.
$4 First Features of the subject, given a Further determiner clause in the lexicon introducing a definite article 26 paired with an additional operation number and marked with the features Cdof, pl\].
The principle of composltlonalitq \[I0\] demands that this syntactical facilitg remain ofFiciallq untriggared pending the int~oduction oF appropriate plural daterminer interpretation clauses in LILT~ however its introduction for experimental purposes allows HOCO and LILT to p~ovido a testbed for the investigation of senses For additional quantlflers.
The cosmetic variatian involves the introduction of further feature marking on variables, but since variables receive semantic interpretation only in leaf position where PTG and HI)CO are equivalent, the change has no semantic significance.
Variables as leaves are in the range heO..he~, but whereas PT@ introduces onl~ accusative marking as a side effect of combination, MI~O adds markings For gender (and If needed number).
Amendments to PT@ to reflect these innovations would ba purely decorative.
S2 would mark its outpu& with a number Featur( derived #row the quantifier, while .both £;4 and 85 would, like 52, licorice alternative operations such that f4.0 and fS.
0 would be restricted to cases where the input T wore not a variable, and f4.1..F4.4, fS.l..f~.4 would generate ha~ IV ..
thauR IV, TV him E ..
TV them~ ~espoctivel V.
Since the translation rules ~T4 and TD refer to the value of the Snout;term of a Function in the F4, F5 series these would be unaffected.
Rules in the range S3n, Sl4n ..
516n would apply on condition that the input sentence did not include a variable with index n having discordant features.
IF plural Forms became available, the subJeCt agreement clause o~ 94 would need generalisin9, and S13 would, Like Sll and $12, gain access to FS, marking its output with the number of its First argument in case the operation were FS, or with \[+plural\] otherwise.
3 Tree
Structures and P@T~ino Procedures Nodes on an analysis tree are represented internally by analogues of the "syn" structures of McCord C213, having the form: node(N,F,L,D) where: N : A rule number in the Form #Sqn:Fun, #Sun: (Fun, Inx), or #i:= such that Sun and Fun ere Man•ague syntax rule and structural operation numbers, Inx is a variable subscript, and elm indicates Iexical inse~ian.
F = A list of Features intrinsic to the node.
L = A node label in list Form.
D = In the case o~ • non-terminal node a binary list of daughters both of which are nodes, otherwise a structure of form: sense(Item, Category) used by LILT in the generation of IL Formulas.
Procedures which parse grammatical categortss normally have ten arguments the nature oF which will where necessary be explained in subsequent sections.
The general form is as #alloys: categoru(N,F,E,L, Ia, Iz, FVB, SA, SRa, SRz) where N m A node structure as described.
F m The features of the category in context which may exceed the node Features.
For example case is not an intrinsic noun phrase leaf feature, but it constrains adoption to specified configurations.
E m The environment (preorder predecessors) of the category relative to which the parse is aborted if N is non unique.
L m The transmission label.
Za, ZZ m String buffers before end after parsing.
m Free variables below list m Substitutions above list.
SRa, SRz = Substttuens.
required lists before and after pa~stng.
4 Imslem~n~tno FMA in PROLOQ The FWA handles the introduction and subsequent binding of indexed variables on n-ary substitutes for skeletal analysis trees by the manipulation of two lists, FVB (free variables below) and SA (subetltuttons above).
In order to implement the algorithm in a PROLOQ DCQ directed towards the production of strictly Manta•avian trees, each clause responsible For creating a node requires both FVB and SA argument places, the First to act as an output and the second as in input parameter, with the proviso that the top level "sentence" call set both to the empty list.
A clause charged with the construction of a T (=NP) node, provided that it does wore than read a surface pronoun, must be given the ootion of returning • default node, or alternatively of binding the noun phrase discovered to the next available variable, adding th~ binding to the FVB set, and returning a variable node instead.
In HDC@ a binding takes the Form not OF a <variable, noun-phrase) pair but af a structure: bind(Var, Inx,Node) where: Vat = The indexed variable.
Ins a The subscript.
Node m The complete structure node(NoF, L,D) for a T or, in case the binding is performed under the S3 27 analogue, for a CN.
The feature field includes both gender and number although presentl~ available determiners constrain number to be singular.
Clauses responsible #o~ returning sentence and verb phrase nodes must like-,is• construct • default node, but must be permitted to substit~t e fo~ it • node having this default as younger daughter, a T node from a binding extracted from the :u~rent FV~ as elder daughter, and the structural operation flagged with the binding index.
In all cases the FVB ~etu~ned to the head goal must represent the union of the FVBs o? those sub-goals ~hich construct daughters (p~eo~de~ successors), plus an U additions ~esulting from a specific c•11 ~o ootion, or less any extractions accomplished b~ a specific call to substitute The FVB of a given node m•U nevertheless contain bindings •pparentlu introduced b~ a preorde~ predecessor 0•cause the effect of substttu~ is to #dopt elder sisters.
Accordingl~ the published constraints \[9\] on quantification ove~ variables remaining Free in preorder predecessors must be preserved.
P~ior to extr•ction MDCG verifies that the V•r field o~ • binding does not appear as a label dominated bu the Node ~ield of an~ other b|nding available in the current FVB.
Vacuously quantified relative clauses ("not there" cases \[16\]) are, surprisingly, tolerated bU the o~iginal FMA, requirement that in the top level "sentence" call FVB must be \[\].
The latter requirement constitutes a final tilter as suggested, albeit with reservation, by d•nssen ~16\] as a means of ensuring syntactic conformity to the "variable principle".
When a parsing p~ocedu~e is called other than at top level, the SA is initiallsed at the union o~ the SA of the head goal and the FVB of an~ goal constructing an elde~ sister.
A noun phrase parsing clause which reads a surface p~onoun may ~eference any binding in the SA such that, where Node = node(NoF, L,D), the features in F conform with the p~onoun in numbe~ and gender.
A variable node having the indexed variable from the binding in its L Field is returned, thus achieving an antecedent ~e~e~ence, Neithe~ LIFO nor FIFO lists suffice to generate all permitted quantifier scope variations.
I~ FVB and SA a~e formed by simple concatenation then ~bstitute must be capable of extracting members ~andomly Alternatively substitute may safely select the next available item p~ovided that ~he lists are formed in such a ~a~ that all permutations emerge in due course.
MDCG adopts the latter choice, employing a p~edicate: mix(LI,LI, L3) ~hich, given successive calls, simulates the scattering of the members of L1 within L2 in a ~andom pattern on the assumption that L2 is al~ead~ ~andom.
* #14:10:2 the man such that he loves her finds mary * * #I= mary * * #4:4 the man such that he loves HER~ finds her2 * * #2:1 the man such that he loves HER~ * * #1:= the * * #3:3:1 man such that he loves HER~ * * .....,, ..............
* fig 2.
* *********************************************************** although a pa~allel test for variable eligibility is plainly needed.
In MDCG the eligibility p~oceduPe includes a mechanism suitable for eliminating vacuous applications of S3: the selected variable may not be dominated by any node in another FVB binding, but it mus t be dominated by the embedded sentence node.
The elimination of "left ove~s", is.
indexed variables remaining f~ee on the top node of an analysis tree, is achieved partly by the constraints on substitution which prevent appearances outside the scape of quantification, and partly by the 5 Auamentino FW~ • Since the gramma~ of PTQ does not generate post ~efe~encing pronouns, FWA is not designed to accommodate them.
In MDCg an augmented FWA is introduced to handle post referencing via capitalised variables which a~e ale•us realised as surface p~onouns.
For example in response to the input: (4) The man such that he loves he~ finds Ma~y.
the output includes a t~ee commencing as in fig 2.
28 The augment requires parsing procedures to accept two additional list holding argument places, SRa and SRz (Substituens Required at start and at end).
When a surface pronoun is encountered, a check is First made both in SA (For an antecedent ~e~e~ent) and in SRa (in case a previous post reference has been made) Fo~ • binding with matching number and gender.
IF none is Found then a dummu binding, with onlu the F Field of the node structure set, is created.
The union of this item and SRa becomes SRz, ~hilst the dumm U is added to FVB.
The SRa of an elder daughte~ is the SRa of its parent, the SRa of a younger daughter is the SRz of its elder sister, and the SRz of the younger daughter becomes the SRz oF the parent.
It is no~ required that whenever a noun phrase making clause exercises its ootion to introduce' a variable, • check must First be made of the SR list, and if possible a suitable dummu binding extracted and completed with no addition to the FVB list.
The behav|our of PROLOG ensures that completion effects all existing occurrences of the dumm U.
A consty•ant on substitution must now p~ohibit the extraction From the FVB of anu binding appea~ing in the SRz list returned to the heed goal.
In this waq not onlu maq no qounge~ sister dominate quantification ove~ a variable remaining Free in the ~amilq of an elde~ ~ister (the original constraint), but the elder siste~ must extend the same courtesv to her sibling.
b The Mechanics of MOCQ b.
I Handl~na Left Recursion Fig 3 illustrates the MIDCG equivalent is essentia11u left rscursive, which presents problems For a top-down, left-right, depth First DCQ technique.
Standard methods (343 For eliminating left recurs/on From a CFQ would be inappropriate as thou result in onlu weakl~ equivalent grammars.
The MDCg solution is to emplov a well Fo~med subst~ing table (WFST), (vide \[17\], \[31\], (33\], (35\]) and assume that the recurring item has al~eadg been Found, adding to the table the ~esult of subsequent parsing given that it is unique relative to its environment.
Since the WFST must record the ~elative position of entries, gramm•~ rule notation (GRN) which insulates the programme~ f~om lexic•l decomposition must be p~osc~ibed: accordinglu MDCQ is written in ~aw PROLOG, pairs of variables in the ~ange Ia.
Iz ~epresenting st~ing buffers before and after parsing.
6. ~ Res.tor•tive Editina Reflection on the behaviou~ of the clause in Fig 3 during the parsing of: (6) Woman such that a man loves he~.
reveals that pTior to parsing the embedded sentence, the kth variable (k=Inx) 'in the ~ange heO..he~ is generated and its binding to CN passed on in a new S~ list.
When the p~onoun is encountered, the binding with index k m•U .be extracted, a leaf node with he~ as label c~eated, and a Fo~m marked For number, gende~ and case returned as transmission label to the immediatelq dominating node.
The value o~ Lb (the embedded sentence label) ~ill in due course be ~etu~ned as: (b) a man loves her~.
Before this ma U be p~efixed w~th the common noun plus "such that" to become the 4.
.If * common(Node, Ft, E,L,I•,Zz,FVB, SA,~Ra, SRz) "* * wFst(common(CN, Ft, E, La, Ia, Ib, FVB•, SA, SRa, SRb) ), * sc•n(\[such, that2, Zb, Ic), * * gensqm(he, He, lnx, SuFFix), * * join( (bind(He, Inx, CN)IFVBa\],SA, SAa), * * join(E, CN, El), * * sentence(S, (dell, El, Lb, Ic, Iz, FVBb, SA•, SRb, SRz), * * eligible(bind(He, Inx, CN),FVBb, \[3, (3), * * dominated (He.
S). * * makevars(Nom,_,Acc,_,SuFFJx, Subj,Obj,Ft), . * editline(Nom, Ace, Sub j, Ob j, Lb, Lc), * * join(L•, \[such, thatlLc\],Ld), * * mix (FVB•, FVBb, FVBc ), * * substitute(on, node(#3: (3: Inx),Ft, Ld, \[CN, S\]), * * Node, Ld,L, \[3, \[\],FVBc,FVB, \[\],SRz), • * reco~dz (wFst (common(Node, * * Ft, ~, L, Ia, I z, FVB, SA, SRa, SRz ) ) ).
* * Fig 3.
. oF Montague's ~ule $3.
The inverse of $3 default label Ld it must be edited so as 29 to restore all variables with index k to appropriate surface Forms.
Samples OF eligible variables (i.e.
k-variables of appropriate numbep and gender) are created by makeva~s, whet,after editli~q achieves the ~equired restoration.
b. 3 Node and Transmission Labels The label o$ a leaf node is invariabl~ a root #orm, but a morphological variation is very often required as transmission label Non-leaf nodes may also be so cha~acte~ised.
When a vl~bph~ase is extracted F~om the WFST in fig 4, which ill~.4 Calls to "substitute" an~ "option" Fig 4 includes a call to substitute while a call to ootion occurs in Fig 5 which illustrates the MDCg clause responsible #or parsing proper names.
The Form of a substit~tl call is as Follows: substitute(T, Node, Nodel, T1,Tll,N1, NL1, FVB, FVB1,Sk, SR) ~hore: T = The t~pe of node involved (s=SEN, vpmIV, cnmCN).
Node = The default node constructed.
Nodal The replacement node (Nod.l-Node if no substitution is made).
TI,TI1 = Default and replacement trans* verbphrase(nodo(NO, FO, LO, DO),VF, E,L, Ia, Iz, FVB, SA, SRa, SRz) -* * wfst(vel'bphrase(node(Nl, Flo LI° D1), VF, E, La, Ia, Ib° * • FVBa0 SAo SRao SRb) )° * * mix (FVBa, SA, SAa ), • * join(E, node(N1, Fl° LI° D1 ), El), * vpadvorb (VPADV, AV, El, Lb, Ib, I z, FVBb, SAa, SRa° SRz ), * • Join(L,, Lb, Lc), • • Join(Ll° Lb, LI), * • mix (FVBa° FVBb, FVBc ), • * substttute(vp, node(#10: 7, VF0 LI, * * \[VPAI)V, node(N1, F1, L1,91) 3)~ * • node(NO, FO, LO, DO), * • Lc, Lo L~, LO, FVBc, FVB, SA, r\], SRa), * • ~ecord z (wFst (ve~bphrase (node (NO, FO, LO, DOt, VF, E, L, * * \]a, Iz, FVB, SA, SRa, SRz ) ) ).
* * fig 4.
* ust~ates the MDCG equivalent of $10, the mission labels (TII=TI if no substitnode label L1 must contain the bare ution made).
infinitive o~ the head verb while La Nl°N11 m Default and ~eplacement node contains a finite Form.
Having processed labels (NllmN1 if no substitution the adverb, a Pa~T of new labels must made, and N1,NLI-\[\] iS T=s or T=cn * nounphrase(Node, \[g, (C, Num)\],E,L, Ia, Iz,FVB, SA, SRa, SRz) "* * scan(Pn, Ia, Iz), * propor(Pn, \[O, (Num) \], * * option(node(#1: "=', \[O, (Num)\], \[Pn\], \[sense(Pn, \[pn\])\]), * * \[g, (C, Num)\], Node, \[Phi, Lo \[\], FVB0 SRa, SRz ), * * recordz(wFst(nounphrase(Node, \[g, (C, Num)\],E, * • L, la, Iz, FVB, SA, SRa, SRz) ) ).
* Fig 5.
accordingly be constructed, one For the since the new~ node label is default node and one for its transmission to be Tll).
label. Should a substitution then be FVB, FVB1 = The free variable below made, twin labels For the introduced before and after an~ extraction.
higher node must likewise be maitained by Sk the substitut e procedure.
SR taken lists = Those bindings bipassed in ancestor calls to substitute (At top level S~m£\]).
= The substituons requi~ed list containing the constraints on substitution.
30 Similarly a call to 9otion appears in the Form: option(Node, FoNodel, T1, Tll, FVB, FVB1, SR, SR1) where: Node, Nodel = The default and replacement nodes.
F = The Features (gender and number) of the node.
TI, TI1 = The default and transmission labels.
FVB, FVB1 = The Free variables below lists before and afte~ any addition.
SR, SRI = The substituens requi~ed lists before and after any subtraction.
7 A
Foretaste of LILT Warren \[32\] suggests two possibilities For encoding l•mbda te~ms in PROLOQ given the desire to represent • full typed lambda calculus0 the First portraying lambda variables as PROLOO structures and the second equating them with PROLOQ varidescriptive commentary similar to that given bq Paste• \[25\] and Dowry \[7\].
This is accomplished during a traverse in "g•lile•n" posto~der of the analysis tree, producing output o~ the Form illustrated in the appendix, From which it will be apparent that, since PROLOg does not recognise • lambd• expression Formed by juxtaposition, the initial pairing of operator and ope~•nd is achieved via a convenience p~edicate "eval" and subsquently evaluated.
Whereas d•nssen (\[14\], \[15\]) accomplishes reduction by a process of essentially localised tree transform• tions, the simplification algorithm of LILT takes advantage o~ PROLOG's list processing capabilities to undertake global list transformations whenever necessary.
MDCg LILT exemplifies the reorg•nised directed process approach discussed by War~en and Friedman \[33\], ie.
LILT is (optionally) called after each parse.
The present objective of display• * • sense(theo\[d(sg)\],l•mbd•(p:lambd•(q:exists(Y:all(X: * • ('p(X)<=~equ•ls(X,Y))k('~(Y))))))) "!.
* e • Fig &.
* ************************************************************ * transl•te(node(N,F,L, \[sense(R,T)\]),S) "* * !, sense(R,T,S),message(O, EL, S\]).
* * translate(Tree, IL) :* * structure (Tree, node(N, F, L, _), Lsub, R sub ), * * tranel•te(Rsub, Rnew), trans1•te(Lsub,Lnew), * * construct(node(N, F, L, _), Lnewo Rnew, Tree1 ), * * formulate(Tree1, ILl), * * message(N, ILl), * * simpliFq (ILl, IL).
* * Fig 7.
* ******--**--************************************************* ables.
Since LILT is concerned only with that subset of lamda calculus needed For ~epresenting Montague's language IL, a simpler scheme becomes possible.
In LILT predicate variables are represented by PROLOg atoms while PROLOG variables •re used directly For individual variables introduced by "sense*' clauses (other than those anaphoric references •1ready constrained to be in the range xO ..
x~). The essence of this scheme may be extracted From Fig 6 which illustrates the clause correlating singular definite article with its sense.
The top level translation clauses are illustrated in Fig 7.
These constitute a recursive p~ocedure which generates reduced IL formulae with ing a conventional derivational history makes the immediate return of logical representations rather than syntactic sub trees inappropriate.
Were all parsing p~ocedu~es to call a mute,/e~sion of translate locally0 it is predicted that a semantic equivalence parse (up tit) would result.
8 R~Fe?entes \[I\] Ajdukiewicz K.
(1935) Sy,tactic connexion, in McCall S.
(Ed). Polish Lpaic 1920-1939.
Clarendon, Oxford, 1967.
\[2\] Bennett M.
(197&) A variation and extension of a Montague Fragment of 31 English.
in ParSee (1976).
\[3\] Clocksin W.F.
& Mellish C.S.
(1981) P~oaramminq ~n PROLOQ.
Springe~-Verlag, Berlin.
\[4\] Colme~auer A.
(1975) MetamoPphosis g~amma~s, in Bole L.
(Ed). Natural Lanauaqe Communi~ation with ~o~pute~_.___~s.
Springe~-Ve~lag0 Berlin, 1978.
\[5\] Dahl V.
(1981) TPanslatlng spanish into logic thPough logic.
Ame~tcan dou~nal of Computational Linguistics Vol.
7 No.
3. \[b\] Davis S.
& Mithun M.
(Eds). (1979) Linauistics, Philosoohu, and Montao~e gPammaP.
Unive~sit@ oQ Texas, Austin.
\[7\] Do~tq D.R., Wall R.E.
& PetePs S.
(1981) Introduction to Montaaue Semantics.
Reidel, DoPd~echt: Holland.
\[8\] F~iedman J.
(1981) Expressing logical FoPmulas in natural language, in gPoenendijk, danssen, & Sto~hoF (1981).
~9\] FPiedman d.
& WaP~en D.
5. (1978) A pa~sing method For Montague grammars.
Linguistics & Philosoph~ 2.
\[10\] F~ege g.
(1893) On sense and PeFe~ence, in geach P.
& Black M.
(Eds) Ph~losophica 1 Writ~nqs oF ~ottlob F~eg~.
Dlackwell, OxFoPd, 19bb.
\[II\] g~oenendijk d.A.g., danssen T.M.V.
& StokhoF M.B.d (Eds).
(1981) Formal Methods in the Stud 4 Of ~qguaae I & ~ Mathematlsch CentPum, AmstePdam.
\[12\] Hintikka K.d.d., Mo~avcslk J.M.E.
& Suppes P.
(Eds). (1973) Ao~Poach~ t~ NatuPal Lanouaqff.
Reade1, Do~d~echt: Holland.
\[13\] Hobbs J.R.
& Rosenschein S.d.
(1978) Making computational sense of Montague's lntenslonal logic.
A~i~icial Intelligence 9.
\[14\] danssen T.M.V.
(1978) Simulation of a Montague gPamma~.
Annals of Sqstems ReseaPch 7.
\[15\] danssen T.M.V.
(1980) Logical investigations on PT@ a~Islr~g ~rom p~ogramming requirements.
Sqnthese 44 \[16\] danssen T.M.V.
(1981) Compositional semantics and Pelative clause Formation in Montague g~ammaw, in g~oenendijk, danssen & StokhoF (1981).
\[17\] Kaplan R.M.
(1973) A general s~ntactic p~ocesso~, in Rustin (1973).
\[18\] Knuth D.E.
(1968) Semantics oF context Free languages, Mathematical S~stems Theor~ Vol.
2 No.
2. \[19\] Knuth D.E.
(1975) The AP~ oF ~9~Pute~ PPoqPammin@ Vol.
I : Funda~e qtal Alao~ithm ~.
Addison Wesley, Reading, Mass.
\[~0\] Landsbe~gen d.
(1981) Adaptation of Montague gPamma~ to the ~equi~ements of paPsing, in gPoenendijk, danssen & Stokho~ (1981).
\[21\] McCo~d M.
(1982) Using slots and modifiers In logic g~ammaPs Fo~ natuPal language.
Artificial Intelligence 18.
\[22\] Montague R.M.
(1972) The p~oper tPeatment of quantification in ordinary English.
in Hintikka et al (1973) and Thomason (1974).
\[23\] PaPtee B.H.
(1972) Comments on Montague's papeP, in Hintikka et al (1973).
\[24\] PaPtee B.H.
(1973) Some transformational extensions of Montague grammap.
in ParSee (1976).
\[25\] ParSee B.H.
(1975) Montague g~amma~ and t~ans~o~mational gPammar.
Linguistic Inquiry 6.
\[26\] Pa~tee B.H.
(Ed). (1976) Montaque g~ammaP.
Academic PPess, N.Y.
C27\] ParSee B.H.
(1977) ConstPaining t~ansFoPmational Montague grammar: a F~amewo~k and a Fragment.
in Davis & Mithun (1981).
\[28\] PePeira F.C.N.
& Warren D.H.D.
(1980) Definite clause grammars For language analqsis.
Artificial Intelligence 13.
\[29\] Rustin R.
(Ed). (1973) Natural Lanouaqe PPocess~q, Algorithmics PPess, N.Y.
\[30\] Thomason R.H.
(1974) (Ed).
Formal Philosoohu Selected Papers of Richard Montaque.
Yale, New Ha~en \[31\] Thompson H.
(1981) Chart parsing and Pule schemata in PSQ.
Proceedings of the 19th.
annual meeting of the Association Fo~ Computational Linguistics 167-172.
\[3~\] Wa~en D.S.
(1983) Using lambda calculus to Pep~esent meanings in logic gPammaps.
P~oceedings of the 21st.
Annual Meeting of the Association #o~ Computational Linguistics \[33\] WaP~en D.S.
& F~iedman d.
(1982) Using semantics in non context F~ee paPsing oF Montague grammar AmePican ~ou~nal of Computational Linguistics 8.
\[34\] WinogPad T.
(1983) Lanquaqe as a Coanitive P~ocess.
Addison-Wesle V, Reading, Mass.
\[35\] Woods W.A.
(1970) An expePimental paPsing s~stem ~0~ tPansition network g~ammaPs, in Rustin (1973).
32 Appendix : Sample Output l: mary believes chaC John is a man.
Parse No.
1 ************* #4:4 mary believes that john is a man #1: = mary #7:6 believe that John is a man #1: believe #4:4 John is a man #I: " John #5:5 be a man #l: = be #2:2 a man #1: a #l: man 1? yes, Composit£on & Simplification **************************** \[0\] ~rom Lexicon: Basic expression \[man\] -> wan It\] from Lexicon: Basic expression \[a\] => lambda(p:lambda(q:exists( 3423:('p(_3423)& "q(_3423))))) \[2\] from \[0,1\]: Construction by T2 -> eval(lambda(p:lambda(q:exiscs( 3423:(~p( 3423)& 'q(_3423))))),'man) \[3\] from \[2\]: Instantiate variable eval(" "man, 34231 \[4\] from \[3\]: Relational no~acion • "man( 34231 \[5\] from \[4\]: Down-up ~onverslon man(3423) \[6} from \[2\]: Lambd~converslon lambda(q:exists( 3423:(man( 3423)& 'q(_3423)))) \[7\] from Lexicon: Basic expression \[be\] =~ lambda(sub:lambda( 4607:'sub('lambda(4608: equals (.
4607,_.4608T) ) ) ) \[8\] from \[6,7\]: Construction by T5 -> eval(lambda(sub:lambda(_.4607: "sub('lambda( 4608: equals(4607, 4608))))),'lambda(q:exisCs( 3~23: man(_3423)& "~(_3423))))) \[9\] from \[8\]: Instantlate variable eval(" "lambda(q:exists( 3423:(man( 3423)~ "q( 34231)11, "lambda(4608:equals(..46~7,._4608)))-\[I0\] from \[9\]: Down-up conversion eval(lambda(q:exiscs( 3423:(man( 3423)& "q(_3423)))), "lambda (_4608 : equals (_--4607,._4608~) ) 33 \[II\] from \[I0\]: InscanClace variable eval(" "lambda(4608:equals(_4607,_.4608)),..3423) \[12\] from \[ii\]: Down-up conversion eval(lambda(.4608:equals(_4607,4608)),3423) \[13\] from \[12\]: Laabda conversion equals(4607,_3423) \[14\] from \[I0\]: SubsclCuCe IdenCicals man(_4607) \[15\] from \[I01: Lambda conversion man(4607) \[16\] from \[8\]: Lamb~a conversion lambda( 4607:man(4607)) \[17\] from Lexicon: BaSic expression \[John\] => lambda(p: "p(John)) \[18\] from \[16,17\]: Construction by T4 -> eval(lambda(p: "p(John)),'lambda(_.4607:man(_4607))) \[19\] from \[18\]: InscanCiace variable eval(" "lambda(4607:man(_4607)),John) \[20\] from \[19\]: Down-up conversion eval(lambda(_.4607:man(_4607)),John) \[21\] from \[20\]: Lambda conversion man(John) \[22\] from \[18\]: Lambda conversion man(John) \[23l from Lexicon: Basic expression \[believe\] -> believe \[24\] from \[22,23\]: Conscrucclon by T7 => eval(believe,'man(John)) \[25\] from \[24\]: RelaClonal noCaClon belleve('man(John)) \[26\] from Lexicon: Basic expression \[mary\] -> lambda(p: "p(mary)) \[27\] from \[25,26\]: Construction by T4 => eval(lambda(p: "p(mary)),'belleve('man(John))) \[28\] from \[27\]: InsCanclaCe variable eval(" "believe(*man(John)),mary) \[29\] from \[28\]: Relacional nocaclon • "belleve(mary,'man(John)) \[30\] from \[29\]: Down-up conversion belleve(mary,'man(John)) \[31\] from \[27\]: Lambda conversion believe(mary,'man(John)) Logical Form believe(mary,'man(John)) 34

