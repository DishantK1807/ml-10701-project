Proceedings of the 2011 Conference on Empirical Methods in Natural Language Processing, pages 1373–1383,
Edinburgh, Scotland, UK, July 27–31, 2011. c 2011 Association for Computational Linguistics
Hierarchical Phrase-Based Translation Representations
Gonzalo Iglesiasnull Cyril Allauzennull William Byrnenull
Adri`a de Gispertnull Michael Rileynull
nullDepartment of Engineering, University of Cambridge, Cambridge, CB2 1PZ, U.K.
nullgi212,wjb31,ad465null@eng.cam.ac.uk
null Google Research, 76 Ninth Avenue, New York, NY 10011
nullallauzen,rileynull@google.com
Abstract
This paper compares several translation rep-
resentations for a synchronous context-free
grammar parse including CFGs/hypergraphs,
finite-state automata (FSA), and pushdown
automata (PDA). The representation choice is
shown to determine the form and complex-
ity of target LM intersection and shortest-path
algorithms that follow. Intersection, shortest
path, FSA expansion and RTN replacement al-
gorithms are presented for PDAs. Chinese-to-
English translation experiments using HiFST
and HiPDT, FSA and PDA-based decoders,
are presented using admissible (or exact)
search, possible for HiFST with compact
SCFG rulesets and HiPDT with compact LMs.
For large rulesets with large LMs, we intro-
duce a two-pass search strategy which we then
analyze in terms of search errors and transla-
tion performance.
1 Introduction
Hierarchical phrase-based translation, using a syn-
chronous context-free translation grammar (SCFG)
together with an null-gram target language model
(LM), is a popular approach in machine transla-
tion (Chiang, 2007). Given a SCFG null and an null-
gram language model null, this paper focuses on how
to decode with them, i.e. how to apply them to the
source text to generate a target translation. Decod-
ing has three basic steps, which we first describe
in terms of the formal languages and relations in-
volved, with data representations and algorithms to
follow.
1. Translating the source sentence null with null
to give target translations: null = nullnullnull null null,
a (weighted) context-free language resulting
from the composition of a finite language and
the algebraic relation null for SCFG null.
2. Applying the language model to these target
translations: null=null nullnull, a (weighted) context-
free language resulting from the intersection
of a context-free language and the regular lan-
guage null for null.
3. Searching for the translation and language
model combination with the highest-probablity
path: ˆnull=argmaxnullnullnullnull
Of course, decoding requires explicit data represen-
tations and algorithms for combining and searching
them. In common to the approaches we will con-
sider here, null is applied to null by using the CYK algo-
rithm in Step 1 and null is represented by a finite au-
tomaton in Step 2. The choice of the representation
of null in many ways determines the remaining de-
coder representations and algorithms needed. Since
nullnullnull is a finite language and we assume through-
out that null does not allow unbounded insertions,
null and null are, in fact, regular languages. As such,
null and null have finite automaton representations nullnull
and nullnull. In this case, weighted finite-state intersec-
tion and single-source shortest path algorithms (us-
ing negative log probabilities) can be used to solve
Steps 2 and 3 (Mohri, 2009). This is the approach
taken in (Iglesias et al., 2009a; de Gispert et al.,
2010). Instead null and null can be represented by hy-
pergraphs nullnull and nullnull (or very similarly context-free
rules, and-or trees, or deductive systems). In this
case, hypergraph intersection with a finite automa-
ton and hypergraph shortest path algorithms can be
used to solve Steps 2 and 3 (Huang, 2008). This
is the approach taken by Chiang (2007). In this
paper, we will consider another representation for
context-free languages null and null as well, pushdown
automata (PDA) nullnull and nullnull, familiar from formal
1373
language theory (Aho and Ullman, 1972). We will
describe PDA intersection with a finite automaton
and PDA shortest-path algorithms in Section 2 that
can be used to solve Steps 2 and 3. It cannot be
over-emphasized that the CFG, hypergraph and PDA
representations of null are used for their compactness
rather than for expressing non-regular languages.
As presented so far, the search performed in Step
3 is admissible (or exact) – the true shortest path
is found. However, the search space in MT can be
quite large. Many systems employ aggressive prun-
ing during the shortest-path computation with little
theoretical or empirical guarantees of correctness.
Further, such pruning can greatly complicate any
complexity analysis of the underlying representa-
tions and algorithms. In this paper, we will exclude
any inadmissible pruning in the shortest-path algo-
rithm itself. This allows us in Section 3 to compare
the computational complexity of using these differ-
ent representations. We show that the PDA represen-
tation is particularly suited for decoding with large
SCFGs and compact LMs.
We present Chinese-English translation results
under the FSA and PDA translation representations.
We describe a two-pass translation strategy which
we have developed to allow use of the PDA repre-
sentation in large-scale translation. In the first pass,
translation is done using a lattice-generating version
of the shortest path algorithm. The full translation
grammar is used but with a compact, entropy-pruned
version (Stolcke, 1998) of the full language model.
This first-step uses admissible pruning and lattice
generation under the compact language model. In
the second pass, the original, unpruned LM is simply
applied to the lattices produced in the first pass. We
find that entropy-pruning and first-pass translation
can be done so as to introduce very few search errors
in the overall process; we can identify search errors
in this experiment by comparison to exact transla-
tion under the full translation grammar and language
model using the FSA representation. We then inves-
tigate a translation grammar which is large enough
that exact translation under the FSA representation
is not possible. We find that translation is possible
using the two-pass strategy with the PDA translation
representation and that gains in BLEU score result
from using the larger translation grammar.
1.1 Related
Work
There is extensive prior work on computational ef-
ficiency and algorithmic complexity in hierarchical
phrase-based translation. The challenge is to find al-
gorithms that can be made to work with large trans-
lation grammars and large language models.
Following the original algorithms and analysis of
Chiang (2007), Huang and Chiang (2007) devel-
oped the cube-growing algorithm, and more recently
Huang and Mi (2010) developed an incremental de-
coding approach that exploits left-to-right nature of
the language models.
Search errors in hierarchical translation, and in
translation more generally, have not been as exten-
sively studied; this is undoubtedly due to the diffi-
culties inherent in finding exact translations for use
in comparison. Using a relatively simple phrase-
based translation grammar, Iglesias et al. (2009b)
compared search via cube-pruning to an exact FST
implementation (Kumar et al., 2006) and found that
cube-pruning suffered significant search errors. For
Hiero translation, an extensive comparison of search
errors between the cube pruning and FSA imple-
mentation was presented by Iglesias et al. (2009a)
and de Gispert et al. (2010). Relaxation techniques
have also recently been shown to finding exact so-
lutions in parsing (Koo et al., 2010) and in SMT
with tree-to-string translation grammars and trigram
language models (Rush and Collins, 2011), much
smaller models compared to the work presented in
this paper.
Although entropy-pruned language models have
been used to produce real-time translation sys-
tems (Prasad et al., 2007), we believe our use of
entropy-pruned language models in two-pass trans-
lation to be novel. This is an approach that is widely-
used in automatic speech recognition (Ljolje et al.,
1999) and we note that it relies on efficient represen-
tation of very large search spaces null for subsequent
rescoring, as is possible with FSAs and PDAs.
2 Pushdown
Automata
In this section, we formally define pushdown au-
tomata and give intersection, shortest-path and re-
lated algorithms that will be needed later.
Informally, pushdown automata are finite au-
tomata that have been augmented with a stack. Typ-
1374
0
1a
2
ε
(
3)b
0
1
a
2
ε
(
ε
3
)
ε
b
(a) (b)
0
1
(
3
ε
2
a
4(
)
5
b
)
0,ε
1,(
ε
3,ε
ε
2,(a
4,(ε
ε
5,(
b
ε
(c) (d)
Figure 1: PDA Examples: (a) Non-regular PDA accept-
ing nullnullnnullnnullnull null Nnull. (b) Regular (but not bounded-stack)
PDA accepting null∗null∗. (c) Bounded-stack PDA accepting
null∗null∗ and (d) its expansion as an FSA.
ically this is done by adding a stack alphabet and la-
beling each transition with a stack operation (a stack
symbol to be pushed onto, popped or read from the
stack) in additon to the usual input label (Aho and
Ullman, 1972; Berstel, 1979) and weight (Kuich
and Salomaa, 1986; Petre and Salomaa, 2009). Our
equivalent representation allows a transition to be la-
beled by a stack operation or a regular input symbol
but not both. Stack operations are represented by
pairs of open and close parentheses (pushing a sym-
bol on and popping it from the stack). The advantage
of this representation is that is identical to the finite
automaton representation except that certain sym-
bols (the parentheses) have special semantics. As
such, several finite-state algorithms either immedi-
ately generalize to this PDA representation or do so
with minimal changes. The algorithms described in
this section have been implemented in the PDT ex-
tension (Allauzen and Riley, 2011) of the OpenFst
library (Allauzen et al., 2007).
2.1 Definitions
A (restricted) Dyck language consist of “well-
formed” or “balanced” strings over a finite num-
ber of pairs of parentheses. Thus the string
( [ ( ) ( ) ] nullnull [ ] ) ( ) is in the Dyck language over 3
pairs of parentheses.
More formally, let null and null be two finite alpha-
bets such that there exists a bijection null from null to
null. Intuitively, null maps an open parenthesis to its cor-
responding close parenthesis. Let ¯null denote null(null) if
null null null and nullnull1(null) if null null null. The Dyck language
nullnull over the alphabet hatwidenull = null null null is then the lan-
guage defined by the following context-free gram-
mar: null null null, null null nullnull and null null null ¯null for all nullnullnull.
We define the mapping nullnull : hatwidenullnull null hatwidenullnull as follow.
nullnull(null) is the string obtained by iteratively deleting
from null all factors of the form null¯null with null null null. Ob-
serve that nullnull=nullnull1null (null).
Let null and null be two finite alphabets such that
null null null, we define the mapping nullnull : nullnull null nullnull
by nullnull(null1 nullnullnullnullnull) = null1 nullnullnullnullnull with nullnull = nullnull if nullnull nullnull
and nullnull=null otherwise.
A weighted pushdown automaton (PDA) null over
the tropical semiring (R null nullnullnullnullminnull+nullnullnull0) is
a 9-tuple (ΣnullΠnullΠnullnullnullnullnullnullnullnullnullnull) where Σ is the fi-
nite input alphabet, Π and Π are the finite open and
close parenthesis alphabets, null is a finite set of states,
nullnullnull the initial state, null null null the set of final states,
null null null null (Σ null hatwideΠ null nullnullnull) null (R null nullnullnull) null null a fi-
nite set of transitions, and null : null null R null nullnullnull the
final weight function. Let null= (null[null]nullnull[null]nullnull[null]nullnull[null])
denote a transition in null.
A path null is a sequence of transitions null=null1 nullnullnullnullnull
such that null[nullnull]=null[nullnull+1] for 1 null null null null. We then de-
fine null[null]=null[null1], null[null]=null[nullnull], null[null]=null[null1]nullnullnullnull[nullnull],
and null[null]=null[null1] + nullnullnull + null[nullnull].
A path null is accepting if null[null] = null and null[null] null null.
A path null is balanced if nullhatwideΠ(null[null])nullnullΠ. A balanced
path null accepts the string null null Σnull if it is a balanced
accepting path such that nullΣ(null[null])=null.
The weight associated by null to a string null null Σnull
is null(null) = minnullnullnull(null) null[null]+null(null[null]) where null(null)
denotes the set of balanced paths accepting null. A
weighted language is recognizable by a weighted
pushdown automaton iff it is context-free. We de-
fine the size of null as nullnullnull=nullnullnull+nullnullnull.
A PDA null has a bounded stack if there exists null null
N such that for any sub-path null of any balanced path
in null: nullnullΠ(nullhatwideΠ(null[null]))null null null. If null has a bounded stack,
then it represents a regular language. Figure 1 shows
non-regular, regular and bounded-stack PDAs.
A weighted finite automaton (FSA) can be viewed
as a PDA where the open and close parentheses al-
phabets are empty, see (Mohri, 2009) for a stand-
alone definition.
1375

