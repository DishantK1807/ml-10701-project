Constraints on strong generative power David Chiang University of Pennsylvania Dept of Computer and Information Science 200 S 33rd St Philadelphia, PA 19104 USA dchiang@cis.upenn.edu Abstract We consider the question “How much strong generative power can be squeezed out of a formal system without increasing its weak generative power?” and propose some theoretical and practical constraints on this problem.
We then introduce a formalism which, under these constraints, maximally squeezes strong generative power out of context-free grammar.
Finally, we generalize this result to formalisms beyond CFG.
1 Introduction
“How much strong generative power can be squeezed out of a formal system without increasing its weak generative power?” This question, posed by Joshi (2000), is important for both linguistic description and natural language processing.
The extension of tree adjoining grammar (TAG) to tree-local multicomponent TAG (Joshi, 1987), or the extension of context free grammar (CFG) to tree insertion grammar (Schabes and Waters, 1993) or regular form TAG (Rogers, 1994) can be seen as steps toward answering this question.
But this question is di cult to answer with much finality unless we pin its terms down more precisely.
First, what is meant by strong generative power?
In the standard definition (Chomsky, 1965) a grammar G weakly generates a set of sentences L(G) and strongly generates a set of structural descriptions (G); the strong generative capacity of a formalism F is then f (G) j F provides Gg.
There is some vagueness in the literature, however, over what structural descriptions are and how they can reasonably be compared across theories (Miller (1999) gives a good synopsis).
(a) X X X a X X b (b) X NA a X b X a b Figure 1: Example of weakly context-free TAG.
The approach that Vijay-Shanker et al.(1987) and Weir (1988) take, elaborated on by Becker et al.(1992), is to identify a very general class of formalisms, which they call linear contextfree rewriting systems (CFRSs), and define for this class a large space of structural descriptions which serves as a common ground in which the strong generative capacities of these formalisms can be compared.
Similarly, if we want to talk about squeezing strong generative power out of a formal system, we need to do so in the context of some larger space of structural descriptions.
Second, whyis preservation ofweak generative power important?
If we interpret this constraint to the letter, it is almost vacuous.
For example, the class of all tree adjoining grammars which generate context-free languages includes the grammar shown in Figure 1a (which generates the languagefa;bg ).
We can also add the tree shown in Figure 1b without increasing the grammar’s weak generative capacity; indeed, we can add any trees we please, provided they yield only asandbs.
Intuitively, the constraint of weak context-freeness has little force.
This intuition is verified if we consider that weak context-freeness is desirable for computational e ciency.
Though a weakly context-free TAG might be recognizable in cubic time (if we knowtheequivalent CFG),itneed not beparsable in cubic time—that is, given a string, to compute all its possible structural descriptions will take O(n 6 ) time in general.
If we are interested in computing structural descriptions from strings, then Derivations Structural descriptions Sentences Figure 2: Simulation: structural descriptions as derived structures.
we need a tighter constraint than preservation of weak generative power.
In Section 3 below we examine some restrictions on tree adjoining grammar which are weakly context-free, and observe that their parsers all work in the same way: though given a TAG G, they implicitly parse using a CFG G 0 which derives the same strings as G, but also their corresponding structural descriptions under G,insuch a way that preserves the dynamic-programming structure of the parsing algorithm.
Based on this observation, we replace the constraint of preservation of weak generative power with a constraint of simulability: essentially, a grammar G 0 simulates another grammar G if it generates the same strings that G does, as well as their corresponding structural descriptions under G (see Figure 2).
So then, within the class of context-free rewriting systems, how does this constraint of simulability limit strong generative power?
In Section 4.1 we define a formalism called multicomponent multifoot TAG (MMTAG) which, when restricted to a regular form, characterizes precisely those CFRSs which are simulable by a CFG.
Thus, in the sense we have set forth, this formalism can be said to squeeze as much strong generative power out of CFG as is possible.
Finally, we generalize this result to formalisms beyond CFG.
2 Characterizing
structural descriptions First we define context-free rewriting systems.
What these formalisms have in common is that their derivation sets are all local sets (that is, generable by a CFG).
These derivations are taken as structural descriptions.
The following definitions are adapted from Weir (1988).
Definition 1 A generalized context-free grammar G isatuplehV;S;F;Pi,where 1.
V is a finite set of variables, 2.
S 2V is a distinguished start symbol, 3.
F is a finite set of function symbols, and X Y X NA a X d Y NA b Y c S ! (X;Y) (hx 1 ;x 2 i;hy 1 ;y 2 i)=x 1 y 1 y 2 x 2 X! 1 (X) 1 (hx 1 ;x 2 i)=hax 1 ;x 2 di X!
() ()=h ; i Y ! 2 (Y) 2 (hy 1 ;y 2 i)=hby 1 ;y 2 ci Y ! () ()=h ; i Figure 3: Example of TAG with corresponding GCFG and interpretation.
Here adjunction at foot nodes is allowed.
4. P is a finite set of productions of the form A! f(A 1 ;:::;A n ) where n 0, f 2F,andA;A i 2V.
A generalized CFG G generates a set T(G)of terms, which are interpreted as derivations under some formalism.
In this paper we require that G be free of spurious ambiguity, that is, that each term be uniquely generated.
Definition 2 We say that a formalism F is a context-free rewriting system (CFRS)if its derivation sets can be characterized by generalized CFGs, and its derived structures are produced by a function~ dblbracketright F from terms to strings such that for each function symbol f, there is a yield function f F such that ~f(t 1 ;:::;t n )dblbracketright F = f F (~t 1 dblbracketright F ;:::;~t n dblbracketright F ) (A linear CFRS is subject to further restrictions, which we do not make use of.) As an example, Figure 3 shows a simple TAG with a corresponding GCFG and interpretation.
A nice property of CFRS is that any formalism which can be defined as a CFRS immediately lends itself toseveral extensions, which arise when we give additional interpretations to the function symbols.
For example, we can interpret the functions as ranging over probabilities, creating a stochastic grammar; or we can interpret them as yield functions of another grammar, creating a synchronous grammar.
Now we define strong generative capacity as the relationship between strings and structural descriptions.
1 1 This is similar in spirit, but not the same as, the notion of derivational generative capacity (Becker et al., 1992).
Definition 3 The strong generative capacity of a grammar G aCFRSF is the relation fh~tdblbracketright F ;tijt2T(G)g: For example, the strong generative capacity of the grammar of Figure 3 is fha m b n c n d m ; ( m 1 ( ()); n 2 ( ()))ig whereas any equivalent CFG must have a strong generative capacity of the form fha m b n c n d m ;f m (g n (e()))ig Thatis, ina CFGthe nbsandcs must appear later in the derivation than the m asandds, whereas in our example they appear in parallel.
3 Simulating
structural descriptions We now take a closer look at some examples of “squeezed” context-free formalisms to illustrate how a CFG can be used to simulate formalisms with greater strong generative power than CFG.
3.1 Motivation
Tree substitution grammar (TSG), tree insertion grammar (TIG),and regular-form TAG(RF-TAG) are all weakly context free formalisms which can additionally be parsed in cubic time (with a caveat for RF-TAGbelow).
For each of these formalisms aCKY-styleparser can bewritten whose itemsare of the form [X;i;j] and are combined in various ways, but always according to the schema [X;i;j][Y;j;k] [Z;i;k] just as in the CKY parser for CFG.
In e ect the parser dynamically converts theTSG,TIG,or RFTAG into an equivalent CFG—each parser rule of the above form corresponds to the rule schema Z!XY.
More importantly, given a grammar G and a string w, a parser can reconstruct all possible derivations of w under G by storing inside each chart item how that item was inferred.
If we think of the parser as dynamically converting G into a CFG G 0, then this CFG is likewise able to compositionally reconstruct TSG, TIG, or RF-TAG derivations—we say that G 0 simulates G.
Note that the parser specifies how to convert G into G 0,butG 0 is not itself a parser.
Thus these three formalisms have a special relationship to CFG that is independent of any particular parsing algorithm: for any TSG, TIG, or RF-TAG G, there is a CFGthat simulates G.
We make this notion more precise below.
3.2 Excursus: regular form TAG Strictly speaking, the recognition algorithm Rogers gives cannot be extended to parsing; that is, it generates all possible derived trees for a given string, but not all possible derivations.
It is correct, however, as a parser for a further restricted subclass of TAGs: Definition 4 We say that a TAG is in strict regular form if there exists some partial ordering over the nonterminal alphabet such that for every auxiliary tree, if the root and foot of are labeled X, then for every node along ’s spine where adjunction is allowed, X label( ), and X=label( ) only if is a foot node.
(In this variant adjunction at foot nodes is permitted.) Thus the only kinds of adjunction which can occur to unbounded depth are o -spine adjunction and adjunction at foot nodes.
This stricter definition still has greater strong generative capacity than CFG.
For example, the TAG in Figure 3 is in strict regular form, because the only nodes along spines where adjunction is allowed are foot nodes.
3.3 Simulability
So far we have not placed any restrictions on how these structural descriptions are computed.
Even though we might imagine attaching arbitrary functions to the rules of a parser, an algorithm like CKY is only really capable of computing values of bounded size, or else structuresharing in the chart will be lost, increasing the complexity of the algorithm possibly to exponential complexity.
For a parser to compute arbitrary-sized objects, such as the derivations themselves, it must use back-pointers, references to the values of subcomputations but not the values themselves.
The only functions on a back-pointer the parser can compute online are the identity function (by copying the back-pointer) and constant functions (by replacing the back-pointer); any other function would have to dereference the back-pointer and destroy the structure of the algorithm.
Therefore such functions must be computed o ine.
Definition 5 A simulating interpretation ~ dblbracketrightis a bijection between two recognizable sets of terms such that 1.
For each function symbol, there is a function ¯ such that ~ (t 1 ;:::;t n )dblbracketright= ¯ (~t 1 dblbracketright;:::;~t n dblbracketright) 2.
Each ¯ is definable as: ¯ (hx 11 ;:::;x 1m 1 ) i);:::;hx n1 ;:::;x mn m i)= hw 1 ;:::;w m i where each w i can take one of the following forms: (a) a variable x ij,or (b) a function application f(x i 1 j 1 ;:::x i n j n ), n 0 3.
Furthermore, we require that for any recognizable set T,~Tdblbracketrightis also a recognizable set.
We say that~ dblbracketrightis trivial if every ¯ is definable as ¯ (x 1 ;:::x n )= f(x (1) ;:::x (n) ) where is a permutation off1;:::;ng.
2 The
rationale for requirement (3) is that it should not be possible, simply by imposing local constraints on thesimulating grammar, toproduce a simulated grammar which does not even come from a CFRS.
3 Definition
6 We say that a grammar G from a CFRSF is (trivially) simulable by a grammar G’ from another CFRSF if there is a (trivial) simulating interpretation~ dblbracketright s :T(G 0 )!T(G)which satisfies~tdblbracketright F 0=~~tdblbracketright s dblbracketright F for all t2T(G 0 ).
As an example, a CFG which simulates the TAG of Figure 3 is shown in Figure 4.
Note that if we give additional interpretations to the simulated yield functions, 1,and 2, this CFG can compute any probabilities, translations, etc., that the original TAG can.
Note that if G 0 trivially simulates G,theyare very nearly strongly equivalent, except that the yield functions of G 0 might take their arguments inadi erent order thanG,and there might be several yield functions of G 0 which correspond to a single yield function ofG used in several di erent contexts.
In fact, for technical reasons we will use this notion instead of strong equivalence for testing the strong generative power of a formal system.
Thus the original problem, which was, given a formalism F, to find a formalism that has as much strong generative power as possible but remains weakly equivalent to F, is now recast as 2 Simulating interpretations and trivial simulating interpretations are similar to the generalized and “ungeneralized” syntax-directed translations, respectively, of Aho and Ullman (1969; 1971).
3 Without
this requirement, there are certain pathological cases that cause the construction of Section 4.2 to produce infinite MM-TAGs.
S ! 0 (x 1 ;x 2 ) mapsfromhx 1 ;x 2 i 0 ! 0 h ();x 2 i mapsfromh−;x 2 i 0 ! 1 h−;x 2 i mapsfromh−;x 2 i 1 ! 1 h−; ()i mapsfromh−;−i 1 ! h−;−i mapsfromh−;−i 0 ! 0 1 [ 0 ] h 1 (x 1 );x 2 i mapsfromhx 1 ;x 2 i 0 1 [ 0 ]!a 2 1 [ 0 ]d hx 1 ;x 2 i mapsfromhx 1 ;x 2 i 2 1 [ 0 ]! 0 1 [ 0 ] h 1 (x 1 );x 2 i mapsfromhx 1 ;x 2 i 2 1 [ 0 ]! 0 h ();x 2 i mapsfromh−;x 2 i 1 ! 0 2 [ 1 ] h−; 2 (x 2 )i mapsfromh−;x 2 i 0 2 [ 1 ]!b 2 2 [ 1 ]c h−;x 2 i mapsfromh−;x 2 i 2 2 [ 1 ]! 1 2 [ 1 ] h−; 2 (x 2 )i mapsfromh−;x 2 i 2 2 [ 1 ]! 1 h−; ()i mapsfromh−;−i Figure 4: CFG which simulates the grammar of Figure 3.
Here we leave the yield functions anonymous; y mapsfrom x denotes the function which maps x to y.
the following problem: find a formalism that trivially simulates as many grammars as possible but remains simulable byF.
3.4 Results
The following is easy to show: Proposition 1 Simulability is reflexive and transitive.
Because of transitivity, it is impossible that a formalism which is simulable by F could simulate a grammar that is not simulable byF.Soweare looking for a formalism that can trivially simulate exactly those grammars thatF can.
In Section 4.1 we define a formalism called multicomponent multifoot TAG (MMTAG), and then in Section 4.2 we prove the following result: Proposition 2 A grammar G from a CFRS is simulable by a CFG if and only if it is trivially simulable by an MMTAG in regular form.
The “if” direction (() implies (because simulability is reflexive) that RF-MMTAG is simulable by a CFG, and therefore cubic-time parsable.
(The proof below does give an e ective procedure for constructing a simulating CFG for any RF-MMTAG.)The “only if” direction ())shows that, in the sense we have defined, RF-MMTAG is the most powerful such formalism.
We can generalize this result using the notion of a meta-level grammar (Dras, 1999).
Definition 7 If F 1 and F 2 are two CFRSs,F 2 F 1 is the CFRScharacterized by the interpretation function~ dblbracketright F 2 F 1 =~ dblbracketright F 2 ~ dblbracketright F 1. F 1 is the meta-level formalism, which generates derivations forF 2 . ObviouslyF 1 must be a treerewriting system.
Proposition 3 For any CFRSF 0, a grammar G from a (possibly di erent) CFRS is simulable by a grammar inF 0 if and only if it is trivially simulable by a grammar inF 0 RF-MMTAG.
The “only if” direction ()) follows from the fact that the MMTAG constructed in the proof of Proposition 2 generates the same derived trees as the CFG.
The “if” direction (() is a little trickier because the constructed CFG inserts and relabels nodes.
4 Multicomponent
multifoot TAG 4.1 Definitions MMTAG resembles a cross between set-local multicomponent TAG (Joshi, 1987) and ranked node rewriting grammar (Abe, 1988), a variant of TAG in which auxiliary trees may have multiple foot nodes.
It also has much in common with dtree substitution grammar (Rambow et al., 1995).
Definition 8 An elementary tree set ~ is a finite set of trees (called the components of~ ) with the following properties: 1.
Zero or more frontier nodes are designated foot nodes, which lack labels (following Abe), but are marked with the diacritic ; 2.
Zero or more (non-foot) nodes are designated adjunction nodes, which are partitioned into one or more disjoint sets called adjunction sites.
We notate this by assigning an index i to each adjunction site and marking each node of site i with the diacritic i . 3.
Each component is associated with a symbol called its type.
This is analogous to the left-hand side of a CFG rule (again, following Abe).
4. The components of ~ are connected by dedges from foot nodes to root nodes (notated by dotted lines) to form a single tree structure.
A single foot node may have multiple d-children, and their order issignificant.
(See Figure 5 for an example.) A multicomponent multifoot tree adjoining grammar is a tupleh ;P;Si,where: A X 1 Y 2 X 1 X 1 A X 1 Y 3 X 1 X 1 { A A Y 3 X 1 Y 2 X 1 X 1 Figure 5: Example of MMTAG adjunction.
The types of the components, not shown in the figure, are all X.
1. is a finite alphabet; 2.
P is a finite set of tree sets; and 3.
S 2 is a distinguished start symbol.
Definition 9 A component is adjoinable at a node if is an adjunction node and the type of equals the label of . Theresult ofadjoining acomponent atanode is the tree set formed by separating from its children, replacing with the root of,andreplacing the ith foot node of with the ith child of . (Thus adjunction of a one-foot component is analogous to TAG adjunction, and adjunction of a zero-foot component is analogous to substitution.) A tree set~ is adjoinable at an adjunction site ~ if there is a way to adjoin each component of~ at a di erent node of~ (with no nodes left over) such that the dominance and precedence relations within~ are preserved.
(See Figure 5 for an example.) We now define a regular form for MMTAGthat is analogous to strict regular form for TAG.
A spine is the path from the root to a foot of a single component.
Whenever adjunction takes place, several spines are inserted inside or concatenated with other spines.
To ensure that unbounded insertion does not take place, we impose an ordering on spines, by means of functions i that map the type of a component to the rank of that component’s ith spine.
Definition 10 We say that an adjunction node 2 ~ is safe in a spine if it is the lowest node (except the foot) in that spine, and if each component under that spine consists only of a member of~ and zero or more foot nodes.
We say that an MMTAG G is in regular form if there are functions i from into the domain of some partial ordering such that for each component of type X, for each adjunction node 2,ifthejth child of dominates the ith foot node of (that is, another component’s jth spine would adjoin into the ith spine), then i (X) j (label( )), and i (X) = j (label( )) only if is safe in the ith spine.
Thus the only kinds of adjunction which can occur to unbounded depth are o -spine adjunction and safe adjunction.
The adjunction shown in Figure 5 is an example of safe adjunction.
4.2 Proof
of Proposition 2 (() First we describe how to construct a simulating CFG for any RF-MMTAG; then this direction of the proof follows from the transitivity of simulability.
When a CFG simulates a regular form TAG, each nonterminal must encapsulate a stack (of bounded depth) to keep track of adjunctions.
In the multicomponent case, these stacks must be generalized to trees (again, of bounded size).
So the nonterminals of G 0 are of the form [ ;t], where t is a derivation fragment of G with a dot ( ) at exactly one node~,and is a node of~ .Let ¯ be the node in the derived tree where ends up.
A fragment t can be put into a normal form as follows: 1.
For every~ above the dot, if ¯ does not lie along a spine of~, delete everything above ~ . 2.
For every~ not above or at the dot, if ¯ does not lie along a d-edge of ~, delete ~ and everything below and replace it with >if ¯ dominates~ ; otherwise replace it with?.
3. If there are two nodes ~ 1 and ~ 2 along a path which name the same tree set and ¯ lies along the same spine or same d-edge in both of them, collapse~ 1 and~ 2, deleting everything in between.
Basically this process removes all unboundedly long paths, sothat theset ofnormal formsis finite.
In the rule schemata below, the terms in the lefthand sides range over normalized terms, and their corresponding right-hand sides are renormalized.
Let up(t) denote the tree that results from moving the dot in t up one step.
The value of a subderivation t 0 of G 0 under~ dblbracketright s is a tuple of partial derivations of G, one for each >symbol in the root label of t 0, in order.
Where we do not define a yield function for a production below, the identity function is understood.
For every set ~ with a single, S-type component rooted by, add the rule S ![ ; ~ (>;:::;>)] ~ (x 1 ;:::;x n ) mapsfromhx 1 ;:::;x n i For every non-adjunction, non-foot node with children 1 ;:::; n (n 0), [ ;t]![ 1 ;t] [ n ;t] For every component with root 0 that is adjoinable at, [ ;up(t)]![ 0 ;t] If 0 is the root of the whole set ~ 0, this rule rewrites a > to several > symbols; the corresponding yield function is then h:::;~ 0 (x 1 ;:::;x n );:::i mapsfromh:::;x 1 ;:::;x n ;:::i For every component with ith foot 0 i that is adjoinable at a node with ith child i, [ 0 i ;t]![ i ;up(t)] This last rule skips over deleted parts of the derivation tree, but this is harmless in a regular form MMTAG, because all the skipped adjunctions are safe.
()) First we describe how to decompose any given derivation t 0 of G 0 into a set of elementary tree sets.
Let t=~t 0 dblbracketright s . (Note the convention that primed variables always pertain to the simulating grammar, unprimed variables to the simulated grammar).
If, during the computation of t, a node 0 creates the node, we say that 0 is productive and produces . Without loss of generality, let us assume that there is a one-to-one correspondence between productive nodes and nodes of t.
4 To
start, let be the root of t,and 1 ;:::; n its children.
Define the domain of i as follows: any node in t 0 that produces i or any of its descendants is in the domain of i, and any non-productive node whose parent is in the domain of i is also in the domain of i . For each i, excise each connected component of the domain of i . This operation is the reverse of adjunction (see Figure 6): each component gets 4 If G 0 does not have this property, it can be modified so that it does.
This may change the derived trees slightly, which makes the proof of Proposition 3 trickier.
1 a d { Q 1 : 1 a d Q 1 1 Figure 6: Example derivation (left) of the grammar of Figure 4, and first step of decomposition.
Non-adjunction nodes are shown with the placeholder (because the yield functions in the original grammar were anonymous), the Greek letters indicating what is produced by each node.
Adjunction nodes are shown with labels Q i in place of the (very long) true labels.
S : Q 1 1 Q 2 2 Q 1 : a Q 1 1 d Q 1 : Q 2 : b Q 2 2 c Q 2 : Figure 7: MMTAG converted from CFG of Figure 4 (cf.
the original TAG in Figure 3).
Each components’ type is written to its left.
foot nodes to replace its lost children, and the components are connected by d-edges according to their original configuration.
Meanwhile an adjunction node is created in place of each component.
This node is given a label (which also becomes the type of the excised component) whose job is to make sure the final grammar does not overgenerate; we describe how the label is chosen below.
The adjunction nodes are partitioned such that the ith site contains all the adjunction nodes created when removing i . The tree set that is left behind is the elementary tree set corresponding to (rather, the function symbol that labels ); this process is repeated recursively on the children of,ifany.
Thus any derivation of G 0 can be decomposed into elementary tree sets.
Let ˆ G be the union of the decompositions of all possible derivations of G 0 (see Figure 7 for an example).
Labeling adjunction nodes For any node 0, and any list of nodes h 0 1 ;:::; 0 n i,letthesignature of 0 with respect to h 0 1 ;:::; 0 n i be hA;a 1 ;:::;a m i,whereA is the left-hand side of the GCFG production that generated 0,anda i = hj;ki if 0 gets its ith field from the kth field of 0 j,or if 0 produces a function symbol in its ith field.
So when we excise the domain of i,thelabel of the node left behind by a component is hs;s 1 ;:::;s n i,wheres is the signature of the root of with respect to the foot nodes and s 1 ;:::;s n are the signatures of the foot nodes with respect to their d-children.
Note that the number of possible adjunction labels is finite, though large.
ˆ G trivially simulates G.
Since each tree of ˆ G corresponds to a function symbol (though not necessarily one-to-one), it is easy to write a trivial simulating interpretation~ dblbracketright:T( ˆ G)!T(G).
To see that ˆ G does not overgenerate, observe that the nonterminal labels inside the signatures ensure that every derivation of ˆ G corresponds to a valid derivation ofG 0,and therefore G.Tosee that ~ dblbracketrightis one-to-one, observe that the adjunction labels keep track of how G 0 constructed its simulated derivations, ensuring that for any derivation ˆ t of ˆ G, the decomposition of the derived tree of ˆ t is ˆ t itself.
Therefore two derivations of ˆ G cannot correspond to the same derivation of G 0, nor of G.
ˆ G is finite.
Briefly, suppose that the number of components per tree set is unbounded.
Then it is possible, by intersecting G 0 with a recognizable set, to obtain a grammar whose simulated derivation set is non-recognizable.
The idea is that multicomponent tree sets give rise to dependent paths in the derivation set, so if there is no bound on the number of components in a tree set, neither is there a bound on the length of dependent paths.
This contradicts the requirement that a simulating interpretation map recognizable sets to recognizable sets.
Suppose that the number of nodes per component is unbounded.
If the number of components per tree set is bounded, so must the number of adjunction nodes per component; then it is possible, again by intersecting G 0 with a recognizable set, to obtain a grammar which is infinitely ambiguous with respect to simulated derivations, which contradicts the requirement that simulating interpretations be bijective.
ˆ G is in regular form.
A component of ˆ G corresponds to a derivation fragment of G 0 which takes fields from several subderivations and processes them, combining some into a larger structure and copying some straight through to the root.
Let i (X) be the number of fields that a component of type X copies from its ith foot up to its root.
This information is encoded in X, in the signature of the root.
Then ˆ G satisfies the regular form constraint, because when adjunction inserts one spine into another spine, the the inserted spine must copy at least as many fields as the outer one.
Furthermore, if theadjunction site isnot safe, then the inserted spine must additionally copy the value produced by some lower node.
5 Discussion
We have proposed a more constrained version of Joshi’s question, “How much strong generative power can be squeezed out of a formal system without increasing its weak generative power,” and shown that within these constraints, a variant ofTAGcalled MMTAGcharacterizes thelimit of how much strong generative power can be squeezed out of CFG.
Moreover, using the notion of a meta-level grammar, this result is extended to formalisms beyond CFG.
It remains to be seen whether RF-MMTAG, whether used directly or for specifying meta-level grammars, provides further practical benefits on top of existing “squeezed” grammar formalisms like tree-local MCTAG, tree insertion grammar, or regular form TAG.
This way of approaching Joshi’s question is by no means the only way, but wehope that this work will contribute to a better understanding of the strong generative capacity of constrained grammar formalisms as well as reveal more powerful formalisms for linguistic analysis and natural language processing.
Acknowledgments This research is supported in part by NSF grant SBR-89-20230-15.
Thanks to Mark Dras, William Schuler, Anoop Sarkar, Aravind Joshi, and the anonymous reviewers for their valuable help.
S. D.
G. References Naoki Abe.
1988. Feasible learnability of formal grammars and the theory of natural language acquisition.
In Proceedings of the Twelfth International Conference on Computational Linguistics (COLING-88), pages 1–6, Budapest.
A. V.
Aho and J.
D. Ullman.
1969. Syntax directed translations and the pushdown assembler.
J. Comp.
Sys. Sci, 3:37–56.
A. V.
Aho and J.
D. Ullman.
1971. Translations on a context free grammar.
Information and Control, 19:439–475.
Tilman Becker, Owen Rambow, and Michael Niv.
1992. The derivational generative power of formal systems, or, Scrambling is beyond LCFRS.
Technical Report IRCS-92-38, Institute for Research in Cognitive Science, University of Pennsylvania.
Noam Chomsky.
1965. Aspects of the Theory of Syntax.
MIT Press, Cambridge, MA.
Mark Dras.
1999. A meta-level grammar: redefining synchronous TAG for translation and paraphrase.
In Proceedings of the 37th Annual Meeting of the Assocation for Computational Linguistics, pages 80–87, College Park, MD.
Aravind K.
Joshi. 1987.
An introduction to tree adjoining grammars.
In Alexis Manaster-Ramer, editor, Mathematics of Language.
John Benjamins, Amsterdam.
Aravind K.
Joshi. 2000.
Relationship between strong and weak generative power of formal systems.
In Proceedings of the Fifth InternationalWorkshop on TAG and Related Formalisms (TAG+5),pages 107– 113.
Philip H.
Miller. 1999.
Strong Generative Capacity: The Semantics of Linguistic Formalism.
Number 103in CSLI lecturenotes.CSLI Publications,Stanford.
Owen Rambow, K.
Vijay-Shanker, and David Weir.
1995. D-tree grammars.
In Proceedings of the 33rd Annual Meeting of the Assocation for Computational Linguistics, pages 151–158, Cambridge, MA.
James Rogers.
1994. Capturing CFLs with tree adjoining grammars.
In Proceedings of the 32nd Annual Meeting of the Assocation for Computational Linguistics, pages 155–162,Las Cruces, NM.
Yves Schabes and Richard C.
Waters. 1993.
Lexicalized context-free grammars.
In Proceedings of the 31st Annual Meeting of the Association for Computational Linguistics, pages 121–129, Columbus, OH.
K. Vijay-Shanker, David Weir, and Aravind Joshi.
1987. Characterizing structural descriptions produced by various grammatical formalisms.
In Proceedingsofthe25thAnnualMeetingoftheAssociation for ComputationalLinguistics, pages 104–111, Stanford, CA.
David J.
Weir. 1988.
Characterizing Mildly ContextSensitiveGrammarFormalisms.
Ph.D.thesis,Univ.
of Pennsylvania .

