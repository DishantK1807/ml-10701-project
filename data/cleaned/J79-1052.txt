American Journal of Computational Linguistics A COMPUTATIONAL TREATMENT OF COORDINATE C04JUNCTIONS Linguistic String Proj ect New York University New York 10012 Microfiche 52 Copyright 1976 Associa tion for Com.nutationa1 Linguistics SUMMARY The present paper describes a computational solution to the problem of locating words that are zeroed under conjunction.
In this solution, which is based on general properties 3f conjunctional constructions, a mechanism locates zeroed elements in the conjunction strings and cross-references them dth respect to elements in the head construction.
Constraints can then be applied to elided conjuncts as though they were expanded, and transformational expansion, which reconstructs the complete sentences underlying conjunctional occurrences, can be carried out straightforwardly by following the pointers which have been set up.
The main innovation is called "stacking".
It is a nond.eterministic programming device which causes restrictions (i.., subprograms applying detailed constraints) to be reexecuted on conjoined segments whenever the restriction is inovked on an element which has a conjunct.
CONTENTS...
A COMPUTATIONAL TREATMENT OF COORDINATE CONJUNCTIONS 4 ........ 1 . The definition of conjunction strings 5 ...... 2 . Restrictions under conjunctions; stacking 8 .............. 3 . Less commondeletion forms 17 4 . Implementation .................... 20 References ................... 30 Acknowledgment .................... 31 Appendix The LSP parsing system .......... 32 A COMPUTATIONAL TREATMENT OF COORDINATE CONJUNCTIONS Carol Raze One particularly intricate problem in the computer parsing of natural language texts is the complexity introduced into the parsing system by conjunctions.
This complexity is due to the richness of conjunctional constructions and to the material implicit in sentences containing conjunctions, The computafional problem can be divided into three parts: (I) generating parse trees which cover the occurrences of conjunction-headed strings in sentences; (11) locating words in the sentences which are repeated implicitly in a "zeroed," i.e., elided, form in particular positions in conjunction strings; and (III) reconstructing the complete sentences underlying conjunctional occurrences when the application requires such an expansion.
A generalized algorithmic solution to problem (I) was provided over a decade ago by the New York University Linguistic String Project (LSP) in the framework of linguistic string analysis (Sager e.t al.
1966, Sager 1967, Raze 1967), and similar devices have been described more recently, e.g.,by Woods in the framework of augmented transition networks (Woods 1973).
The present paper describes a compukational solution to problem (II), locating the words that are zeroed under conjunction.
In this solution, which is based on general properties of conjunctional constructions, a mechanism locates zeroed elements in the conjunction strings and cross-references them with respect to elements in the head construction.
Constraints can then be applied to elided conjuncts as though they were expanded, and transformational expansion, which was problem (111) above, can be carried out straightforwardLy by following the pointer's which have been set up.
The main innovation is called "stacking".
It is a nondeterministic programming device which causes restrictions e., subprograms applying detailed constraints) to be re-executed on conjoined segments wheqever the restriction is invoked on an element which has a conjunct.
Since the constraint usually applies to a combination of words in the main string and in the conjunct, the device must ensure that the proper grammatical relation holds between these wards.
That is, it treats these separated words as a single linguistic entity, obtaining the effect of a full expansion of the conjunctional occurrence without carrying out the physical rearrangement and copying or the parse tree.
The strategy of treating ellipsis in two steps (locating deleted elements and later carrying out the physical expansion) is important for a solution to conjunctions far several reasons.
First, it is costly and often fruitless to expand a conjunctional string until one is sure one has a good parse.
Second, to get a good parse one has to execute xestrictions on the generated parse tree.including the conjunction subtrees, and this requires locating deleted eldments.
And third, the decision as to whether conjunctional constructions should be expanded or not is application specific.
This artic-le is divided into four sections: 1.
The ~efinition of conjunction Strings; 2.
Restrictions under Conjunctions; Stacking; 3.
Less Common ~eletion Forms; and 4.
Implementation. An appendix describes the LSP system.
1. THE DEFINITION OF CONJUNCTION STRINGS Constructions containing coordinate conjunctions CONJ have the overall.
form: A CONJ B, where A and B are structuresof the same type in the grammar.
In linguistic string grammar, A and B are particular elements or sequences of elements in defined strings of the grammar.
An element or a sequence of elements in a string occurrence may be conjoined by a conjunctional string which consists of the conjunction followed by another occurrence of the same type of string element (or elements) that precedes the conjunction.
In Hearsay and rumors can ruin careers we have and.rmors (AND + SUBJECT) conjoined Hearsay (SUBJECT) the ASSERTION string, which consists of the elements SUBJECT + TENSE + VERB + OBJECT.
(See Appendix for string definitions).
And in Rumors can ruin careers and can cause much hardship we have and can cause much hardshie (AND + TENSE + VEFU3 + OBJECT) conjoined after Rumors can ruin careers (SUBJECT +'TENSE + VEN + OBJECT).
Computationally, include all the conjunctional combinations large grammar in the grammar definiti6ns would complicate the grammar and make it immense.
Instead, an interrupt mechanism can be used to achieve the same result.* An interrupt occurs when a conjunction is reached while parsing sentence.
When an interrupt occurs, a conjunctional node is atthched to the part of the tree being built.
To illustrate, a simplified tree ofthe type the LSP system would generate for the noun phrase Hearsay and rumors hastily printed is shown in Fig.
1. After Hearsay is matched as a noun, an interrupt occurs, and the special process node ANDSTG is attached to the right of Hearsay.
However, restriction the LSP grammar limits the insertion special cess node to occurring only in LXR type sequences or in strings,' and therefore *The mechanism described here for generating conjunction strings was first programmed by James Morris for the 1966 IPL version of the LSP system (Sager et al.1966), It was expanded in the FAP version of the LSP system, programmed by the author (Raze 1967), and is also part of the current FORTRAN implementation by Ralph Grishman (Grishman 1973): As noted above, the LSP systm is not the only system to employ a dynamic device for generating conjunction parse trees, +An LXR definition consists of three elements: a position for the left adjuncts of X, a core position for the word class XI and a position for the right adjuncts of X.
See Appendix for a definition of the term "string" as used formally in the LSP grammar.
FIGURE 1 Parse tree of noun phrase: Hearsay and rumors hastily printed LNR bN NVAR ANDSTG RN ------I*.
I Hearsay and SA PASSOBJ RV SA rr .I C----.
-L. .-1 DSTG LV *VEN RV rumors printed hastily ANDSTG is rejected in the lowest level.
This restriction avoids various redundancies created by conjoining at intermediate levels and regularizes the points of conjunction in the parse tree.
When insertion fails, the parser detaches the special process node and continues parslng as if no interrupt had occurred.
Another interrupt may occur, however, after the next element in the tree has been satisfied.
Thus for the noun phrase in Fig.
1 an interrupt occurs after NVAR is satisfied and ANDSTG is attached to the right of NVAK.
ANDSTG consists of and followed by the general conjunctional string Q-CONJ.
Q-CONJ contains a restriction which generates a definition for Q-GQNJ.
Its definitLon consists of a set of alternate values: the first value is the element to the left of the inserted node, the second consists of the two elements to the left of the inserted node, etc.
Thus,in Fig.
1 Q-CONJ is NVAR (rumors).
The parser resumes by constructing element RN of LNR.
Here the right adjunct hqstily printed adjoins the conjunction of hearsay and rumors.
Another analysis for the noun phrase hearsay and rumprs hastily printed is shown in Fig.
2. In this case hearsaxhas no right adjunct and Q-CONJ consists of the elements NVAR and RN (rumors hastily printed).
The difference in these two trees shows the ambiguitv.in the given sentence.
FIGURE 2 Another parse tree of noun phrase: Hearsay and rumors hastily printed LNR I AND Q-CONJ L--% 1 Hearsay and !WAR TIN ----7 I *N J ' VENPASS 4 rumors ILVSA LVENR * ---.
SA PASSOBJ RV SA t .A _---_I_.la-----..l-A -.
. ] *D printed hastily 2.
RESTRICTIONS UNDER CONJUNZTIONS; STACKING.
A sentence with a conjunction presents a problem for the application of detailed constraints to the parse tree (restrictions), an essential part of the parsing process.
The tree structure will be different from that assumed by the restriction; conjunctional strings will have been inserted and khe conjunctional strings themselves may be truncated versions of defined strings.
To appreciate what this problem means, one must keep in mind that a grammar like that of the LSP for processing English text sentences is very large by comparison with grammars used in most other natural language processing systems, which are directed to particular subsets of English.
The LSP grammar consists of approximately 3500 lines.
The restrictions com~rise by far the largest part of the grammar, and without them, text parsing6is out of the question.
In addition, we have found that roughly one third of all text sentences contain coordinate or comparative conjunctions, many times in complicated interrelation.
It is therefore essential that there be a means for executing restrictions on sentences containing conjunctions.
One solution to this problem is to rewrite all the restrictions so that they test for conjunctions and accommodate truncated segments.
This was done in earlier versions of the LSP parser but that involved a tremendous amount of detail and both increased and complicated the grammar enormously.
As an alternative, in some cases the Sentence can be expanded so that the restrictions operate on corgplete strings.
But in other cases this is not possible because the expansion necessitates the introduction of certain transformations which should be done later.
In the present system we therefore use a general solution whereby restrictions are re-executed automatically for conjunctional occurrences.
Thus, in the analysis shown in Fig.
1 of Hearsay and rumors hastilyprinted the selectional restriction will be executed autgmatically for the sequences hearsay printed and rumors printed.
This is equivalent to expanding the sentence into two assertions, namely, (Someone) printed hearsay and (Someone) printed rumors.
The actual expansion is performed in the transformational phase (if the application requires expansion), which takes place after the surface analysis is obtained.
However, for the correct surface analysis it is crucial that the restrictions operate on expanded or complete strings.
Thus, the conjunction computation performs some of the function of expansion prior to the transformational phase.
To apply restrictions to sentences containing conjunctions, a nondeterministic programming mechanism, which we call the stacking mechanism, was incorporated into the parser.
This mechanism saves the conjoined structure so that the restriction can be re-executed for the conjoined structure.
In principle, the same method can be Japplled to any grammar containing restrictions as long as the structure assigned to the conjunctional occurrence is of the same type as the one assigned to the segment that precedes the conjurlctionAn efficient restriction component of a grammar makes use of routines for pieces of code which are used again and again.
Then the stacking mechanism can be implemented eff-iciently by changing the routines rather than the more numerous restrictions.
In the LSP cage, the routines which were modified are those which locate a basic type of structure in the parse tree, such as the roubinasCQRE, HOST, ELWNT, LEPT-ADJUNCT, etc.* In additi~n to locating structures the modified routines must also test whether or not the structures are conjoinad.
When a restrictibn calls a routine which locates a conjoined structure, that routine in turn calls an operator which saves the conjoined structure(~) along with the place of the routine within the sequence of operations being executed the restriction.
The operator puts this information re-execution stack.
The routine returns to the original structure located and the restriction interpreter executes the rest of the restriction.
At this point the restriction interpreter "looking at" the original s t~uc ture located by the routine.
When a restriction is successful the restriction interpreter uses the information on the re-execution stack to resume execution of that restriction.
The restriction is resumed at the point immediately after the call to the routine so that the routine itself is not called again.
Instead however, the =striction interpreter will "look at" the conjoined structure previously located and sayed by the routine.
For example, when the verb-object selection restriction WSELl is executed on the sentence They printed hearsay and rumors, it calls the CORE routine to obtain the core of the object.
The CORE routine will go to hearsay, locate and stack rumors, and return to hearsay.
WSELl will be successful for printed hearsay.
WSELl will be resumed therefore at the point after the call to the CORE routine and rumors, which was saved *See Appendix for a detailed description of the routines'.
by the CORE routine, will be plugged in as though it was just obtained bv the CORE routine.
WSELl will be successful for printed rumors.
A trace of the execution of WSELl which shows the re-execution of the restriction on the conjunct appears in Fig.
3. Various cases of WSELl with examgles are explained in detail below.
An effect of dynamic generation of conjunctional parse trees is that in addition to locating conjoined values, provision must be made for restrictions to function properly on the non-conjunctional grammar, in new situations due to conjunctions; a routine may be operating in a structure into which conjunctional strings have been inserted, or in a truncated versi~n of a defined string or host-adjuruct sequence.
For example, the LSP RIGHT-ADJUNCT routine is assumed to start at a node X in an LXR type node.
Without conjunctions the RIGHT-ADJUNCT routine goes one node to the right from X to arrive at the right adjunct of X.
In Fig.
2 for the noun phrase rwnors hastily printed, RIGHTADJUNCT, starting at the core position NVAR subsuming rumors, goes one node to the right to arrive at its right adjunct RN (hastily printed).
However, with con j unctions the routine must go right until lands at non-con junct ional node.
Thus, in Fig.
1, for the noun phrase hearsay and rumors hastily printed, RIGHT-ADJUNCT goes from NVAR (hearsay) past the conjunction string (and rumors) to RN.
When RIGHT-ADJUNCT starts in the conjunctional string at NVAR (rumors), RN is not to its right.
To go to RN, the routine locates the corresponding preconjunction element NVAR (hearsay) and goes to RN from there.
To illustrate how the stacking mechanism works we will explain in detail how restriction WSELl is executed for several sentences with conjunctions.
WSELl is housed in the center string ASSERTION:* *WSEL~ is also housed in other strings containing object and verb elements, but for our example we will only consider the stking ASSERTION.
In the statement WSEL~ = IN ASSERTION: IF ALL OF SOBJECT-NOUN, SGOVl3RNING-VERR, $FORBIDDEN-NOUN-LIST ARE: TRUE THEN $NOCOMMON, $OBJECT-NOUN = THE COE X1 OF THE OEUECT X10 IS N OR PRO.
$GOVERNING-VERB = AT X10, COELEMENT VERB X4 EXISTS.
SFORBIDDEN-NOUN-LIST = THE CORE OF X4 HAS ATTRIBUTE N.OTNOBJ X5.
The above restriction statements have the following functions: $OBJECT-NOUN checks that the core of the object position is a noun or pronoun; $GOVERNINGVERB tests that a verb eoelement exists; and SFORBIDDEN-NOUN-LIST checks that the given verb has an attribute NOTNOBJ.* If all these conditions are satisfied the selection check $NOCOMMON is made.
$NOCOMMON = LISTS X1 AND XS HAVE NO COMMON ATTRIBUTE.
If the noun does have a subcategory that is on the subcategory list of NOTNOBJ, then $NOCOMMON fails and that noun is not accepted as the object of the given verb.
Consider the parse tree for the sentence shown in Fig.
4, They spread rumors and they print hearsay.
In $OBJECT-NOUN, in order to go to the core of th~ OBJECT, OBJECT must first be located.
This is accomplished by the routine (The first footnote is continued from p.
8,) $GOVERNING-VERB we can therefore use the routine COELEMENT with argument VERB.
In the actual restriction a more general routine VERB-COELEMENT is used.
This restriction was described in full, without reference to its operation on conjunction sentences, in Sager and Grishman 1975.
*NOTNOW is assigned in the word dictionary to transitive verbs; its attributes for a given verb are those noun subclasses of the grammar which are not appropriate noun objects of the given verb (in scientific writing).
FIGURE 2 Trace olf WSELL STARTAT(0BJECT).
STARTAT both locates OBJECT and calls the stack operator for each conjoined OBJECT.
rhus for the sentence in Fig.
4, STARTAT will go to the first OBJECT (subsuming cumors) and will save the second OBJECT (hearsax)t.
Wheh STARTAT is compLeted the CORE routine is called to locate the core of OBJECT.
In this exmpl'e it locates the noun rumors.
$GOVERNING-VERB goes to VERB, which is a coelement of OBJECT.
It does this by first locating OBJECT (which was saved in register X10 by $OBJECT-NOUN) and by calling the COELEbIENT routine.
Thus in Fig.
4, COELEXENT (WEW) goes from the first OBJECT to its coelement VERB (spread).
It locates all conjuncts of this VERB and determines whether or not to call the stack operator.
VERB (spread) has a conjunct but in this case COELEIlENT(VERB) will not stack the conjoined VERB (print) because this VERB has its own coelement OBJECT.
When COELEMENT returns, the restriction interpreter is looking at the first VERB.
WSELl is successful for spread rumors.
Since there is something on the reexecution stack, the execution of WSELl is resumed, It is resumed in $OBJECTNOUN at the point immediately after the call to STARTAT(OEUECT), However, this time the restriction interpreter is located at the second OBJECT.
The core (hearsay) of the second OEUECT is obtained and the rest of the restriction is executed for the secona time.
In particular, COELEMENT(VERB) goes tcl the second VERB (print) from the second OBJECT and WSELl is successful for print hearsay.
FIGURE 4 Parse tree of They spread rumors and they print hearsay ASSERTION ]SA SUBJECT SA TENSE $8 VERB SA OBJECT ANDSTG RV SA L----l-L -L-$ ----A-.
. -7-I--_I They spread rubrs iYl 8 LAND SA Q-CONJ s SUBJECT SA TENSE SAVERB SA OBJECT L.--.-.
-------A they* print hearsay For the sentence shown in Fig.
5, They may spread but not print the rumors the execution of WSELl is different.
The OBJECT (the rumors) has no ' conjunct but the VERB does.
In this case the COELEMl$NT(VEZ.B) routine goes to the first VERB (spread) from OBJECT and saves the second VERB (pint) or.
the re-execution stack.
WSELl is successful for spread rumors.
Its execution is therefore resumed in $GOVERNING-VERB at the point just after the ~13.
to COELEMENT(VERB), However, this time the restriction interpreter is looking at the second VERB in).
Therefore, the well-formedness of pint rumors is also checked.
FIGURE 5 Parse tree of rhey may spread but not print the rumors.
ASSERTION he^ may spiead th6 rumors BUT NOT A SA Q-CONJ r but not For the sentence shown in Fiyure 6, They heard and printed facts and.
rumors, the execution of WSELl is again different from the previous examples.
OBJECT itself has no conjunct but the core of OBJECT does.
Thus, when CORE is called in SOELECT-NOUN, the CORE routine will locate N (facts) and will place the second N (rumors) on the re-execution stack.
Likewise, the COELEMENT(VERI3) routine will not find a conjunct for the VERB position itself However, the core of the VERB has a conjunct.
When CORE is called in SFORBIDDEN-NOUN-LIST, it will locate tv (heard) and will place the second tv (printed) on the re-execution stack.
This will result in WSELl being executed for all four verb + ohject noun facts, prinked xumows.
sequences: heard facts, heard rumors, FIGURE 6 Parse tree of They heard and printed facts and rumors.
ASSERTION ISA SUBJECT SA TENSE SA VERB SA -1 --M .* t A -9 1 (Lv WAR ANDSTG RV printed OBJECT RV SA -r--.--.--.IcI-----.
I--)L_ -2 ]*tv ;AND SA p;-Cf heard and printed LN NVAR ANDSTG RN ----f . I facts and rumors The following is an example of how the stacking mechanism helps to resolve syntactic ambiguity.
In the sentence He printed rumors and his friend also, there are two possible parses.
In one analysis the object of printes consists of the conjoined nouns rumors and friend.
This analysis ICCU~~ be rejected by WSELl (assuming print to have iTkIb-i\Wi as 3 valiie of :~oT;;o~\T) in the fallowing manner.
When the CORE routine is callctl in SOBJECT-NOUN, the noun rumors is located and the conjoined noun friend is placed on the re-execution stack.
Printed is located by $GOVERNING-VERB, Printed rumors is successful and WSELl is re-executed for printed friend.
However, printed has NHUMAN on its NOTNOBJ list and friend has a noun subcategory NHUMAN.
Thus $NOCOMMON fails and this analysis is rejected.
Another analysis of this sentence contains a second (implicit) occurrence of printed rumors: He printed rumors and his friend also (printed rumors), The conjoined string consists of SUBJECT (his friend) followed by VERB and OFUECT, which both are assigned the values NULLC (Section 3).
3. LESS COMMON DELETION FORMS Some conjunctional strings differ from the usual form of conjunctional occurrences that the deleted elements are not contiguous to the con j unction.
For example, in He printed the facts but his friend did not, the verb and object printed the facts have been deleted in the conjunctional string; the positions of the deleted verb and object in but his friend did not do not immediately f 01 low but, but follow the tense position (did) . 7 This conjunctional occurrence is covered in the ESP grammar by a node called NULLC.
The NULLC is automatically satisfied without subsuming a sentence word if certain conditions are met.
When it occurs in a parse, it represents the fact that a required element of a string-conjunct has been deleted in such a position that the resulting parse tree does not have similar structures on either side of the conjunction.
Thus, in the parse of the preceding sentencefa shown in Fig.
7, the verb and object of the assertion following but both have the value NULLC.
Before a NULLC node is accepted, several "zeroing" restrictions must be satisfied.
The general conditions for acceptance of a NULLC node are that FIGURE 7 Parse tree of He printed the facts but his friend did not.
S A SUBJECT SA TENSE SA VERB SA OBJECT BUTSTG a ------A & -------_-_---A" ..
4 . -^--LZ . . t I I T'---* * ---+ I 1 HE printed the facts 1 21 I5 I SA TENSE SA VERB -.
.& ---L -..--I L 3------.
. SA OBJECT L 1 t I I hi; friend did 1) it be within a conjunctional string; 2) the pre-conjunctional element which corresponds to the deleted element sub9ume some sentence word(s); and 3) that the zeroing pattern be one of a few types known to be acceptable for conjunctional strings with this type of deletion (see examples below).
Thus in the example sentence shown in Fig.
7, the verb of the assertion following but will have the value NULLC, and conditions 1-3 are met as fo1lows.i 1) NULLC is in a conjunctional string--the string headed by but.
2) The corresponding pre-conjunctional verb subsum~s printed.
3) The NULLC verb is not contiquous to the conjunction but, but follows the tehse in the conjunctional string, this construction being one of the allowed patterns of zeroing.
In addition to establishing conditions for accepting NULLC nodes, the "zeroing1' restrictions have another very important function.
They locate the material that would have been repeated in the conjoined phrase but which was "zeroed," that is, deleted or elided, and they save that information.
When the appropriate structure is located for a WLLC node, the location is saved via a node-attribute mechanism.
The restriction assigns to the NULLC node the node attribute LINKC, whose value points to the pre-conjunctional structure that would have been repeated.
Once the LINKC attribute is assigned, any constraint can locate this structure and Ehus identify the words that have been deleted.
In the LSP system the actual physical rearrangement of the parse tree is not dane until the transformational phase.
However, the actual "filling in" transformation is simple and straightforward because the main bulk of the work (locating the material identical to what is zeroed) is done by the restrictions in the parsing phase.
For conjunction strings with the NULLC type of deletion, restrictions can be executed only after the filling in of deleted elements has been done.
Some sxamples of the NULLC deletion types which are covered by the LSP grammar appear in parentheses in the following sentences: He printed facts but his friend did not (print facts).
He washed the dishes but she did not want to (wash the dishes).
He should have tried to wash the dishes but he did not (try to wash the dishes)".
He ate supper and she (ate supper) too.
He played the played the piano and she (played) the drums.
He left and (he left) fast.
He tried 'to wash the dishes but she was not willing to (try to wash the dishes) . * *This sentence contains an ambiguity as to how much material was deleted: try to wash the dishes vs.
wash the dishes.
4 . IMPLEMENTATION The basic routines* of the LSP grammar were modified to handle conjunctions.
They were modified to locate the appropriate conjoined structure(s) and call an operator which saves those structure(s).
In addition, the routines were modified to function properly in the non-conjunctional grmar for the new situations which occur when conjunctions are present.
Although these changes involve some of the basic routines only, the restrictions use these routines so often so that the changes have to be as efficient as possible.
Otherwise the execution time of a restriction would be greatly increased, To save much repetitious moving around the tree, pointers are attached to the appropriate nodes of the tree via a node-attribute mechanism which is described in Sager and Grishman 1975.
Each element E2 in a conjunctional string of the form El CONJ E is assigned a node attribute called PRECONJELEM 2 which points to the corresponding element E in the string -3rior to conjunc1 tidn.
Likewise each E is assigned a node attribute called POSTCONJELEM 1 which points the corresponding element E in the 2 post-con junctional string.
The node attribute assignments are done by a well-formedness restriction housed on the conjunctional string.
Once the node attributes are assigned, the routines can quickly obtain (or check for) conjoined values of a node by using its node attribute POSTCONJELEM.
And when a routine is called from inside a truncated string segment, it can quickly move to the corresponding pre-conjunction element by obtaining the node attribute PRECONJELEb1.
From that point the routine can then locate the appropriate elemeat.
For example in Fig, 1, the second NVAR (rumors) has been assigned node attribute PFU3CONJELEM pointing to a NVAR (hearsay).
Using the node attribute PRECONJELEM *See Appendix for a detailed explanation of the basic routines.
of the second NVAR, RIGHT-ADJUNCT goes to the first NVAR and then goes two nodes to the right to RN.
Not all restrictions may be re-executed for sentences containing conjuhctional occurrences.
For example, those restrictions testing number agreement have to be changed to explicitly test for the occurrence of a conjunction.
Therefore, those restrictions must use routines that do not stack.
Each routine that calls the stack operator has a counterpart which does not.
The routines are written so that in each pair, the one which stacks calls on the nonstacking version as a subpart.
We will now go into the details of those routines that were modified for conjunctions.
The explanations here will be concerned with the modifications only.
hst of the basic routines fall into three categories: 1) those which begin at.
X or go down to X.
STARTAT(X), ELEMENT(X), LAST-ELEMENT and NELEMRT* are in this category.
These routines concern only one element of a string or sequence.
2) The routines which go right or left to X.
HOST, RIGHT-ADJUNCT, LEFT-ADJUNCT, NEXT-ELEMENT, PREVIOUS-ELSMENT and COELEMENT(X) are in this category.
These routines involve two elements of a string or Sequence.
3)'The routines which start at or go up to X.
IMMEDIATE(X), STARTAT(X), PRESENT-ELEMENT, IT, PRESENT-STRING, IMMEDIATE-NODE are in this category.
Because the conjunction modification can be generalized depending on which category a routine is in, only several routines are needed to handle various conjunction operations.
The actual modification to many of the routines therefore consists of addins a call to one of the few routines which handle conjunctional operations.
*Core is also in this category; however, this routine needs to perform some extra operations to get to the conjoineu core word.
The routine that handles stacking for routines of category (1) above is called $STACK-TEST : * $STACK-TEST = IF $POSTCONJ THEN $STACK-CONJUNCTS . $POSTCONJ " THE PRESENT-EWmNT HAS NODE ATTRIBUTE POSTCONJELEM.
(GLQEAL) It is assumed that the restriction interpreter is "looking at" X when $STACKTEST is called.
If an element E has a corresponding element E in a con1 2 junctional string E will have the node attribute POSTCONJELEM.
This provides 1 a quick test to determine whether or not a node has a conjunct.
If El does not have the node attribute POSTCONJEEM, $POST60NJ fails and $STACK-TEST is finished; if E has the node attribute POSTCONJELEM, the attribute POSTCONJEEEM 1 has a value, namely E 2' When $POSTCONJ is finished the restriction interpreter will be "looking at" E2.
$STACK-CONJUNCTS = VERIFY ITERATE $STACK-X.
$STACK-X = DO $POSTCONJ; STACK.
$STACK-CONJUNCTS locates all the conjuncts of the node by iterating $STACK-X.
It then returns to the starting node.
$STACK-X goes to each conjunct by first executing $POSTCONJ and then calling STACK, the operator which puts the conjunct on the re-execution stack.
In Fig.
4, starting at the first OBJECT, $STACK-TEST will call STACK for the second OBJECT.
It will return to the first OBJECT, before exiting,as a result of the VERIFY con-mand.
The routines that handle stacking for those routines in category 2 above are called $STACK-FOR-LEFT-TO-X and $STACK-FOR-RGHT-TO-X respectively.
We will only go into the details of $STACK-FOR-&FT-TO-x since $STACK-FOR-RGHT-TO-X is similar.
When $STACK-FOR-LEFT-TO-X is called, the restriction interpreter *In our system $STACK-TEST is actually a global address instead of a routine.
This was done because it is faster to execute an address than a routine.
is assumed to be at X.
It is also assumed that the routine which called $STACK-FOR-LEFT-TO-X started at some node Y, saved Y in register X200 and we& from Y left one or more nodes to arrive Bt X.
For instance, this occurs when the routine COELEMENT(VERB) is called from OEUECT in Fig.
4. $STACK-FOR-LEFT-TO-x = IF SPOSTCONJ THEN VERIFY $STACK-IF-NO-Y-RGHT.
(GLOBAL) If X has a corresponding element in a conjunctional string it will have the node attribute POSTCONJELEM.
If X does not have the node attribute POSTCONJEL!?M, $STACK-FOR-LEFT-TO-X is finished.
If it does have node attribute POSTCONJELEM, $STACK-IF-NO-Y-LEFT is executed to determine whether or not to stack the conjunct (s) : $STACKIF-RO-Y -RGHT = IF $POSTCONJ THlEN EITHER ALL OF $NO-Y-TO-RIGHT, $DO-STACK, $STACK-IF-NO-Y-RGHT OR TRUE.
$NO-Y-TO-RIGHT = NOT ITERATE GO RIGHT UNTIL TEST FOR X200 SUCCEEDS.
$DO-STACK = STACK.
Looking at Fig.
4 assume COELEMENT(VERI3) is called when the restriction interpreter is at OBJECT (rumors).
The COELEMENT routine locates the first VERB (spread).
The premise of $STACK-FOR-LEFT-TO-X is successful because this VERB has a conjunct and $STACK-IF-NO-Y-RGHT is executed.
The premise of $STACK-IF-NO-Y-RGHT is successful: a conjunction is found, in this case the second VERB (print).
The restriction interpreter remains at the second VERB while the rest of the implication is executed.
In this example, there is OBJECT, (hearsay) to the right of the second VW; therefore $NO-Y-TO-RGHT fails.
As a result VERB (print) is not stacked.
In Fig.
5, if COELEMENT (VERB) is called when the restriction interpreter is at OBJECT (the rumors) the VERB (spread) is located.
It has a conjunct, which is stacked.
In this case $NO-Y-TO-RGHT is successful since there is no OBJECT to the right of the second VERB.
SSTACK-IF-NO-Y-RGHT is recursive so that all the cohjoined structures are located and tested.
In the above examples if SPOSTCONJ is true starting at the second VERB then $STACK-IF-NO-Y-RGHT goes to the next corresponding post-canjunctional VERB and determines whether or not to stack it, In Fig.
8, after executing the remise of $STACK-IF-NO-Y-RGWT the restriction interpreter is at the second VERB.
$NO-Y-TO-RIGHT is true and $DO-STACK is executed.
~t will stack the second VERB.
$STACK-XF-NO-Y-RGHT is called recursively and the restriction interpreter is at the third VERB.
Howevex, OBJECT (them) is present; therefore $NO-Y-TO-RIGHT will fail and the third VERB (ignored) will not be stacked.
Routines COELEMENT, YOST, LEFT-ADJUNCT and PREVIOUS-ELEMENT use $STACK-FOR-LEFT-TO-X . Routines COELEMENT, HOST, RIGHT-ADJUNCT and FOLLOWING-ELEMENT use $STACK-FOR-RGHT-TO-XI FIGURE 8 Parse tree of They heard and-did print the rumors but we ignored them.
T ASSERTION SA TENSE SA VERB ANDSTG S A OBJECT BUTSTG IiV SA ------r . *--.r4--.r--A+-.--t-I they . L ----I the ;umorg and r TENSE SA VERB 1 did piint BUTSTG but ISUBJECT SA TENSESA VERB SA OBJECT ignored them The routines in category 2 were also modified to operate properly if they start in a truncated segment of a defined string or host adjunct sequence.
For example, if cOELEMENT(OBJECT) is called from the second VERB in Figure 5, the CQELEMENT routine will not be able to go left or right to OBJECT.
It must first go to the corresponding pre-conjunctional element and then try to go left or right to X from there.
This is accomplished by $TO-PRECONJUNCTION-Y.
$TO-PRECONJUNCTION-Y = EITHER SPRECONJ OR $ASSIGN-PRECONJELEM (GLOBAL ) SPRECONJ = THE PRESENT-ELEMENTHAS NODE ATTRIBUTE PRECONJELEM.
If the starting node has node attribute PRECONJELEM, SPRECONJ will go to the corresponding pre-conjunctional node; othefwise the node attributes PRECONJELEM and POSTCONJELEM have to be assigned.
This is accomplished by $ASSIGN-PRECONJELEM: SZOCATE-CONJNODE = ASCEND TO Q-CONJ; GO UP; STORE IN X100, $ASSIGN-PRE-AND-POST assigns the node attribute PRECONJEmM to the current node.
$ASSIGN-PRE-AND-POST is defined in routine ~~~POST-CONJELEM which will be described later.
8fter the node attribute PRECONJBLEM is assigned, $ASSIGN-PRECONJELEM goas to the correspondihy prc-conjunctional IIQ~G by QXCcuting SPRECONJ.
Ror example in Fig.
5, if CQELEMENT(0BJECT) is called fuon the second VERB, COELtEMENT will call $TO-PRECONJUNCTIONbY to go to the first VERB; then kt: will try to go left or right to locate OBJECT.
Another type of adjbstment is needed for restriction routines in category 3 above.
The problem occurs when a restriction is executed starting at the conjunctiona1 string Q-CONJ.
When the aefinition for Q-CONJ is generated from the elements of a string, the well-formednes~ restrictions housed in the ebernents are transmitted along with the elements.
The restrictions on those elements, therefore, were written with the assumption that the starting point is the string that the restrictions were originally housed in--i.e., two nodes up from (2-CONJ, For example in Fig, 5, all restrictions in ASSERTION assume to start at ASSERTION, Thus, the same restriction, starting at Q-CONJ would fail if, for example, we were to test whether the immediate-node of, the second VERB is ASSERTION.
Therefore, the routinesin category 3 execute $UP-THROUGH-Q initially: $UP-THROUGH-Q = ITERATET $GO-UP-TWICE UNTIL TEST FOR Q-CONJ FAILS.
$GO-UP-TWICE = GO UP; GO UP.
$UP-THROUGH-Q goes to the node which is two nodes up from the top of a nest of Q-CONJts.
Routine PRE-POST-CONJELEM assigns the node attribute PRECOKJELEM to the elements of Q-CONJ, It is assumed that the starting node is the node above Q-CONJ.
To each elemen+ of Q-CONJ that is not on the C-NODE list (ANDSTG, ORSTG, BUTSTG, etc.), it assigns the node attribute PRECOVJELEM.
Likewise the corresponding pre-conjunction elements will.
be assigned the n~de attribute POSTCONJELEM.
ROWLNE PRE-POST-COMJELEM = STORE IN X100; DO EJXMENT(Q-CONJ) ; DO LAST-ELEMENT-; ITERATEVERIFY $ASSIGN-TESTUNTILGOLEFTFAXLS, $ASSIGN-TEST = EITHER TEST FOR C-NODE OR EITHER SPECONJ [COELl-] OR $ASSIGN-PE-AND-POST.
The routine PW-POST-CONJELEM saves the starting point in register X100.
It then uses the nonstacking routines* to go to the last element of Q-CONJ.
The node attribute assignments start from the rightmo~t node of Q-CONJ and proceed left.
$ASSIGN-TEST determines whether or not a node attribute should he assigned to a part.icular node.
An assignment is not necessary if the node is on the C-NODE List or if the assignment was already made for the node.
If an assignment daes not have to be made,$ASSIGN-TEST is finished; if one has to be made $ASSIGN-PW-AND-POST is executed: $ASSIGNPRE-AND-POST = STOm IN XSOO; STORE IN XO; GO TO X100; ITERATE $GO-LEFT UNTIL TEST FOR X500 SUCCEEDS; EITHER ITERATE $POSTCONS' [STARTAT] OR TRUE; DO $ASSIGN-POSTCONJELEM; STORE IN XO; GO TO X500; Do $ASSIGN-PREcONJELEM.
*For each routine that stacks, there is a nonstacking counterpart, The nonstacking routines are used for restrictions where stackingis not desired-such as the number agreement restrictions.
$GO-LEFT = ITERATET SUPCONJ UNTIL GO LEFT SUCCEEDS; STORE XN X100.
SUPCONJ = GO UP; TEST FOR Q-CWJ; GO UP.
$ASSIGN-PRE-AND-POST saves the node to be assigned in registers X5QO and XO.
It then goes to the node saved in XlOO (which is initially the star tiny C-NWE) and locates the corresponding pre-conj~nctional~element by executing $GOLEFT until it finds a node which has the same name as that in register S5OO.
That node is saved in XlOO so that the search starts there for the next node to be assigned.
$ASSIGN-POSTCBNJEmbl and $ASSIGN-PRECONJELEM ass iyn the node attributes.
We will consider the case where the second OBJECT in Fig.
8 is being assigned node attribute PRECONJELEM.
BUTSTG is saved in register X100.
$ASSIGN-PRE-AND-FOST saves the second OBJECT in registers XO arid X500.
It then searches for the corresponding pre-conjunctional element by going left from B~STG.
The first OBJECT is found.
$POSTCONJ fails at the first OBJECT and $ASSIGN-PRE-AND-POST remains there.
Node attribute POSTCONJELEM is assigned to the first OBJECT by $ASSIGN-POSTCONJELEM: $ASSIGN-POSTCONJELEM = ASSIGN THE PRESENT ELEbIENT NODE ATTRIBUTE POSTCONJELEM.
$ASSIGN-PRECoNJELI2M = AS$ZGN THE PRESENT ELEMENT NODE ATTRIBUTE PRECONJELEM . When node attribute POSTCONJELEM is assigned, if there is a node saved in registerX0, thatnodewill automaticallybe assignedasthe valueof attribute POSTCONJELEMbythenode attribute assignment operator.
In this case the second OBJECT is in register XO.
Therefore the first OBJECT is assigned node attribute POSTCONJELEM with the second OBJECT as its value.
After a node attribute assignment is made, register XO is automatically cleared by the program.
This prevents accidental value assignments from occurring in case the grammar writer forgets to clear the register.
In the above example, after node attribute POSTCONJELEM is assigned to the first OBJECT, the first OBJECT is saved in register XO by $ASSIGN-PIG-AND-POST and the sebond OBJECT saved in XSOO is assigned the node attribute PIJECONJELIEM with the first OBJECT as its value.
Sometimes a routine starts in a nest of Q-CON3 nodes; the corrcsl~ondinq pre-co~i~inctional element is not necessarily locatecj on the next hiql~etr level.
In Fig.
9 when the second LN (a -few) is beinq assicjnrd node attlribut6 PFECONJEI,EM, Pra-POST-CONJELEM has to (70 ul) ttm Q-CCjN,T Ieve~l:; tt3 f i~ld the corresponding LN.
In SGO-LEFT, if the ca1-1-esp1ontIi nq node is not on thc level being searched, SUPCONJ is executed to locate the next level.
In Chc" above example, when $GO-LEFT cannot go left f ronl the second NVAR (women ), -$UP-CONJ goes up to the next higher Q-CONJ and then goes up to the next CNODE where the search for a corresponding node resumes.
Thus LN (a few) is assigned node attribute PRECONJELEM with LN (all the) as its value.
FIGURE 9 Parse tree of All the men and women and a few children were hurt.
-.
ASSERTION SUBJECT SA TENSE SA VERB SA OBJECT RV SA -r----------were hurt I ILN NVAR ANDSTG RN I -r1 All the hen [AND SA Q-CONJ and 1NVAR ANDSTG +--1 women AND SA Q-CONJ I..
-T and NVAR 7 a few children In Fig.
8, when the third verb (ignored) is being assigned node attributes by $ASSIGN-PRE-AND-POST, the restriction interpreter goes left from BUTSTG and arrives at the first VERB.
The node attributes are chained.
Therefore, node attribute POSTCONJEmM of the first VERB sHould have the second VERB as its value and node attribute POSTCONJELm of the second verb should have the third VERB as its value.
$ASSIGN-PRE-AND-POST gets the last node of the chain after it arrives at the first VERB.
This is done by the section of code . . . EITHER ITERATE $POSTCONJ [STARTAT] OR TRUE; . . ., In this case VERB (ignored) is assigned node attribute PRGCON3ELE.M with value VERB (print).
References 1.
Fitzpatrick, E.
and N.
Sager, The Lexical Subclasses of the Linguistic St-ring Parser, American Journal of Computational Linguistics; microfiche 2, 1974, 2.
Grishman, R., The Implementation of the Stxing Parser of English.
In Natural Language Processinq, R.
ust tin, ed., Algorithmics Press, New York, 1973.
3. Grishman, R*, N.
Sager, C.
Raze, and B.
Bookchin, The Linguistic String Parser.
Proceedings of the 1973 National Computer Conference, 427-434, AFIPS Press, 1973.
4. Harris, Z.S., String Analysis of Sentence Structure, Mouton & Co., The Hague, 1962.
5. Raze, C., The FAP Program for String Decomposition of Scientific Texts.
String Program Reports (S.P.R,) No.
2, Linguistic String Project, New York University, 1967.
6. Sager, N., Syntactic Analysis of Natural Language.
Advances in Computers, vol.
8, 153-158, Academic Press, Inc,, New York, 1967.
7. Sager, N., A Computer String Grammar of English, S.P.R.
No. 4, Linguistic String Project, New York University, 1968.
8. Sager, N., A Computer Grammar of English and Its Applications, to be published by Gordon & Breach in the series Mathematics and Its Applications.
Revised from SPR 4 (L968).
9. Sager, N., The String Parser for Scientific Literature, In Natural Language Processing, R.
Rustin, ed., Algorithmics Press, New York, 1973.
10. Sager, N.
and Ralph Grishman, The Restriction Language for Computer Grammars of NatuYal Language.
Communi,c~tions of the ACM, 18, 390-4Q0, 1975.
11. Sager, N., Salkoff, M., Morris, J., and Raze, C., Report on the String Analysis Programs, Introductory Volume.
String Program Reports No.
1, Linguistic String Project, New York University and University of Pennsylvania, March 1966.
12. Woods, Wm., in Natural Languaqe Processing, R.
Rustin, ed., ~lgorithmics Press, New York, 1973 .

