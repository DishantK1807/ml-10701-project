Restrictions on Monadic Context-Free Tree Grammars Akio Fujiyoshi Department of Computer and Information Sciences, Ibaraki University 4-12-1 Nakanarusawa, Hitachi, Ibaraki, 316-8511, Japan fujiyoshi@cis.ibaraki.ac.jp Abstract In this paper, subclasses of monadic contextfree tree grammars (CFTGs) are compared.
Since linear, nondeleting, monadic CFTGs generate the same class of string languages as tree adjoining grammars (TAGs), it is examined whether the restrictions of linearity and nondeletion on monadic CFTGs are necessary to generate the same class of languages.
Epsilonfreeness on linear, nondeleting, monadic CFTG is also examined.
1 Introduction
The context-free tree grammars (CFTGs) were introduced by W.
C. Rounds (1970) as tree generating systems, the definition of which is a direct generalization of context-free grammars (CFGs) from strings to rooted, ordered, labeled trees.
For the application of CFTGs to natural languages, many kinds of restrictions on CFTGs have been considered because the string languages generated by CFTGs are exactly indexed languages, whose emptiness problem and uniform membership problem are exponential time complete, i.e., nonrestricted CFTGs are formidable.
One approach to define subclasses of CFTGs is to restrict the ranks of nonterminals.
The rank of a nonterminal is a natural number assigned to each nonterminal by which the number of children of the node labeled by the nonterminal is fixed.
Through this approach, the simplest model of CFTGs is regular tree grammars (RTGs) (Brainerd, 1969), where the ranks of nonterminals are all 0.
The string languages generated by RTGs are the languages generated by contextfree grammars (CFGs).
Since recent research on natural languages has suggested that formalisms for natural languages need to generate a slightly larger class of languages than CFGs, this paper focuses on monadic CFTGs, where the ranks of nonterminals are either 0 or 1.
Another formalism of tree generating systems is tree adjoining grammars (TAGs) (Joshi et al., 1975; Joshi and Schabes, 1996; Abeill´e and Rambow, 2000).
TAGs have been widely studied relating them to natural languages, and it was shown that TAGs have the same generative power of string languages as other formalisms for natural languages developed independently such as head grammars, combinatory categorial grammars and linear indexed grammars (Vijay-Shanker and Weir, 1994).
It is also noteworthy that there are recognition algorithms for the string languages generated by TAGs that run in O(n6) and O(M(n2)) time (Rajasekaran, 1996; Rajasekaran and Yooseph, 1998).
From the view point of CFTG, the languages generated by TAGs were examined (Fujiyoshi and Kasai, 2000; Fujiyoshi, 2004; M¨oennich, 1997), and it was shown that linear, nondeleting, monadic CFTGs generate the same class of string languages as TAGs and a strictly larger class of tree languages than TAGs.
Linearity is a restriction on CFTGs that requires the number of occurrences of every variable in the right-hand side of a rule be no more than 1, and nondeletion requires all variables in the left-hand side of a rule occur at least once in the right-hand side.
In other words, linear, nondeleting, monadic CFTGs are those with nonterminals of rank 0 and 1 only and with exactly one occurrence of a variable in every right-hand side of a rule for a nonterminal of rank 1.
In this paper, the subclasses of monadic CFTGs are compared to examine whether the restrictions of linearity and nondeletion on monadic CFTGs are necessary to generate the same class of string languages as TAGs.
It is shown that nondeletion is unnecessary since for any linear, monadic CFTG, there exists an equivalent linear, nondeleting, monadic CFTG.
On the other hand, it is shown that linearity is necessary since there exists a non-linear, monadic CFTG which is not weakly equivalent to any linear, monadic CFTG.
For the development of parsing algorithm, the property of epsilon-freeness is very important, and in this paper, epsilon-freeness on linear, monadic CTFGs is also considered.
Epsilon-freeness is a restriction on grammars that requires no use of epsilon-rules, that is, rules defined with the empty string.
It is shown that for any linear, monadic CFTG, there exists an epsilon-free, linear, nondeleting, monadic CFTG that generate the same string language.
2 Preliminaries
In this section, some terms, definitions and former results which will be used in the rest of this paper are introduced.
2.1 Ranked
Alphabets, Trees and Substitution A ranked alphabet is a finite set of symbols in which each symbol is associated with a natural number, called the rank of a symbol.
Let be a ranked alphabet.
For n 0, it is defined that n = fa 2 j the rank of a is ng.
The set T (trees over ) is the smallest set of strings over, parentheses and commas such that (1) 0 T and (2) if 1; 2;::: ; n 2 T and a 2 n for some n 1, then a( 1; 2;::: ; n) 2 T. Let be the empty string.
Let " be the special symbol that may be contained in 0.
The yield of a tree is a function from T into defined as follows.
For 2 T, (1) if = a 2 ( 0 f"g), yield( ) = a, (1’) if = ", yield( ) =, and (2) if = a( 1; 2;::: ; n) for some a 2 n and 1; 2;::: ; n 2 T, yield( ) = yield( 1) yield( 2) yield( n).
Let X be the fixed countable set of variables x1;x2;:::.
It is defined that X0 = ; and for n 1, Xn = fx1;x2;::: ;xng.
x1 is situationally denoted by x.
T (Xn) is defined to be T [Xn taking the ranks of elements in X are all 0.
For 2 T (Xn) and 1; 2;::: ; n 2 T (X), [ 1; 2;::: ; n] is defined to be the result of substituting each i (1 i n) for the occurences of the variable xi in . A tree 2 T (Xn) is linear if no variable occurs more than once in, and nondeleting if all variables in Xn occur at least once in . The set of all linear trees and all nondeleting trees in T (Xn) are denoted by T (dXne) and T (bXnc), respectively.
In this papaer, the conventional way of illustrating trees is used.
See Figure 1.
The tree A(b(a);a;B(E;d)) is illustrated as (1).
An arbitrary tree 2 T is illustrated as (2).
When the variables of a tree 2 T (X3) occur in the order of x1;x2;x3;x1, the tree is illustrated as (3).
2.2 Context-Free Tree Grammars The context-free tree grammars (CFTGs) were introduced by W.
C. Rounds (1970) as tree generating systems.
The definition of CFTGs is a direct generalization of context-free grammars (CFGs).
$ E D % (D G α β x1 x2 x3 x1 (1) (2) (3) Figure 1: Trees A context-free tree grammar (CFTG) is a fourtuple G = (N; ;P;S), where: N and are disjoint ranked alphabets of nonterminals and terminals, respectively.
P is a finite set of rules of the form A(x1;x2;::: ;xn) ! with n 0, A 2 Nn and 2 TN[ (Xn).
For A 2 N0, rules are written as A ! instead of A() ! . S, the initial nonterminal, is a distinguished symbol in N0.
For a CFTG G, the one-step derivation G) is the relation on TN[ TN[ such that for a tree 2 TN[, if = 0[A( 1; 2;::: ; n)] for some 0 2 TN[ (dX1e) \ TN[ (bX1c), A 2 Nn and 1; 2;::: ; n 2 TN[, and A(x1;x2;::: ;xn) ! is in P, then G) 0[ [ 1; 2;::: ; n]].
Figure 2 is an example of a one-step derivation where the rule A(x) ! is applied to the tree = 0[A( 00)] and the tree 0[ [ 00]] is obtained.
An (n-step) derivation is a finite sequence of trees 0; 1;::: ; n 2 TN[ such that n 0 and 0 G) 1 G) G) n.
When there exists a derivation 0; 1;::: ; n, it is writen that 0 Gn) n or 0 G ) n.
The tree language generated by G is the set L(G) = f 2 T j S G ) g.
The string language generated by G is LS(G) = fyield( ) j 2 L(G)g.
Note that LS(G) ( 0 f"g) . α• $ α•• α• α•• α•• β β x x $ * x Figure 2: One-step derivation Let G and G0 be CFTGs.
G and G0 are equivalent if L(G) = L(G0).
G and G0 are weakly equivalent if LS(G) = LS(G0).
2.3 Restrictions
on CFTGs A CFTG G = (N; ;P;S) is monadic if the rank of any nonterminal is 0 or 1, i.e., N = N0 [ N1 and Nn = ; for n 2.
G is linear if for any rule A(x1;x2;::: ;xn) ! in P, 2 TN[ (dXne), and nondeleting if for any rule A(x1;x2;::: ;xn) ! in P, 2 TN[ (bXnc).
A CFTG G = (N; ;P;S) is epsilon-free if for any rule A(x1;x2;::: ;xn) ! in P, the symbol " doesn’t occur in . When G is monadic, all rules are either of the form A(x) ! with A 2 N1 and 2 TN[ (X1) or of the form B ! with B 2 N0 and 2 TN[ . When G is monadic, linear and nondeleting, for any rule A(x) ! with A 2 N1 in P, there exists exactly one occurrence of x in . For linear, nondeleting, monadic CFTGs, the following results are known.
Theorem 2.1 (Fujiyoshi and Kasai, 2000) The class of string languages generated by linear, nondeleting, monadic CFTGs coincides with the class of string languages generated by TAGs.
Theorem 2.2 (Fujiyoshi and Kasai, 2000) For any linear, nondeleting, monadic CFTG, there exists a weakly equivalent linear, nondeleting, monadic CFTG G = (N; ;P;S) that satisfies the following conditions: For any a 2, the rank of a is either 0 or 2.
For each A 2 N0, if A ! is in P, then either = a with a 2 0, or = B(C) with B 2 N1 and C 2 N0.
See (1) and (2) in Figure 3.
$ D $ % & $ x $ x % & x $ x E x & E x& (1) (2) (3) (4) (5) Figure 3: Strong normal form For each A 2 N1, if A(x) ! is in P, then is one of the following forms: = B(C(x)) with B;C 2 N1, = b(C;x) with b 2 2 and C 2 N0, or = b(x;C) with b 2 2 and C 2 N0.
See (3),(4) and (5) in Figure 3.
If a linear, nondeleting, monadic CFTG satisfies the condition of Theorem 2.2, it is said that the grammar is in strong normal form1.
3 Linearity
and Nondeletion on Monadic CFTGs Because linear, nondeleting, monadic CFTGs generate the same class of string languages as TAGs, the question is whether the restrictions of linearity and nondeletion on monadic CFTGs are necessary to generate the same class of languages.
First, it will be shown that nondeletion is unnecessary.
Theorem 3.1 For any linear, monadic CFTG G, there exists an equivalent linear, nondeleting, monadic CFTG G0.
Proof. Let G = (N; ;P;S) be a linear, monadic CFTG.
An equivalent linear, nondeleting, monadic CFTG G0 = (N0; ;P0;S) can be constructed as follows.
The set of nonterminal is N0 = N00 [ N01 such that N00 = N0 [ fAjA 2 N1g and N01 = N1.
For the preparation of the definition of P 0, for 2 TN[ (X1) we define ( ) TN0[ (X1) as the smallest set satisfying the following conditions: 2 ( )D 1We say “strong” because a grammar in this normal form only preserves weak equivalence.
x *• Π δ * β (1) α• α• γ x δ• γ Π *• * β (2) ^ α• γ δ• γΠ *• * β (3) ^ α•• δ•• Figure 4: The three different cases If 2 ( ) and = 0[B( 00)] for some B 2 N1, 0 2 TN0[ (dX1e) \ TN0[ (bX1c) and 00 2 TN0[, then 0[ B ] 2 ( ).
The set of rules is defined as follows.
P0 = fA ! ^ j A 2 N0, A ! 2 P, ^ 2 ( )g [ fA(x) ! ^ j A 2 N1, A(x) ! 2 P, ^ 2 ( ) \ TN0[ (bX1c)g [ fA ! ^ j A 2 N1, A(x) ! 2 P, ^ 2 ( ) \ TN0[ g Because of the construction of N0 and P0, G0 is monadic and nondeleting.
To show the equivalence of G and G0, we prove the following statement holds for any 2 TN[ and 2 T by induction on the length of derivations: G ) if and only if there exitsts ^ 2 ( ) such that ^ G0 ) . We start with proving “only-if” part.
Let Gk) . If k = 0, then clearly =, 2 ( ) and G0 ) . For k 1, assume that the statement holds for any derivation of length less than k.
If a rule of the form A ! with A 2 N0 is used at the first step, the proof is rather simple, so we only prove the other case.
Suppose that a rule A(x) ! with A 2 N1 is used at the first step and = 0[A( 00)] G) 0[ [ 00]] G ) for some 0 2 TN[ (dX1e) \ TN[ (bX1c) and 00 2 TN[ . By the induction hypothesis, there exist 2 ( 0[ [ 00]]) such that G0 ) . Here, we have to think of the three different cases: (1) 2 ( 0), (2) can be written as 0[^ ] for some 0 2 ( 0) and ^ 2 ( ), and (3) can be written as 0[^ [ 00]] for some 0 2 ( 0), ^ 2 ( ) and 00 2 ( 00).
See Figure 4.
In the case (1), 2 ( ) and G0 ) . In the case (2), A ! ^ is in P 0 and therefore, 0[ A ] 2 ( ) and 0[ A ] G0) 0[^ ] G0 ) . And in the case (3), A(x) ! ^ is in P 0 and therefore, 0[A( 00)] 2 ( ) and 0[A( 00)] G0) 0[^ [ 00]] G0 ) . The “if” part is proved as follows.
Let ^ G0k) for some ^ 2 ( ).
If k = 0, then clearly ^ =, = ^ and G ) . For k 1, assume that the statement holds for any derivation of length less than k.
The rule used at the first step is one of the following forms: (1) A ! ^ with A 2 N0, (2) A(x) ! ^ with A 2 N1, or (3) A ! ^ with A 2 N00 N0.
The proof of the case (1) is similar to the proofs of the other cases, so we start proving the case (2).
In the case (2), ^ = ^ 0[A(^ 00)] G0) ^ 0[^ [ ^ 00]] G0 ) for some ^ 0 2 TN0[ (dX1e)\TN0[ (bX1c) and ^ 00 2 TN0[ . By the definition of P0, A(x) ! is in P such that ^ 2 ( ).
By the induction hypothesis, for any 2 TN[ such that ^ 0[^ [^ 00]] 2 ( ), G ) . By the definition of, there exists 0 2 TN[ (X1) and 00 2 TN[ such that = 0[A( 00)] G) 0[ [ 00]], and ^ 0[^ [^ 00]] 2 ( 0[ [ 00]]).
Therefore, G ) . And in the case (3), ^ = ^ 0[ A ] G0) ^ 0[^ ] G0 ) for some ^ 0 2 TN0[ (dX1e) \ TN0[ (bX1c).
By the definition of P0, A(x) ! is in P such that ^ 2 ( ).
By the induction hypothesis, for any 2 TN[ such that ^ 0[^ ] 2 ( ), G ) . By the definition of, there exists 0 2 TN[ (X1) and 00 2 TN[ such that = 0[A( 00)] G) 0[ [ 00]], and ^ 0[^ ] 2 ( 0[ [ 00]]).
Therefore, G ) . Because (S) = fSg, L(G) = L(G0).
Next, consideration will be given to whether the restriction of linearity can be removed from monadic CFTGs to generate the same class of languages.
The answer is negative.
The following example is a non-linear, monadic CFTG that generates a string language that no linear, monadic CFTG can generate.
Example 3.2 The following is an example of a monadic CFTG that generates the string language Lw4 = fwwww j w 2 fa;bg+g.
G = (N; ;P;S) where N = fS;Ag, the ranks of S and A are 0 and 1, respectively, = fa;b;c;dg, the ranks of a, b, c and d are 0, 0, 2 and 4, respectively, and P consists of the following rules: S ! A(a), S ! A(b), A(x) ! d(xxxx), A(x) ! A(c(xa)), and A(x) ! A(c(xb)).
Because G has the rule A(x) ! d(xxxx), G is not linear.
Theorem 3.3 There exists a monadic CFTG which is not weakly equivalent to any linear, monadic CFTG.
Proof. It is known that the string language Lw4 in Example 3.2 cannot be generated by any TAG.
It cannot be generated by any linear, monadic CFTG, neither.
4 Epsilon-Freeness on Linear, Monadic CFTGs According to our definition of CFTGs, they are allowed to generate trees with the special symbol ", which is treated as the empty string while taking the yields of trees.
In this section, it will be seen that for any linear, monadic CFTG, there exists a weakly equivalent epsilon-free, linear, nondeleting, monadic CFTG.
Because any epsilon-free CFTG cannot generate a tree with ", it is clear that for a CFTG with epsilon-rules, there generally doesn’t exist an equivalent epsilon-free CFTG.
Theorem 4.1 For any linear, monadic CFTG G = (N; ;P;S), if 62 LS(G), then there exists a weakly equivalent epsilon-free, linear, nondeleting, monadic CFTG G0.
If 2 LS(G), then there exists G0 whose epsilon-rule is only S ! ".
Proof. Since it is enough to show the existence of a weakly equivalent grammar, without loss of generality, we may assume that G is in strong normal form.
We may also assume that the initial nonterminal S doesn’t appear in the right-hand side of any rule in P.
We first construct subsets of nonterminals E0 and E1 as follows.
For initial values, we set E0 = fA 2 N0jA ! " 2 Pg and E1 = ;.
We repeat the following operations to E0 and E1 until no more operations are possible: If A ! B(C) with B 2 E1 and C 2 E0 is in P, then add A 2 N0 to E0.
If A(x) ! b(C;x) with C 2 E0 is in P, then add A 2 N1 to E1.
If A(x) ! b(x;C) with C 2 E0 is in P, then add A 2 N1 to E1.
If A(x) ! B(C(x)) with B;C 2 E1 is in P, then add A 2 N1 to E1.
In the result, E0 satisfies the following.
E0 = fA 2 N0j9 2 T ;A G ) ; yield( ) = g We construct G0 = (N0; 0;P0;S) as follows.
The set of nonterminals is N0 = N00 [ N01 such that N00 = N0 [ fAjA 2 N1g and N01 = N1.
The set of terminal is 0 = [fcg, where c is a new symbol of rank 1.
The set of rules P 0 is the smallest set satisfying following conditions: P0 contains all rules in P except rules of the form A ! ".
If S 2 E0, then S ! " is in P0.
If A ! B(C) is in P and C 2 E0, then A ! B is in P0.
If A(x) ! B(C(x)) is in P, then A ! B(C ) is in P0.
If A(x) ! b(C;x) or A(x) ! b(x;C) is in P and C 2 E0, then A(x) ! c(x) is in P 0.
If A(x) ! b(C;x) or A(x) ! b(x;C) is in P, then A ! c(C) is in P0.
To show LS(G0) = LS(G), we prove the following (i), (ii) and (iii) hold by induction on the length of derivations: (i) For A 2 N0, A G0 ) 0 and 0 2 T if and only if A G ) for some 2 T such that yield( ) = yield( 0) 6= . (ii) For A 2 N1, A(x) G0 ) 0 and 0 2 T (X1) if and only A(x) G ) for some 2 T (X1) such that yield( ) = yield( 0).
(iii) For A 2 N00 N0, A G0 ) 0 and 0 2 T if and only if A(x) G ) for some 2 T (X1) such that yield( ["]) = yield( 0) 6= . We start with “only if” part.
For 0-step derivations, (i), (ii) and (iii) clearly hold since there doesn’t exists 0 2 T nor 0 2 T (X1) for each statement.
We consider the cases for 1-step derivations.
[Proof of (i)] If A G0) 0 and 0 2 T, then 0 = a for some a 2 0 and the rule A ! a in P0 has been used.
Therefore, A ! a is in P and A G)a.
[Proof of (ii)] If A(x) G0) 0 and 0 2 T (X1), then 0 = c(x) and the rule A(x) ! c(x) in P0 has been used.
By the definition of P 0, A(x) ! b(C;x) or A(x) ! b(x;C) is in P for some C 2 E0.
There exists 2 T such that C G ) and yield( ) = . Therefore, A(x) G) b(C;x) G )b( ;x) or A(x) G)b(x;C) G )b(x; ), and yield(b( ;x))= yield(b(x; ))= yield(c(x)).
[Proof of (iii)] There doesn’t exists 0 2 T such that A G0) 0.
For k 2, assume that (i), (ii) and (iii) holds for any derivation of length less than k.
[Proof of (i)] If A G0k) 0, then the rule used at the first step is one of the follwoing form: (1) A ! B(C) or (2) A ! B.
In the case (1), A G0)B(C) G0 ) 0[ 0] = 0 for some 0 2 T (X1) and 0 2 T such that B(x) G0 ) 0 and C G0 ) 0.
By the induction hypothesis of (ii), there exists 2 T (X1) such that B(x) G ) and yield( ) = yield( 0).
By the induction hypothesis of (i), there exists 2 T such that C G ) and yield( ) = yield( 0).
By the definition of P 0, A ! B(C) is in P.
Therefore, A G)B(C) G ) [ ] and yield( [ ]) = yield( 0[ 0]).
In the case (2), A G0)B G0 ) 0.
By the definition of P0, A ! B(C) is in P for some C 2 E0.
There exists 2 T such that C G ) and yield( ) = . By the induction hypothesis of (iii), there exists 2 T (X1) such that B(x) G ) and yield( ["]) = yield( 0).
Therefore, A G)B(C) G ) [ ] and yield( [ ]) = yield( 0).
[Proof of (ii)] If A(x) G0k) 0, then the rule used at the first step is one of the follwoing form: (1) A(x) ! B(C(x)), (2) A(x) ! b(C;x) or (3) A(x) ! b(x;C).
Becasue these rule are in P, the proofs are direct from the induction hypothesis like the proof of the case (1) of (i).
[Proof of (iii)] If A G0k) 0, then the rule used at the first step is one of the follwoing form: (1) A ! B(C) or (2) A ! c(C).
In the case (1), A G0)B(C) G0 ) 0[ 0] = 0 for some 0 2 T (X1) and 0 2 T such that B(x) G0 ) 0 and C G0 ) 0.
By the induction hypothesis of (ii), there exists 2 T (X1) such that B(x) G ) and yield( ) = yield( 0).
By the induction hypothesis of (iii), there exists 2 T (X1) such that C(x) G ) and yield( ["]) = yield( 0).
By the definition of P0, A(x) ! B(C(x)) is in P.
Therefore, A(x) G)B(C(x)) G ) [ ] and yield( [ ["]]) = yield( 0[ 0]).
In the case (2), A G0)c(C) G0 ) c( 0) = 0 for some 0 2 T such that C G0 ) 0.
By the induction hypothesis of (i), there exists 2 T such that C G ) and yield( ) = yield( 0).
By the definition of P0, A(x) ! b(C;x) or A(x) ! b(x;C) is in P.
Without loss of generality, we may assume that A(x) ! b(C;x) is in P.
Therefore, A(x) G)b(C;x) G )b( ;x) and yield(b( ;x)["]) = yield(c( 0)).
The “if” part is similarly proved as follows.
For 0-step derivations, (i), (ii) and (iii) clearly hold since there doesn’t exists 2 T nor 2 T (X1) for each statement.
The cases for 1-step derivations are proved.
[Proof of (i)] If A G) and 2 T, then = a for some a 2 0 and the rule A ! a in P has been used.
Therefore, A ! a is in P 0 and A G0) a.
[Proof of (ii) and (iii)] There doesn’t exists 2 T such that A G) . For k 2, assume that (i), (ii) and (iii) holds for any derivation of length less than k.
[Proof of (i)] If A Gk), then the rule used at the first step must be of the form A ! B(C).
Thus, A G)B(C) G ) [ ] = for some 2 T (X1) and 2 T such that B(x) G ) and C G ) . Here, we have to think of the two cases: (1) yield( ) 6= and (2) yield( ) = . In the case (1), by the induction hypothesis of (ii), there exists 0 2 T (X1) such that B(x) G0 ) 0 and yield( 0) = yield( ), and by the induction hypothesis of (i), there exists 0 2 T such that C G0 ) 0 and yield( 0) = yield( ).
By the definition of P 0, A ! B(C) is in P.
Therefore, A G0)B(C) G ) 0[ 0] and yield( 0[ 0]) = yield( [ ]).
In the case (2), C 2 E0.
Thus, A ! B is in P0.
By the induction hypothesis of (iii), there exists 0 2 T (X1) such that B G ) 0 and yield( 0) = yield( ["]).
Therefore, A G0)B G0 ) 0 and yield( 0) = yield( [ ]).
[Proof of (ii)] If A(x) Gk), then the rule used at the first step is one of the follwoing form: (1) A(x) ! B(C(x)), (2) A(x) ! b(C;x) or (3) A(x) ! b(x;C).
The proof of the case (1) is direct from the induction hypothesis.
In the case (2), A(x) G)b(C;x) G )b( ;x) = for some 2 T such that C G ) . Here, we have to think of the two cases: (a) yield( ) 6= and (b) yield( ) = . (a) If yield( ) 6=, then by the induction hypothesis of (i), there exists 0 2 T such that C G0 ) 0 and yield( 0) = yield( ).
By the definition of P0, A(x) ! b(C;x) is in P0.
Therefore, A(x) G0)b(C;x) G0 )b( 0;x) and yield(b( 0;x)) = yield(b( ;x)).
(b) If yield( ) =, then C 2 E0 and A(x) ! c(x) is in P0.
Therefore, A(x) G0)c(x) and yield(c(x)) = yield(b( ;x)).
The proof of the case (3) is similar to that of the case (2).
[Proof of (iii)] If A(x) Gk), then the rule used at the first step is one of the follwoing form: (1) A(x) ! B(C(x)), (2) A(x) ! b(C;x) or (3) A(x) ! b(x;C).
In the case (1), A(x) G)B(C(x)) G ) [ ] = for some ; 2 T (X1) such that B(x) G ) and C(x) G ) . By the definition of P0, A ! B(C) is in P0.
By the induction hypothesis of (ii), there exists 0 2 T (X1) such that B(x) G0 ) 0 and yield( 0) = yield( ).
By the induction hypothesis of (iii), there exists 0 2 T such that C G0 ) 0 and yield( 0) = yield( ["]).
Therefore, A G0) B(C) G0 ) 0[ 0] and yield( 0[ 0]) = yield( [ ["]]).
In the case (2), A(x) G)b(C;x) G )b( ;x) = for some 2 T such that C G ) and yield( ) 6= . By the definition of P0, A ! c(C) is in P0.
By the induction hypothesis of (i), there exists 0 2 T such that C G0 ) 0 and yield( 0) = yield( ).
Therefore, A G0)c(C) G0 )c( 0) and yield(c( 0)) = yield(b( ;x)["]).
The proof of the case (3) is similar to that of the case (2).
By (i), we have the result LS(G0) = LS(G).
5 Conclusions
In this paper, the desirable features of linear monadic CFTGs have been discovered: the restriction of nondeletion doesn’t affect their generative power of tree languages, and the restriction of epsilon-freeness can be assumed when their generation of string languages is considered.
The key to the proofs of this paper was the simplicity of the definition of linear, monadic CFTGs and their normal form.
Recently, the class of grammars called mildly context-sensitive grammars has been studied very actively, to which TAGs and other well-established formalisms for natural languages belong.
Since it is not difficult to study formal properties of linear, monadic CFTGs, they are helpful tools for the study of mildly context-sensitive grammars.

