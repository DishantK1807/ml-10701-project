Polarity sensitivity and evaluation order in type-logical grammar Chung-chieh Shan Division of Engineering and Applied Sciences Harvard University Cambridge, MA 02138 ccshan@post.harvard.edu Abstract We present a novel, type-logical analysis of polarity sensitivity: how negative polarity items (like any and ever) or positive ones (like some) are licensed or prohibited.
It takes not just scopal relations but also linear order into account, using the programming-language notions of delimited continuations and evaluation order, respectively.
It thus achieves greater empirical coverage than previous proposals.
1 Introduction
Polarity sensitivity (Ladusaw, 1979) has been a popular linguistic phenomenon to analyze in the categorial (Dowty, 1994), lexical-functional (Fry, 1997, 1999), and type-logical (Bernardi, 2002; Bernardi and Moot, 2001) approaches to grammar.
The multitude of these analyses is in part due to the more explicit emphasis that these traditions place on the syntax-semantics interface—be it in the form of Montague-style semantic rules, the CurryHoward isomorphism, or linear logic as glue—and the fact that polarity sensitivity is a phenomenon that spans syntax and semantics.
On one hand, which polarity items are licensed or prohibited in a given linguistic environment depends, by and large, on semantic properties of that environment (Ladusaw, 1979; Krifka, 1995, inter alia).
For example, to a first approximation, negative polarity items can occur only in downward-entailing contexts, such as under the scope of a monotonically decreasing quantifier.
A quantifier q, of type (e → t) → t where e is the type of individuals and t is the type of truth values, is monotonically decreasing just in case (1) ∀s1.∀s2.
parenleftbig∀x. s2(x) ⇒ s1(x)parenrightbig ⇒ q(s1) ⇒ q(s2).
Thus (2a) is acceptable because the scope of nobody is downward-entailing, whereas (2b–c) are unacceptable.
(2) a.
Nobody saw anybody.
b. *Everybody saw anybody.
c. *Alice saw anybody.
On the other hand, a restriction on surface syntactic form, such as that imposed by polarity sensitivity, is by definition a matter of syntax.
Besides, there are syntactic restrictions on the configuration relating the licensor to the licensee.
For example, (2a) above is acceptable— nobody manages to license anybody—but (3) below is not.
As the contrast in (4) further illustrates, the licensor usually needs to precede the licensee.
(3) *Anybody saw nobody.
(4) a.
Nobody’s mother saw anybody’s father.
b. *Anybody’s mother saw nobody’s father.
The syntactic relations allowed between licensor and licensee for polarity sensitivity purposes are similar to those allowed between antecedent and pronoun for variable binding purposes.
To take one example, just as an antecedent’s ability to bind a (c-commanded) pronoun percolates up to a containing phrase (such as in (5), what B¨uring (2001) calls “binding out of DP”), a licensor’s ability to license a (c-commanded) polarity item percolates up to a containing phrase (such as in (4a)).
(5) [Every boyi’s mother] saw hisi father.
Moreover, just as a bindee can precede a binder in a sentence when the bindee sits in a clause that excludes the binder (as in (6); see Williams, 1997, §2.1), a licensee can precede a licensor in a sentence when the licensee sits in a clause that excludes the licensor (as in (7); see Ladusaw, 1979, page 112).
(6) That hei would be arrested for speeding came as a surprise to everyi motorist.
(7) That anybody would be arrested for speeding came as a surprise to the district attorney.
This paper presents a new, type-logical account of polarity sensitivity that encompasses the semantic properties exemplified in (2) and the syntactic properties exemplified in (3–4).
Taking advantage of the Curry-Howard isomorphism, it is the first account of polarity sensitivity in the grammatical frameworks mentioned above to correctly fault (3) for the failure of nobody to appear before AxiomA turnstileleft A For each unary mode α (blank, u, or p in this paper): DiamondαΓ turnstileleft A square↓ αIΓ turnstileleft square↓ αA Γ turnstileleft square↓αA square↓ αEDiamond αΓ turnstileleft A Γ turnstileleft A Diamond αIDiamond αΓ turnstileleft DiamondαA ∆ turnstileleft DiamondαA Γ[DiamondαA] turnstileleft B Diamond αEΓ[∆] turnstileleft B For each binary mode β (blank or c in this paper): Γ turnstileleft B ∆ turnstileleft C ◦ βIΓ◦ β ∆ turnstileleft B◦β C ∆ turnstileleft B◦C Γ[B◦β C] turnstileleft A ◦ βEΓ[∆] turnstileleft A ∆◦β B turnstileleft C / βI∆ turnstileleft C/ βB ∆ turnstileleft B/βA Γ turnstileleft A / βE∆◦ β Γ turnstileleft B B◦β ∆ turnstileleft C \ βI∆ turnstileleft B\ βC Γ turnstileleft A ∆ turnstileleft A\βB \ βEΓ◦ β ∆ turnstileleft B Figure 1: Natural deduction rules for multimodal categorial grammar (Bernardi, 2002, pages 9 and 50).
To reduce notation, we do not distinguish structural punctuation from logical connectives.
A turnstilerightturnstileleft A ◦c 1(Root) (B◦C) ◦c K turnstilerightturnstileleft B◦c (C ◦ K)(Left) (DiamondB◦C) ◦c K turnstilerightturnstileleft C ◦c (K ◦DiamondB)(Right) A turnstileleft DiamondA(T) DiamondA ◦DiamondB turnstileleft Diamond(A ◦ B)(Kprime) DiamondDiamonduA turnstileleft DiamonduA(Unquote) Figure 2: Structural postulates anybody.
The analysis makes further correct predictions, as we will see at the end of §3.
The analysis here borrows the concepts of delimited continuations (Felleisen, 1988; Danvy and Filinski, 1990) and evaluation order from the study of programming languages.
Thus this paper is about computational linguistics, in the sense of applying insights from computer science to linguistics.
The basic idea transfers to other formalisms, but type-logical grammar—more precisely, multimodal categorial grammar—offers a fragment NLDiamondR− whose parsing problem is decidable using proof-net technology (Moot, 2002, §9.2), which is of great help while developing and testing the theory.
2 Delimited
continuations Figure 1 shows natural deduction rules for multimodal categorial grammar, a member of the type-logical family of grammar formalisms (Moortgat, 1996a; Bernardi, 2002).
Figure 2 lists our structural postulates.
These two figures form the logic underlying our account.
We use two binary modes: the default mode (blank) for surface syntactic composition, and the continuation mode c.
As usual, a formula of the form A ◦ B can be read as “A followed by B”.
By contrast, a formula of the form A ◦c B can be read as “A in the context B”.
In programming-language terms, the formula A ◦c B plugs a subexpression A into a delimited continuation B.
The Root rule creates a trivial continuation: it says that 1 is a right identity for the c mode, where 1 can be thought of as a nullary connective, effectively enabling empty antecedents for the c mode.
The binary modes, along with the first three postulates in Figure 2, provide a new way to encode Moortgat’s ternary connective q (1996b) for insitu quantification.
For intuition, it may help to draw logical formulas as binary trees, distinguishing graphically between the two modes.
To further capture the interaction between scope inversion and polarity sensitivity exemplified in (3–4), we use three unary modes: the value mode (blank), the unquotation mode u, and the polarity mode p.
The value mode marks when an expression is devoid of in-situ quantification, or, in programming-language terms, when it is a pure value rather than a computation with control effects.
As a special case, any formula can be turned pure by embedding it under a diamond using the T postulate, analogous to quotation or staging in programming languages.
Quotations can be concatenated using the Kprime postulate.
The unquotation mode u marks when a diamond can be canceled using the Unquote postulate.
Unquotation is also known as eval or run in programming languages.
The polarity mode p, and the empirical utility of these unary modes, are explained in §3.
A derivation is considered complete if it culminates in a sequent whose antecedent is built using the default binary mode ◦ only, and whose conclusion is a type of the form DiamonduA.
Below is a derivation of Alice saw Bob.
(8) Alice turnstileleft np saw turnstileleft (np\Diamondus)/np Bob turnstileleft np /E saw ◦ Bob turnstileleft np\Diamondus \E Alice ◦ (saw ◦ Bob) turnstileleft Diamondus Note that clauses take the typeDiamondus rather than the usual s, so the Unquote rule can operate on clauses.
We abbreviate Diamondus to s◦ below.
To illustrate in-situ quantification, Figure 3 on the following page shows a derivation of Alice saw a man’s mother.
For brevity, we treat a man as a single lexical item.
It is a quantificational noun phrase whose polarity is neutral in a sense that contrasts with other quantifiers considered below.
The crucial part of this derivation is the use of the structural postulates Root, Left, and Right to divide the sentence into two parts: the subexpression a man and its context Alice saw ’s mother.
The type of a man, s◦/c(np\cs◦), can be read as “a subexpression that produces a clause when placed in a context that can enclose an np to make a clause”.
a man turnstileleft s◦/c(np\cs◦) Alice turnstileleft np saw turnstileleft (np\s◦)/np Axiomnp turnstileleft np ’s mother turnstileleft np\np \Enp ◦ ’s mother turnstileleft np /Esaw ◦ (np ◦ ’s mother) turnstileleft np\s◦ \EAlice ◦ (saw ◦ (np ◦ ’s mother)) turnstileleft s◦ DiamondIDiamondparenleftbigAlice ◦ (saw ◦ (np ◦ ’s mother))parenrightbig turnstileleft Diamonds◦ UnquoteDiamondparenleftbigAlice ◦ (saw ◦ (np ◦ ’s mother))parenrightbig turnstileleft s◦ Kprime thriceDiamondAlice ◦ (Diamondsaw ◦ (Diamondnp ◦Diamond’s mother)) turnstileleft s◦ TDiamondAlice ◦ (Diamondsaw ◦ (np ◦Diamond’s mother)) turnstileleft s◦ RootparenleftbigDiamondAlice ◦ (Diamondsaw ◦ (np ◦Diamond’s mother))parenrightbig ◦ c 1 turnstileleft s◦ Rightparenleftbig Diamondsaw ◦ (np ◦Diamond’s mother)parenrightbig ◦c (1 ◦DiamondAlice) turnstileleft s◦ Right (np ◦Diamond’s mother) ◦c parenleftbig(1 ◦DiamondAlice) ◦Diamondsawparenrightbig turnstileleft s◦ Left np ◦c parenleftbigDiamond’s mother ◦ ((1 ◦DiamondAlice) ◦Diamondsaw)parenrightbig turnstileleft s◦ \ cIDiamond’s mother ◦ ((1 ◦DiamondAlice) ◦Diamondsaw) turnstileleft np\ cs◦ / cEa man ◦ parenleftbigDiamond’s mother ◦ ((1 ◦DiamondAlice) ◦Diamondsaw)parenrightbig turnstileleft s◦ Left(a man ◦Diamond’s mother) ◦ c parenleftbig(1 ◦DiamondAlice) ◦Diamondsawparenrightbig turnstileleft s◦ RightparenleftbigDiamondsaw ◦ (a man ◦Diamond’s mother)parenrightbig ◦ c (1 ◦DiamondAlice) turnstileleft s◦ Rightparenleftbig DiamondAlice ◦ (Diamondsaw ◦ (a man ◦Diamond’s mother))parenrightbig ◦c 1 turnstileleft s◦ Root DiamondAlice ◦ (Diamondsaw ◦ (a man ◦Diamond’s mother)) turnstileleft s◦ T thrice Alice ◦ (saw ◦ (a man ◦ ’s mother)) turnstileleft s◦ Figure 3: In-situ quantification: deriving Alice saw a man’s mother Quantifier Type a man s◦/c(np\cs◦) nobody s◦/c(np\cs−) anybody s−/c(np\cs−) somebody s+/c(np\cs+) everybody s◦/c(np\cs+) d71d70d69d68d64d65d66d67s+ ε d31d31d63d63 d63d63d63 d63d63d63 d63d63 somebody d31d31d47d47 d71d70d69d68d64d65d66d67 s− ε d127d127 d127d127 d127d127d127 d127d127d127 d127 anybody d31d31 d79d78d77d76d72d73d74d75d71d70d69d68d64d65d66d67s◦ nobody d78d78 a man d95d95 everybodyd110d110 d47d47 Figure 4: Quantifier type assignments, and a corresponding finitestate machine 3 Polarity sensitivity and evaluation order The pmodemediatespolaritysensitivity.
Foreveryunary mode α, we can derive A turnstileleft square↓αDiamondαA from the rules in Figure 1.
This fact is particularly useful when α = p, because we assign the typesDiamondusquare↓pDiamondps andsquare↓pDiamondpDiamondus to positive and negative clauses, respectively, and can derive s◦ turnstileleft Diamondusquare↓pDiamondps, s◦ turnstileleft square↓pDiamondpDiamondus.(9) In words, a neutral clause can be silently converted into a positive or negative one.
We henceforth write s+ and s− for Diamondusquare↓pDiamondps and square↓pDiamondpDiamondus.
By (9), both types are “subtypes” of s◦ (that is to say, entailed by s◦).
The p mode is used in Figure 5 on the next page to derive Nobody saw anybody.
Unlike a man, the quantifier anybody has the type s−/c(np\cs−), showing that it takes scope over a negative clause to make another negative clause.
Meanwhile, the quantifier nobody has the type s◦/c(np\cs−), showing that it takes scope over a negative clause to make a neutral clause.
Thus nobody can take scope over the negative clause returned by anybody to make a neutral clause, which is complete.
The contrast between (2a) and (3) boils down to the Right (but not Left) postulate’s requirement that the leftmost constituent be of the form DiamondB.
(In programminglanguage terms, a subexpression can be evaluated only if all other subexpressions to its left are pure).
For nobody to take scope over (and license) anybody in (3) requires the context *Anybody saw. In other words, the sequent (10) np ◦c parenleftbig(1 ◦Diamondanybody) ◦Diamondsawparenrightbig turnstileleft s− must be derived, in which the Right rule forces the constituents anybody and saw to be embedded under diamonds.
Figure6showsanattemptatderiving(10), which fails because the type s− for negative clauses cannot be Unquoted (shown with question marks).
The sequent in(10)cannotbederived, andthesentence*Anybodysaw nobody is not admitted.
Nevertheless, Somebody saw everybody is correctly predicted to have ambiguous scope, because neutral and positive clauses can be Unquoted.
The quantifiers a man, nobody, and anybody in Figures 3 and 5 exemplify a general pattern of analysis: every polarity-sensitive item, be it traditionally considered a licensor or a licensee, specifies in its type an input polarity (of the clause it takes scope over) and an output polarity (of the clause it produces).
Figure 4 lists more quantifiers and their input and output polarities.
As shown there, these type assignments can be visualized as a finite-state machine.
The states are the three clause types.
The εtransitions are the two derivability relations in (9).
The non-ε transitions are the quantifiers.
The start states are the clausal types that can be Unquoted.
The final state is the clausal type returned by verbs, namely neutral.
The precise pattern of predictions made by this theory can be stated in two parts.
First, due to the lexical types in Figure 4 and the “subtyping” relations in (9), the quantifiers in a sentence must form a valid transition sequence, from widest to narrowest scope.
This constraint is standard in type-logical accounts of polarity sensitivity.
Second, thanks to the unary modes in the structural nobody turnstileleft s◦/c(np\cs−) anybody turnstileleft s−/c(np\cs−) ·· · Diamondnp ◦ (Diamondsaw ◦ np) turnstileleft s◦ Root,Right,Right np ◦c parenleftbig(1 ◦Diamondnp) ◦Diamondsawparenrightbig turnstileleft s◦ Diamond pIDiamond p parenleftbignp ◦ c ((1 ◦Diamondnp) ◦Diamondsaw) parenrightbig turnstileleft Diamond ps◦ square↓ pInp ◦ c parenleftbig(1 ◦Diamondnp) ◦Diamondsawparenrightbig turnstileleft s− \cI(1 ◦Diamondnp) ◦Diamondsaw turnstileleft np\ cs− / cEanybody ◦ c parenleftbig(1 ◦Diamondnp) ◦Diamondsawparenrightbig turnstileleft s− Right,Right,LeftDiamondnp ◦ c parenleftbig(Diamondsaw ◦ anybody) ◦ 1parenrightbig turnstileleft s− T twicenp ◦ c parenleftbig(saw ◦ anybody) ◦ 1parenrightbig turnstileleft s− \cI(saw ◦ anybody) ◦ 1 turnstileleft np\ cs− / cEnobody ◦ c parenleftbig(saw ◦ anybody) ◦ 1parenrightbig turnstileleft s◦ Left,Rootnobody ◦ (saw ◦ anybody) turnstileleft s◦ Figure 5: Polarity licensing: deriving Nobody saw anybody ·· · anybody ◦ (saw ◦ np) turnstileleft s− DiamondI Diamondparenleftbiganybody ◦ (saw ◦ np)parenrightbig turnstileleft Diamonds−· ·· ???
Diamondparenleftbiganybody ◦ (saw ◦ np)parenrightbig turnstileleft s− Kprime twice Diamondanybody ◦ (Diamondsaw ◦Diamondnp) turnstileleft s− T Diamondanybody ◦ (Diamondsaw ◦ np) turnstileleft s− Rootparenleftbig Diamondanybody ◦ (Diamondsaw ◦ np)parenrightbig ◦c 1 turnstileleft s− Right (Diamondsaw ◦ np) ◦c (1 ◦Diamondanybody) turnstileleft s− Right np ◦c parenleftbig(1 ◦Diamondanybody) ◦Diamondsawparenrightbig turnstileleft s− Figure6: Linearorderinpolaritylicensing: ruling out Anybody saw nobody using left-to-right evaluation order postulates in Figure 2, whenever two quantifiers take inverse rather than linear scope with respect to each other, the transitions must pass through a start state (that is, a clause type that can be Unquoted) in between.
This constraint is an empirical advance over previous accounts, which are oblivious to linear order.
Theinputandoutputpolaritiesofquantifiersarehighly mutually constrained.
Take everybody for example.
If we hold the polarity assignments of the other quantifiers fixed, then the existence of a linear-scope reading for A man introduced everybody to somebody forces everybody to be input-positive and output-neutral.
But then ouraccountpredictsthatNobodyintroducedeverybodyto somebody has a linear-scope reading, unlike the simpler sentenceNobodyintroducedAlicetosomebody.
Thisprediction is borne out, as observed by Kroch (1974, pages 121–122) and discussed by Szabolcsi (2004).
Acknowledgments Thanks to Chris Barker, Raffaella Bernardi, William Ladusaw, Richard Moot, Chris Potts, Stuart Shieber, Dylan Thurston, and three anonymous referees.
This work is supported by the United States National Science Foundation Grant BCS-0236592.
References Raffaella Bernardi and Richard Moot.
2001. Generalized quantifiers in declarative and interrogative sentences.
Journal of Language and Computation, 1(3):1–19.
Raffaella Bernardi.
2002. Reasoning with Polarity in Categorial Type Logic.
Ph.D. thesis, Utrecht Institute of Linguistics (OTS), Utrecht University.
Daniel B¨uring.
2001. A situation semantics for binding out of DP.
In Rachel Hastings, Brendan Jackson, and Zsofia Zvolensky, editors, SALT XI: Semantics and Linguistic Theory, pages 56–75, Ithaca.
Cornell University Press.
Olivier Danvy and Andrzej Filinski.
1990. Abstracting control.
In Proceedings of the 1990 ACM Conference on Lisp and Functional Programming, pages 151–160, New York, March.
ACM Press.
David R.
Dowty. 1994.
The role of negative polarity and concord marking in natural language reasoning.
In Mandy Harvey and Lynn Santelmann, editors, SALT IV: Semantics and Linguistic Theory, Ithaca.
Cornell University Press.
Matthias Felleisen.
1988. The theory and practice of first-class prompts.
In POPL ’88: Conference Record of the Annual ACM Symposium on Principles of Programming Languages, pages 180–190, New York.
ACM Press.
John Fry.
1997. Negative polarity licensing at the syntaxsemantics interface.
In Philip R.
Cohen and Wolfgang Wahlster, editors, Proceedings of the 35th Annual Meeting of the Association for Computational Linguistics and 8th Conference of the European Chapter of the Association for Computational Linguistics, pages 144–150, San Francisco.
Morgan Kaufmann.
John Fry.
1999. Proof nets and negative polarity licensing.
In Mary Dalrymple, editor, Semantics and Syntax in Lexical Functional Grammar: The Resource Logic Approach, chapter 3, pages 91–116.
MIT Press, Cambridge.
Manfred Krifka.
1995. The semantics and pragmatics of polarity items.
Linguistic Analysis, 25:209–257.
Anthony S.
Kroch. 1974.
The Semantics of Scope in English.
Ph.D. thesis, Massachusetts Institute of Technology.
Reprinted by New York: Garland, 1979.
William A.
Ladusaw. 1979.
Polarity Sensitivity as Inherent Scope Relations.
Ph.D. thesis, Department of Linguistics, University of Massachusetts, August.
Reprinted by New York: Garland, 1980.
Michael Moortgat.
1996a. Categorial type logics.
In Johan van Benthem and Alice ter Meulen, editors, Handbook of Logic and Language, chapter 2.
Elsevier Science, Amsterdam.
Michael Moortgat.
1996b. Generalized quantification and discontinuous type constructors.
In Harry C.
Bunt and Arthur van Horck, editors, Discontinuous Constituency, pages 181– 207.
de Gruyter, Berlin.
Richard Moot.
2002. Proof Nets for Linguistic Analysis.
Ph.D. thesis, Utrecht Institute of Linguistics (OTS), Utrecht University.
Anna Szabolcsi.
2004. Positive polarity—negative polarity.
Natural Language and Linguistic Theory, 22(2):409–452, May.
Edwin Williams.
1997. Blocking and anaphora.
Linguistic Inquiry, 28(4):577–628 .

