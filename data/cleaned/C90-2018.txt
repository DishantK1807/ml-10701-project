Feature Logic with Disjunctive Unification dochen Dgrre, Andreas Eisele Institut fiir maschinelle Spraehvera.rbcitung Universit~tt Stuttgart Abstract \Ve introduce lea.tare terms containing sorts, vztriables, negation and named disjunction for the specification of feature structures.
We show that the possibility to label di@mctions with names has m~tjor advantages both for the 'use of feature logic in computationaJ linguistics and its implementation.
We give an open world semantics for feature terms, where the denotation of a term is determined in dependence on the disjunctive conte:rt, i.e. the choices taken for the disjunctions.
We define conte:ct-unique feature description.% a relational, constraint-based rcpresentation language and give a normMization procedure that allows to test consistency of feature terms.
This procedure does not only avoid expansion 1o disjunctive normal fbrm but maintains also structure sharing between information contained in dii:ferent disjuncts as much as possible.
Context-unique feature descriptions can be easily implemented in environments that support ordinary unification (such as I?UOLOG).
1 Introduction
1.
t. Ambiguity in Nat;ural \]\[,anguage Our use of language mirrors our intellectual capacities, which are as yet my no mea.ns understood.
As long as we can not formally de.scribe the processes involved in thinking and understanding, k)rnlM descriptions of human language have to b<: rough approximations.
One pa.rticular instance of this general fact is; the problem of disambiguation of human utterances.
Since our use of words fits our capabilities of itnderstanding l.heir meaning, contex:t and intent, systems that do ilot have such capabilities can, at best, produce sets of possible analyses.
It is well known that such sets can be very la.rge in practice.
Ambiguity in aatnral language is fed by a couple of source.~;, including lexicat ambiguity, where differing analyses are possible for a given word concerning its part of speech, subcat.cgorization for complements, morphological features, or any o!her information assigned to it, and structural ambiguity introduced by different possible groupings or interpretations of phrases or different interrelaIious between them with respect to subcategorizatioil, meaning, pragmMics etc.
On each le.vel, a.
bunch of possibilities exist, which could po-tentially multiply to an enormous space of combinations.
l lowever, these possibilities interact and restrict each other in such a way, that taking it all together only a few (hopcfulJy exactly one)interpretations remain.
1.2 Unification-Based Formalisms For about a decade, many fornral theories of naturM lan-.
guage haw: tried to describe their subject in terms of so called feature structures, i.e. potentially nested bundels of features that are assigned to words and phrases.
These structures are sometimes seen as M)stract linguistic objects, which are described using a suitable description language, sometimes they are given ~ concrete shape in form of finite automatons and regarded themselves as descriptions of the linguistic objects \[Kasper/Ronnds 86\].
Despite such differences in interpretation, there is a consensus among the theories that linguistic descriptions should provide constraints concerning feature structures and that a set.
of such constraints gives a partial description of the feature st, rnctures associated with a phrase.
A set of constraints defines a milli real model, i.e. a rninimM structure satisfying all constrainls in the set.
The union of two sets of constraints sot (ontra..
dieting each other leads to a minimal model which is the least common extension of the models of both sets.
Sn(-h minimal common extensions can be constructed by unification of the given models, hence the term unification-based form alisrns.
There is also a consensus among feature-based ti~eories that ambiguity should be described with disjunctive formulas, and most formalisms offer ways to spe(:it} them.
If disiunc tlon is present, there is usila.l}y a.
tinite ltumber el minimal models instead of only one.
Ilowever, until now, the way such disjunctive specifications have been processed compu taiionally was not quite satisfactory.
An enumeration of the possibilities using a backtracking scheme or a chart, which c.orresponds to an expansion to disjunctive nornlal form in the underlying logic, often leads to computational ineflMency.
Approaches to improve the situa.iion both ill terms of the logic and the inlplementation (see e.g.
\[l(arttuncn 81, Ka.'q~er 87, Eisele/Dgrre 88, Maxwell/Kaplan $9\]) can be subdivided in those assuming di:,junctive value.s tor fealures and lhose allowing \[or more general terms of disjunction.
Roughly, we can state that fornia.lisms and implementatio;is that provide wilue disjunction can be implelnented more eas ily a.nd more efiicienilg', since they can exploit the faci that disjunclive information for a certain feature ha~; no et\[ect (~li other features (as long ;is disjunctive iui\3rnlation.'loe~ not interact with path equivalences, see \[Eisele/1)grre g8\]).
t3tlt. the restriction to wdue disjunction decreases the expressive power of the formalism, since disjunctions concerning di\[ l\?rent features must be stated on a higher level, Schemes providing for general disjunction allow for a more compact representation of such cases.
But if disjunctive information is not local to single features, the interaction between different parts of tile descripi.ion is more dilflcuh to handle (see e.g.
\[Kasper 87\]).
The method we propose combines advantages of both ap preaches.
It can be seen as a generalization of value disjunction, which allows for a concise description of di~Lju~cLion concerning more than one feature, or pat;h.
It can also be se.en as an efficient implementation of general disjunctiol~ which a.llows to exploit the locality of disjunctive information whenever this is possible.
2 Feature
Terms 2.1 Disjunction Names The background of our approach is the simple observation that general disjunction affecting more than one feature can be reduced to value disjunction for those k'atnres, provided that tile correspondence between such disjunctions can be expressed within the formalism.
In order to state such correspondences, we will label disjunctions with a disjunctiot~ name.
Take, tbr instance, th.e formula (l) that could be used 100 i s,t A x f: s sFlt s Lld t a sort a variable simple complements selection conjunction (intersection) named disjunction (union) := A :r := (~(~)} := u IM .... := {a E U I fz(a) E \[s~ ....
} := D\]I,,,,~ n \[tL,~ ~ J'~ \[sly,.
if.(d):/ : gt\]~,~ if ~(d) = r Figure 1: Syntax and Semantics of Feature Terms to express that the directional reading of the german preposition "in" (=into) corresponds to the accusative case of the following noun phrase, whereas the static reading (=in) corresponds to the dative case.
This can also be expressed by (2), where the index dl at the disjunction sign indicates the mutual dependence of both disjunctions.
Throughout this paper, we will assume that each disjunction is labelled with ~ name.
Even in cases where a disjunction appears only once in the initial description, naming it will help us to treat the :interaction between disjunction and path equivalence correctly.
(1) (syn : arg: case : dat A sem: rel: statdn) V (syn : arg : case : ace A sere : rel : dirdn) (2) syn: arg : case : (dat Va, ace) A sem : tel : (statdn Vd, dir_in) r s 2.2 Syntax and Semantics of Feature term'.
\Ve incorporate named disjunction into ~t language of socalled feature terms (similar to those in \[Smolka 88\]), where each feature term describes a set of possible feature structures.
The language allows for the use of sort symbols A,B,C...
(:_ S, on which some partial order ~ induces a lower semilattice (i.e.
VA, B E S : CLB(A, B) e S).
T and ± are the greatest and least element of S.
We also distinguish a set of singleton sorts (a, b, c...
E Sg C S), which include the special sort NONE.
J_ is the only sort smaller than a singleton sort.
The language provides a set F of feature symbols (written f, g, h,...), an iMinite set.
V of variables (written x, y, z, xa, Yl, • • ).
to express path equivalence, and an infinite set D of disjunction names (written d, dl, d2,...).
S, F, V and D are pMrwise disjoint.
Sort symbols and variables can be negated to express negative values and path equivalence (simple negation).
The restriction of negation to sort symbols and variables is not essential, since the negation of any feature term can always be reduced to these forms in linear time \[Smolka 88\].
Definition 1 (Feature Terms) We define the set FT of feature terms with wwiables, simple negation and named disjunction by the context-free production rules given in Fig.
1. Letters s, t, tl, ...
will always denote feature terms.
The semantics of our terms is defined with respect to an interpretation, which is a pair (H, .z) of a universe of the interpretation and an interpretation function snch that: • T z:=// and -k z= \[~ • for all sorts A, 11: GLB(A, B) "z = A ~ rl B z • singleton sorts are mapped onto singleton sets • for (;very feature f: fz is a function b/ -+ lt.
• if a is a singleton sort and f is a featnre symbol, then fz maps a z into NONE "/ When interpreting a feature term with variables and named disjunctions, we have to make sure that the same value is assigned to each occurrence of a variable and that the same branch is chosen for each occurrence of a named disjunction.
To achieve this, we introduce variable assignments that map variables to elements of tile universe and disjunctive contexts that assign to each disjunction name the branch that has to be taken for this dis.innction and hence specify a possible interpretation of a formula with named disjnnction.
Since we limit ourselves to binary disjunctions, a branch of a disjunction can be specified by one of the symbols l or r.
Definition 2 (//-Assignment) A lt-assignme~t a.
is an element of l.t V, i.e. a Junction from V to li.
Definition 3 (Context)A context is an element of (1, r) D, i.e. a function from D to the set {l,r}.
7'he.,'gmbols ~, ~', etc.
will ahvags denote contexts.
For a given interpretation, we define the denotation of a feature term in a context ~ E {1, r} D under an assignment a E N v as shown in Fig.
1. The denotation of a feature term as such is defined by: :_U U st,.
nEl,r} D c~E~/v 3 Context-Unique Feature Descriptions To describe the computational mechanisms needed for an implementation, we will introduce a relational language Io express constraints over variables.
Unlike similar approaches (e.g.
\[Smolka 88\]), our constraint language will also be nsed to express disjunctive information.
For this language, we will define a normal form that exhibits inconsistencies, and simplification rules that allow to normalize a given specification.
Our language will provide only two kinds of constraints, one that relates a variable to some feature term (written z It) attd one that expresses that certain contexts are excluded from consideration because the inforn-tal.ion known for them is inconsistent (written ±\[k\]).
In order to refer to sets of contexts, we define Definition 4 (Context Desc.riptions) A context description is a propositioned.form,la where the constant TRUE, variables written d,: l and d,: r with d, E D, and the operators A, V and ~ may be empl~wecl.
CD will deplete the set of context descriptio~ts.
The symbols k, kl .... will alwags denote members of CD.
The set of purely co~junctivc context descriptiol~s (,ot eoataining the operators V and ~) is denoted by CD¢.
Each context x satisfies the context description "rRu\[,; (written n ~,: TUUF), wherea,, n ~.
d:b for b E {l,r} only if t~(d) = b.
7'he meaning of context descriptions invoh.,i,g A, V and -~ is defined as irt propositional logic.
If n ~ k, we will also say that k describes or covers ~r or that ~ lies in k.
A context description is called contradictory, if ~m eold~:rt satisfies it.
Two context deseripti<ms k, k' which are satisfied b!\] e:ractlg the same contexts are called equivalent (written \],'=k').
2 i01 An important form of constraints for our approach are constraints like x I zl kin, x2 which expresses that x and xl have to be equal in contexts where ~(dl) = 1 and so do x and x2 in contexts where ~(dl) = r.
Such constraints are called bifurcations and Xl, x2 are called (the dl:land dl:r-) variants' of x.
Assume an additional constraint xl \[ xa kid2 x4, then x3 will be called the dl:l A d2:l-variant of x and so on.
Now, instead of accumulating constraints on the variable x which might be effective in different contexts and could interact in complicated ways, we (:an introduce new variables as variants of ~ and attach the information to them.
We will sometimes reffer to a.
variant of a variable x without having a variable name for this variant.
To this end, we will use a special notation x/k to denote the k-variant of x.
Such expressions will be called contextcd variables.
Definition 5 (Contexted Variables) A contexted variable is a pair x/k where x G V and k ~ CI)~.
V,: wilt denote the union of V with the set of eontexted vario ables.
Elernents of V~ will be written with capital letters X, ?', Z, X1, Y'I ...
lib mark the distinction, we will some..
time.~ call the members of V pure variables.
During t.he normalization of feature descriptions we will sometimes need variable substitution.
If a description eontaiz)s e.g. x \[y, where other constraints might express conflicting information about x and y, we want to concentrate this information on one variable (say a:) by m~bstituting all oceurences of y in other constraints by x.
This could lea(\] to problems when constraints attached to x and y are relevant in different contexts.
One way to treat this situation correc'.ly would be the introduction of conditional substitution (see iEisele/DSrre 90\] for details).
The way we choose here is to rest.ric~ the use of variables in such a way that it is always safe to use conventional substitution.
Our trick **'ill be to require thud.
essentially all occurences of a variable x are relevant to the same set of contexts.
We call this condition (defined more precisely below) the context° uniqaer~ess of variables.
~Ve. will set up the normal fornl and the rewrite system in such a way, that context-nniquel,ess of a description is maintained during the simplilication protess.
(See \[Eisele/i)Srre 90\] for a more detailed motivation of context-uniqueness).
'The set of relevant contexts will be regarded as an inherent and invariant property of varial)les, and we will introduce a context assignment, ii.e.,~ partial function Con : V ~--~ CD~: that maps each variable in use to a purely conjunctive description of the contexts it is relevant to.
\\reextend ('on to context.ed varial)lesby defining C'ou(:,./~:) :::: co,,(:~) A ~.
in order Io obtain context-unique descriptions, we generalize our feature terms so that they may also contain contexted variables.
Definition 6 (Gontexted Feature Terms) A contexted feature term is buih' according go definition l, but where both p~tre and contexted variables may occur.
The set of contextcd feature terms will be denoted by FT~.
The symbols s, t, t~ . ..
may henc@~rth also denote contexted feature germs.
The dc**otation of a contcxted feature term in a context n {I, r} D under an assignment ee ~ l/\[ V is defined as for usual feature terms by adding: \[x/k\]~,,~ := ~ otherwise We can now define the context compatibility of a feature term.
This definition is somewhat technical and the reader can skip it, since our algorithm will produce only contextunique descriptions, anyway.
Definition 7 (Context compatibility) Given a partial assignment Con : V ~-~ CDe, a contexted feature term t is context-compatible to a context description k with respect to Con, written t,'ocon k, according to the following conditions.
A ~Con k X "con k -~t "-co,; k f:t ~Co,, k s N t "con k s Ud t "Con k for arbitrary k E CD~ iff Con(X) = k lift ~Co.
k lift ~Co.
k iff s ~Co, k and t *~Co,* k ifJs ~Co~ kAd:l and t ~co,~ kAd:r Definition 8 (Context-unique feature descriptions) A context-uniquc feature description (m0,CUC, Con) is a triple such that: * xo C V, called the root variable e CUC' is a set of context-unique constraints which either have the form &\[k\], where k E CD or Xlt, where X C V~,t E F'£~ and t "co,~ Con(X) o Con is a context assignment which is defined for all variables in CUC The semantics of contextounique feature descriptions is given by the satisfaction relation t-::Co~ between variable as.~ignmentfl, contexts and constraints, which is parametrized with a context assignment.
~, '~ t:=~: .....
Xlt iJJ" ~V:~Co,.(X) o," <X) c ~t\] .....
~,,~ V<'o,, ±\[k\] ifl ~ >~ k 7'he denotation of a context.unique f-description is: \[(x0,c~ c, Co,,)lj :--= {~O'0) I ~ < zcv,~ c {l,r} :° s.t.
Ve ~ CUC : r_t, ~ t::Coc} Given a feature term t not containing the variable x0, we (:an find an equivalent context-unique feature description (x0, {~0 IF}, Con) as follows.
We initialize the context assignment Con so that x0 and all variables eont,dned in t are mapped to TRUE (they are regarded as relevant to all contexts).
Then we obtMn the contexted feature term t' by replacing all occurences of variables in t which are embed° ded in disjunctions by their appropriate variants, such that ~J "~C:on TItUE 2.
Proposition: if t does not contain the variable x0, and if Con and t' are obtained fi'om t as described above, then \[t~ ~.= ~(x0, {:co I t'},C0n)~.
For a proof see \[l';isele/l)grre 90\].
4 Normal
Feature Descriptions One way to elimina:te a contexted wn:iable (take e.g. x/dl:l) from a description is to introduce a bifurcation (x J xl kl~ x2) and replace the variable by an appropriate variant (in this case xl).
AnMogously, contexted variables with rnore coinplex context descriptions can be replaced by introducing several bifurcations.
However, it turns out that our representation can be more compact if we allow for the use of contexted variables.
But we have to prevent conflicting inlbrmation from being attached to variants of a variable.
Our normal form will therefore allow the use of contexted variables in certain places, but in some cases, a pure variable has to be used.
l c~ is extended to eontexted variables by: a(x/k)::::: c~(x) 2 \]in the sequel we will also assmne that inaccessible disjuncts resulting fi'om nested disjunctions with identical names (e.g.
t2 in tl tad (t2 Md t3)) are removed.
102 3 A context-unique feature description (x0, CUC, Con) is nor° tool if it satisfies the following conditions: A) All constraints in CUC have one of the forms: • Z\[k\] • x I xl Ud z2 ® x l-~y, where x 7~ y • xlAorxl~A • xlf:Y where k C CD, x~,x2,x,y C V,Y C V~,d E D and A E S\{T,_L} B) 'lThe following restrictions apply: t.
\]f ±\[k\] aud x I~ aro in cuc, then Co.(~') A -,k is not contradictory 2, if x IX aud X I l\] are in CUC, then A = 1\] 3.
if :el a and xlt are in CUC, then t = a 4.
if x \] A and x I -~I3 are in CUC, then A ~ .B and 5.
if x I~A and a' I~B are in C'UC, then A ~ B 6.
if xlf: Y and m lf:Z are in CUC, then Y = Z 7.
if _L\[k\] and .L\[k'\] are it, CUC, then k = k' 8.
if x 12:1 lad ~;2 and x I t are ill C\[r(?, then t =,';'21 Ud X2 4.?
Simplification Rules for Normalization Fo~: normalization, we have to consider all ways a contextunique feature description could fail to be normal, and we have to find an equivalent description that is in (or closer t.o) normal form.
To this end, we give simp\]ification rules for each possible case.
Since there are many different ways to violate normal form, we get a lot of different rules, but each of them is very simple and their correctness should be easy to see.
The rules are parametrized with the root variable (which should not be substituted away) aml with th< context assignment, which will be extended to new variabh:.s during s~implification.
To facilit~te notation, we use c .~.
CUC to denote {c} u CUC where CUC is supposed no~ lo contain the constraint c, and C/fCx~,a denotes CUC with all oecurences of x replaced by y.
Also, if we write d: b A k', then k' is supposed not to contain d: b.
The eases we have to handle are grouped in those that treM single non-normal constraints (S) and those that treat interactious between different constraints (M).
There are S-Rules for all forms of constraints which conflict wilh condition A), i.e. which are of our of the forms J.
*/kl~ e.
~ l-,vlk :L xlY 4.
xlt or xl-~t, where t has the form T, 2_ or z 5.
x\]f:~l, where tl ~ Vc 6.
xltl Flt2 r.
:,:It~ uat2, where {h,t2} ¢_ g Among the situations in which a contexted variable x/k confliers with normal form, we have to distinguish severM cases.
If \].: ~ 'I'RUF,, then the context description is irrelevant and we can replace x/k by x (Rule S~,,lb).
Otherwise, if there exi:qts ah:eady a bifurcation x lxtLlaxr, such that k _~ d : bAk' for some b C {1, r} and k' C CD~, where k' does not contain d : b, then we can replace x/k by the shorter term :cb/k' (Rule S~,,lc).
\]f there is a biflu:cation x \]:tt LJd z,where d does not appear in k, the constraint attached to x/k is dist.ributed over the wtriablc.s :ct and x,.
(Rule S~,,ld).
In order to maintain context-uniqueness, the variables appearing in the constraint luLve to be replaced by their respective el:/.
and d:r-w~riants.
We use ilk as a shorthand for a eontexted feature term, where each variable has been replaced by its k-variant, i.e. z has been replaced by z/k and z'/k' by z'/(k' A k) (see also rule (M~8c), below).
Only if no bifurcation exists for x we have to introduce a new bifttrcation (Rule S~,,le).
We select a disjunction name d flom k such that k d: b A k' for some b E {l, r} attd k' E CD¢, where k' does not contain d : b, we add a bifurcation x lxt Lid :/:,, to CUC, where act and x,.
are new variables, and we extend Con by mapping x~ to Con(x)A d:l and x,to Con(x)A d: r.
Now we can replace x/k by xb/k'.
The other rules handle equalities by substituting a variable by some other variable, eliminate redundant constraints, handle inconsistencies, or decompose constraints with complex feature terms into a set of simple constraints.
'l'he cases where a pair of constraints violates some of the conditions Ill-7 can be treated as for similar non-disjunctive rewrite systems (see \[Smolka 88\] or \[Eiscle/DSrre 9(/\]).
Rules M~,\] 7 handle those.
When a bifurcation x Ix: tJdx2 occurs together with some other constraiut on z, this could lead to a contradiction with information known about xl and ace.
ilere, we distingnish three cases, if the other constraint happens to be a bifurcation re I yl Lid Ye with the same disjuoction name d, we get equalities between both d: i-variants and both d:r-variants (Rule A/¢~8a).
If the other constraint is a bifurcation x I yl Idol, y2 with a different disjunction name, then the.
two disjunctions interact and have to be multiplied out for the wtriable x (lhlle 3/~,8b).
To this cud, four new variables are introduced as variants of x attd new bifurcations are installed that link the new variables to those already in use.
Con is extended for the new variables.
In any other case, the constraint attached to x is distributed over both variants, and context descriptions for variables on the right-hand side of the constraint are introduced or adapted as required by context-uniqueness (tlule M~Sc).
4.2 Soundness; Completeness and Ternfinatlon We can show that our simplification rules constitute an algorithna for the consistency (or unification) problem, which is sound andcompletc and guaranteed to terminate.
For detailed proofs the reader is referred to \[Eisele/I)Srre 90\].
Below, we give the key intuitions or strategies for the proofs.
Soundness can be seen by inspecting the rules.
£ach rule rewrites a clause to one with an equivalent denotatlom To show that the algorithm Mways finds an answer, we first observe that to evcry context-unique feature description that is produced during translation or normalization aud that is not normal at le,'Lst one of the rules applies.
When the result of simplification is the single constraint ±\[k I where k ~ "rRuI.:, this means that the description failed to unify.
in any other case we cart construct models from the normal form result.
The basic idea is to choose a context i~ which is not covered by the context description of a constraint Z\[k\] in our formula and 'project' the formula into this context by regarding 0nly those constrail,ts which are relevant to this context;, thereby degenerating bifurcations to nondisjunctive bindings a" I Y.
This nondisjunctive set of constraints can be made into a modeh In order to prove termination we construct, a complexity measure for descriptions (a natural number) which is decreased in eve,'), rewrite step (see \[Eisele/DSrre 90\]).
tIere we take advautage of the fact that although there are rules which increase the uumber of constraints and hence seem to add to complexity, these rules also can be seen as part.
of an inherently irreversible process, since they distribute information M.tached to a variable over variables in more specific contexts.
But since the number of dis,junction uames 4 103 (Scula) (s~..~) (s~,~) (s~3a) (s~3~) (s~3c) (s~4).
(S¢,~4b) (s~8) (s~6) (s~7) • /~lx/~' x~ cuc xl~lt s¢ cuc x/klt X~ xlx~dX,.
& CUC x/kl t & xlx~uax~ h CUC x/~lt s~ cuc x l-~ylk & CUC xlYlk & CUC xly & CUC xo l Y gz CUC zlt & CUC xlt & CUC ~,~lf : t ~tz CUC xlhrnt2 & CUC xlhUdt~ & CUC ---*xo,Co,~ CUC (k -k' due to context-uniqueness) -*xo,Co.
xlt & CUC, if k ~ TRUE -'*~.o,co~ xb/k'lt & xlxtLAdX," & CUC, ifk==-d:bAk' --*zo,Co~ x,/klt/d:l t~ x,./klt/d:r Sz ~l~,~xT,~: cuc, if (S:~,lc) does not match ---~o,co,~ x~lk'lt & xlx~Udx~ & CUC if (S~la, b,c,d) do not match, k =_ d:bA k', x~,x,, are new, and Con(xb) := Con(x) A d:b ---+~o,co,~ y/kl".x 8z CUC ---*~o,Co~ y/klx ~ CUC --+xo,Con CUCx~, if x ¢ x0 -*~o,Co~ CUC~_~,o --~o,co, ±\[Con(z)\] & CUC,if t= ±,t =-~Vor t=-~x -~o,co~, CUC,ift=T, t= ~_kor t=x ~xo.Co~ xlf:y & y\[t & CUC,iftCV~ where y is new and Con(y) := Con(x) --"~o,Co.
xl& & xlt2 & CUC --*xo,Co~ xlxtUdX.
& xtltt & x,-lt, Xc CUC where {&,t2} ¢ V, Xb are new and Con(xb) := Con(x)A d:b (~4cul) (M~2) (i~3~) (M~4~) (M~,,4~) (M~5) (M~6) (M~.8a) (M~s8) (M:~8~) ±\[k\] ~ x lt & CUC zlA & ztB & CUC xla & xl-~y & CUC xla & xlf:Y & CUC xlA Sz xl-~B S¢ CUC xlA ~ zl-,B & CUC x I-,A ~ x l-.B & CUC xlf:Y & zlf:Z & cue ±\[~\] s~ ±\[~'\] ~ cue x I x~ LAd x2 &: x lY~ LJd y2 ~5 CUC xlx~ LAa~ x~ ~ xlyLJd~ z ~ CUC xlxxu~z~ ~= ~lt & cue "-+X 0, Con ~-'~ x o, C o~ -~x 0, CorL "-~x o, Con "-*x o, Con "-'-~x 0, Con --'~Xo,COrt ""+x o, Co~ --+x o, Con --+xo,Con "-+x o, Con _l_\[k\] & CUC, if Con(x) A -,k is contradictory xIGLB(A,B ) & CUC x la & y l-~a & CUC x la g¢ Y INONE & cue ±\[Con(x)\] ~5 CUC, if a _< B x\[A & CUC, if GLB(A,B) = ± x\[~B & CUC, ifA<B xlf:Y & ZIY & CUC _l_\[k v k'\] & CUC xlx~ uax~ s~ (cucw-x~)u:-x~_ xlxl LJdx x~ ~ xll!/a LAd2 zl ~ xzly2 Lla~ z'2 ylylkla~y~ & zlzlt2at z2 ~ CUC, where dl :/: d2 and yl, y2, zl, z2 are new --*~o,Co, xlxaudz2 & zalt/d:l $.~ z21t/d:r ~ CrfC where t is not a bifurcation Figure 2: Simplification Rules is limited, the contexts associated to variables can not be arbitrarily specific and hence, this process must terminate.
4.3 An
Example Due to lack of space, our example can not demonstrate all capabilities of the formalisrn, but will concentrate on the treatment of disjunction and the support of structure sharing between different disjuncts.
Assume as initial feature term f : (x N g : ta) V3 h : ((x Ud y) yl i : tI) where ta and t1 might be themselves complex.
Translation to contextunique tbrm will produce the description (x0, {xolf : (x Ng : t'c;)Nh : ((x/d:lLAdy/d:r) Ni : t'D},Conl ) where t'~ and t} might contain contexted variables if necessary.
Partial normalization then produces x0 \[x01h zlx/d:lUay/d: x~It) ' where the further decomposition of the constraints X t "alta, x~lt~ need not interest us.
Since the bifurcation for z contains eontexted variables, it is replaced by zlz, Ud z~, zzlx/d: l, zrly/d: r, but the latter two constraints lead to the introduction of bifurcations also for x and y.
Furthermore, the feature constraints on x and z are distributed over their respective variants.
We eventually get: xo, ~ x\[.l ud z,., 6'o~3 ~,.1i : xz/d:r, % ~l~t Ud zr, Although the resulting description contains contexted variables which refer to variants of zc and :r~, we do not have to introduce bifurcations for these variables.
Itcnce the information contained in constraints on the variables xa and xi is not duplicated, although both variables are used within a disjunction.
However, if there would be more information on the values of the gor /--features of z~, x~, or z~, for instance a constraint of the form z~lg : x', this would lead to the introduction of a bifurcation for xa, and some parts of the structure embedded under xa would have to be distributed over the variants of za.
But the unfolding of the structure below xc.
would be limited to the minimal necessary amount, since those parts of the structure that do not interact with information known about ~' could make use of contexted variables.
Informally speaking, if we unify a structure with a disjunction, only those parts of the structure have to be copied that 104 5 interact with the information contained in the disjunction.
4,4 Algorithmic Considerations One major advant~ge of our treatment is its similarity with conventional rewrite systems for feature logic.
Since we perlorm only conventionM substitution of variables (opposed to conditional substitution as in \[Maxwell/Kaplan 89\], see \[Eisele/Dgrre 90\] for a discussion), our system can be easily implemented in environments providing term unification (PnoLoc,), or the ahnost linear solution of the union/find problem could be exploited (see e.g.
\[Aft-Kaci 84\]).
The only essential extension we need concerns tire treatment of context descriptions.
A context description contained in a contexted variable is always purely conjunctive, tIence the necessary operations (comparison with TRUe;, locating, adding or deleting a simple conjunct) can each be implemented by one simple list operation.
In the constraint expressing inconsistent contexts (A_\[k\]), k is a disjunction of the inconsistencies found so far (which themselves are purely conjunctive).
This could be also represented in a list of (purely conjunctive).
contexts. However, the exclusion of irrelevant constraints ~: It, where Con(x) is covered by k in ±\[k\], and the (final) test if k ~ TRUe involves a bit more propositional calculation.
Since these tests might occur more often than the detection of a new inconsistency, it might be worthwile to use a representation that facilitates the test for entailment.
In any case, the implementation can make use of fast bit-vector operations.
<!:.5 Maxwell and Kaplan's Approach An approach which ours is especially interesting to con> pare with is the disjunctive constraint satisfaction procedure given in \[Maxwell/Kaplan 89\], because of the similar representations involved in the two approaches.
They use also disjunction names and contexts to represent disjunctive constraints and propose,~ general transformation procedure which turns a rewrite system for non-disjunctive constraints into one which handles disjunction of constraints with the use of corttexted constraints, having the impli.cational form (k-~ d), where ¢ is some non-disjanctlw'.
constraint. This is done by replacing every rewrite rule by its "contexted versimF', e.g., ¢1 A ¢2 ~ ¢a is replaced by (k:t -~ (/)1) A (k2 -~ ~2) --'+ (kl A "~k2 ~ (/)1) A (k~ A ~k~ --, O~) A (< A k~ --, 0~), where k~ and k~ are variables for context descriptions.
There are two severe efficiency-critical problems if we want to use the outcome of this translation without further optimization.
First, any rule of the generated form should only apply to a pair of contexted constraints whose contexts are compatible, i.e. kl A/c2 is not contradictory.
But now, since context descriptions taay include conjunction and negation at any level, this test itself is an A/P-complete problem, which has to be solved before every application of a rule.
The second problem concerns substitution.
Consider a rule like z yA~ ~ ~,a-.~.
The translation produces a rule in which (P is rewritten to both ~ and (I)v_x, indexed with different context descriptions.
Thu,~, we cannot simply perform a replacement, but instead, have to make a copy of 45 (or at least those parts of 45 containing y).
Unfortunately, this prevents also the efficient union/find method to be employed for bnilding equivalence classes for variables instead of actual substitution.
All of I, hese problems arc avoided if we let the context description,:)f a contexted constraint depend implicitly on the variables in it through the introduction of context-unique variables.
From this point of view, our method can be seen as an optirnized implementation of the translated rewrite system for unification in feature logic wittt sorts and negation.
5 Conclusion
To summarize, we have presented a new unification method for tile full la.nguage of feature logic including variables, sorts and negation which avoids expansion to disjunctiw~ normal form, if possible.
The basic principle is to minimize unnecessary interaction of dilt'erent disjunctions by keeph~g thenl local to those attributes which they specify different values for through the introduction of disjunction names.
With this treatment we avoid expoimntial explosion in many practical cases.
A precursor of this algorithm \[DSrre/Eisele 89\] has been implenlenled and is successfully used in a grammar development environment.
Besides the obvious advantage of increased etliciency, our compact representation of disjunctive information also facilitates the comparison of ahernativc solulions with common parts, which has been proved to be a very valuable property in our application.
Our algorithm is specified in a completely formalised way as a rewrite system for which a model-.theoretic semantics is given.
It may seem that there are a lot of rules, but this can be explained by the following facts: we include a complete reduction from feature terms (like in t(asper/I/ounds logic) to feature descriptions (as used in Lt."G); we handle all different types of constraints, inchlding sorts ~md negation in one framework; and our rules only involve few primitive operations for which sinrple and fast implementations exist.
References \[Ai't-I,:aci 84\] Ai't-Kaci, l I.
(1984). A Lat lice-Theoretic Approadl to Computation Based on a Calculus of Partially-Ordered Type Structures.
Ph.D. Thesis.
University of \[~ennsylvania.
\[DSrre/Eisele 89\] DSrre, J.
and A.
I:;isele (1989).
Determining consistency of feature terms with distributed disjunctions.
In: D.
Mctzing red).
GWAI-89, 13th German Workshop on Arlificial Intelliyence, pp.
270 279.
Informatik \[;'achberichte 2 I6, Springer.
\[F, isele/1)Srre 88\] Eisele, A.
and J.
DSrre (1988).
Unification of disjunctive feature descriptions.
In: Proc.
o/ the '2.6rd Ann.
Meeting of the ACL, Buffalo, NY.
\[l';isele/D&'re 90\] t';isele, A.
and J.
13Srre (1990).
Dis.junc~ive Unification.
IWBS-l~eport, IWBS, IBM Germany, Postfach 80 08 80, 7000 Stuttgart 80, W.
Germany. To app.
in: f",'oc, of t\]~c Workshop on Unification Fo'r'm.alisms ....
Syntax.,q'eman~i,:s and Implementation, Titisee, MIT Press.
\[Karttunen 84\] Karttunen, L.
(1984). Features and Values.
In: P~'oceedings of COLING I98~, Stanford, CA.
\[l(asper 87\] I(asper, tt.T.
(1987). A Unification Melhod for Disjunctive Feature Descriptions.
In: PT"oc.
o.f the 25~h el nn.
Mee tin.q o/ the ACL.
Stanford, CA.
\[t(asper/lounds 86\] Kasper, H..T.
and \V.
flounds (1986).
A Logical Semantics for I;'eature Structures.
In: Proc.
of ~he 2.ill, Ann.
~lqeeling o/ the A CL.
Columbia University, New York, NY.
\[Maxwell/Kaplan 89\] Maxwell, J.
and It.
\[(aplan (i989).
Disjunctive Constraint Satisfaction.
Ill: Proc.
\[nL IVS 0n Parsing Technologies, Carnegie Mellon, Pittsburgh, PA.
\[Smolka 88\] Smolka, G.
(1988). A Feat~Lre Lo.qic tcizh 5'~tbsorla.
LILOG-F~eport 33.
IBM Germany.
To app.
in: J.
of Automat od lt.easoning.
\[Smol'!~, 89\] Smolka, G.
(1989). I"ea~'re Const.,'ai'at Logic.s .f,~J Unification Grammars.
IWl-~S-teport 93.
D,\'BS, IBM Germany.
To app.
in Proc.
o/ the l'g.5' on UTzifica.tiorz Formalis',ls --Syn.¢ax, Semantics and Implementalion, Titisee, MIT Press,

