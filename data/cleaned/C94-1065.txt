LIl~(k)I'msing of C( ut 1 A-Cont(xt,-\]~ (c Grammars :) -) 0 " ~ ~ ~ '~* ~ * G~se\]a Pit;sch l°B lnfornlatik, Universil.i;t des Saarland(!s 1).-6612',/Saar\])ricken, (\]ermany E-marl: pitsch~cs.uni-sb.de Abstract (hmpled-Cmltext--l:ree (lrammars are a t~eneralizati(m of context-free, grammars obtained by combining nonterminals to parcnthescs which can only be substituted simnltaneously, l/efl~rring to the generative capacity of the grammars we obtain an inlinite \]licrarchy <)f lanl4uages that comprlscs the context-free languages as the first and all the lattguages generated by ~lYee Adjoining Crammars (TA(;s) as the second eh'.ment.
Ilere, we present a genera\]izati(in of the context-free LR(k)--notion, which characterizes subclasses of Couph:d-Context-\[:ree (}ralltlltars and ihelefme for TAGswhich c;tn be.
pa.rsed in linear time.
The pars\]rig proce.dure described works incrementally so that it can be used for on-llne l)arsing o\[natural language.
\]'~xanlples show that important Tree Adjobling Languages, e.g. those modelling cross-serial dependencies, c:tn \])e ge.nerate.d by LR(k) Coupled--Context.-\]:ree (Iranlmars.
\] Introduction ill order to process ll&ttlra\[ I;t/l~ll;l~,eS 3 ;Vfl first }lave to model the synta× formally.
Many investigations ;is~ e.g., \[lligS,l \] show th~tt this cannot be done by contextfree graliilllars ((Jl!'(ls).
I"or context-sensitive ~.,,l'allllllars which are powerful enough, it is kn(iwlt that the anal5'sis is PSl)ACl:,--coml~lete.
q'hus, there is a trade-off' he tween tile power of the.
formalism and it;; analysis colnplexlty.
To solve this dilenlma, much work has \]men done tO char;t(:terize l;tllgl|al~e classes ill Detweett coltt(!xt-free and context-sensitlve languages herig powerful enough to model the syntax o\[' natural \]allgllages hut endowed with at Imlynomial time analysis.
(2mll)\[{:(l-(;onl.ext-I"ree Gram mars represent such a.
forma\]isnl yeneralizhlg CI"Cs.
Their suitability to model syntactical phenmnen:t fo\]h)ws \[rom the fact that they include tit'.
\]itllgllaJ!,eS ~.CllCl'il(Cd by (he Tree Adjoining (h'ammars (TACs) (i\]' \[.hls87\] as (me subclass.
Anlung other properties, both f()rmallsms are ;d)le to model tim linguistic phenomenon of cross s(:ri;d depen.
dencies, which is not context.free hut \]'rcquently appears in natural languages (of.
\[Shi86\]). The formalism of (fOul)led-Context-Free (',ramnlars \]tits been introdu<:ed in \[CIIR92\] and \[Cua92\].
It h,'.hmt, s to ~l~(: family (ff v'egulate<l striwg rewriting syslems investigated in \[1)P89\].
The inc:ruased generative capa<:ity is o\])laincd by allowing to rewrite sintultanemlsly a {retain iHllllbCl' of elements.
Other regulated string rewriting systems its, e.g., the Scatte.red (Jontext (ll'allllllars of \[(',llft.q\] generalize CFCs by allowing simultaneous rewriting of arbitrary combinations o\] elements.
\[n \[I)P89\], it is shown that this results in languages which are not sentillnear.
But semilin= earity is important since it formalizes the "conslant-growth lm)pe.rty" of natural lanyuages (cf.
\[3os85\]). In co,,t,'ast to these, all languages defined by our I'urmallsnl are semi\[{near *'\['his research has been supported hy a (h'aduh:rtenkol\]cgfellowship of the I)cutsche l"orschtmgsgenleinschaf(.
because of two restrlctions.
First, only those elementsean he rewritteu simultaneously whh:h were produced by the same re.writing.
Second, the Coupled-Conte×t-Free (\]ramllial'S coltsi(ler e\]ellleltts Iewr\[tten SillllllLalleo|tsly ;ts COil|portents of ;t parenthesis.
Those can only l)e substituted if they form a parenthesis and t\]ley can only he suhstitutetl \[)y seqlteltc(!s of pa.r(.*lll,heses cov'rectly nested.
When characterizhq4 Cuup\]ed-Context-I'~ree (~\]r&ll~l\[Htrs by lhe maximal number o1" elements rewritten simultan(> ously width we call the rm& o\[" the grammar we get an infinite hierarchy.
The generative capacity grows with the rank.
The smallest element of the hierarc\] W the one of rank I • are (~l;'(;s.
The next element, namely Couple.d-Context-Free (Iramnlars of rank 2, generates t}le same class of Tanguag.es as the Tree Adioini,g (~raIlllnaFs of \[Jl/I'75\] and \[Jos87\].
llence, all noth)ns and algorithms designled for Couph~d-Conl.ext-Free (il'ilIiIllt;tl's Of riLItk 2 can easily be translated onto 't'A(ls (eL \[Cua92\]).
l~ec:allse of the enJarl,e(I geIterat, lve capacity, it is not sutprising that the coutllh:xity of analysing I:tl<gIHtges gener~tled by (Jouph:d-Context-l"ree (h'anm,ars is larger than it is in the context free case.
\[t even increa.ses with growi,m rattk (c:L \[11P9,1\]).
Therefore, we aim to characterize suhclasses of the set of all lall,~ll~t.ff, es geller~tl.ed hy (,'Oul)led(.~oiHexl,-.Vree (~'4t'atllllltaFs which are powerful ellOltgh to model the important phenomena of natural liu,guages, I)ut which are of at lower c(mq)lexity.
The deternliuistic (:onlext-free parsing with Llt(k)~,~"............ leads t .... li ...... r tinl ......... lysis (of.
\[Knu65\]), the best lmssible.
Therefbre, its generalization is very attractive.
A fh'st altempt in this direction was done in \[.'qVg()\].
I~u(. there, only TA(Is are ilwestiga|.ed.
\]\]ere, we invesilgatc~ the whole hi(Hallchy Of Couph:d Context-l"ree (lramma~s.
Allhou,;h their enlarged generative (Stl)a:ity seems to I)e c(mlradictory Io a.
Ihm;u' time cOnll)\]exlty of q\]le palsrig algmithm, we can present an Ll~(k)-notion t'{, (:oup\[(:d-Co,ttext-l"vee Crammars dcs:ril,ing a class of laugual'j:s, which can actnal\]y bc anMysed in linear time.
This increase ill power a.s to the linear time ~tlHtlysis is ilaid hy an expensive ln'eprocessil~g.
It in taking into account (he comple× rclntlons \])etwe'n parewthese.s that involves ILL(: ill(:rease ill conll)lexity, l\[owever, these costs are to he paid only once for each grammar.
The suhchuss described hy our I,l~(k)-notion for a lixed k i.rows with the rank.
"\['he al~orithm of \[.q\:90\] fnr l,l¢(k)/l'AGs does not fullill theimp(,tant Valid Prefix I)roperty.
This means that for any prefix o1" the iUl)Ul: aheady accepted, there exists a suffix such that the whoh', word is in the language analysed.
It allows to detect illegal inputs as soon its possible, which is necessary for efllcient parsing.
Our algorithm fulfills this property.
Addition;lily, the algorithm its well as the notion defined here,'eprescnt genera.lizations o\] their context-free C<)lllt(,et'pltrts which are ll~ttllra\] ill tit<: sense that they strictly contain tit: context-free sitnation as the special case of (;ouple(\[-(Jonl, exl.-Free (\]ranLulars o\] rank 1.
401 An example of an important LR(k)-Coupled-ContextFree Grammar is the one generating the language {w$w I w ~ {a, b}*} which reflects the syntactical construction of cross-serial dependencies.
The paper starts by defining the Coupled-Context-Free Grammars.
Thcn, wc shortly recall the context-free Lib parsing procedure.
Subsequently, the deterministic finite automaton used there to guide the analysis is modified such that it can handle Couplcd-Cm~text-Frec Grammars.
Based on it, the parsing algorithm for LR(O) CoupledContext-Free Grammars is derived.
Tiffs results in the generalized definition of the LR(O)-notlon.
As for CFCs, the LR(k)-Coupled-Context-Free Grammars result from the LR(0)-ones by resolving decision conflicts using a lookahead of at most k symbols.
2 Coupled-Context-Free Grammars Coupled-Context-Free Grammars are defined over extended semi-Dyck sets which are a generalization of scmlDyck sets.
Elements of these sets can be regarded as sequences of parentheses that are correctly nested.
SentiDyek sets play an important role in the theory of formal languages.
To extend the family of context-free languages by using them wc consider parentheses of arbitrary finite order define(\[ as follows: Definition I (Parentheses Set) A finite sctK := ((ki,~ ..... ki,,,,,)li, mi ~ N} is a Parentheses Set iff it satisfies ki,j # kt,,,, Jot" i ¢ I or j # m.
The elements eric are erdled Parentheses.
All parentheses of a fixed length r are summarized as ~:\[~\] := ((~,., .....
~,,,,,,) ~ ~: I,n, = ~},,hct.e ~C\[O\] := {~}.
(~ de.otes O,e e.,Vt,a,,otd).
"the s,.2 of all (first) components of parenthesis in K is denoted by eon,p(~C) := {~, I (~, .....
~, .....
~,) e ~c},esp.
co,marc) := {~, I(~, .....
~,) e ~c}.
Straightforward frmn this, we get Definition 2 (Extended Semi-Dyck Set) Let ~ be a parentheses set and 7' an arbiteary set where 7" VI K = T m comp( K) = O.
E D( K, T), the extended semiDyck set over E and T, is indnetively defined by (El) T* C ED(K, T).
(E2) ~C\[~1 c ~D(~C, T).
(E3) u~ ..... u, E ED(IC, T),(k, ..... k,+,) e K\[," + 11 ==~ k~u~ ""kru~k~+~ G ED(K,T).
(E4) u,v e ED(K,T) ~ u.
v ~ E1)(K,T).
(E5) ED(K, 7") is the smallest set f,,lfilling em,ditions (E1)-(E4).
Now, we define how to generate new elements in ED(K, T) starting from given ones.
Definition 3 (Parenthesis Rewriting System) A Parenthesis Rewriting System over ED(/C, T) is a fiaite, nonempty set P of productions of the form {(k, ..... k~) ~ (.~ ..... o,).
I (~, .....
~,) C-,~,., ......,,.
e ED(~, "r)}.
The left and the right side of p := (X~,...,X~) -* (o:1 ..... o6,) G P is denoted by • S(p):= (x, ..... x~), thc sonrce oh,, a,,d • V(p) := (or, ..... e~,.), the drain ofp.
Now, we can deline our grammars.
The term "coupled" expresses that a certain number of (:ontext-free rewritings is executed in parallel and controlled by K\[".
Definition 4 (Couph;d-Context-l, Yeo Grammar) A Coupled-Context-Free Grammar over ED(K,T) is au ordered ~-luple (IC, T, l 7,S) whcr'e l' is a Parentheses Rewritin 9 Syste,n over ED(K~,7') and S 6 KIll.
Therefore, IC can be regaeded as a set of couph:d nonterminctls.
The set of (all these granmmrs is denoted by CG' I,'G.
~(~ At last, we give the definition of derivation in CCI,.
Let (;' = (K,T, P,S) C-,(.1 G and V := cornp(l£)UT.
We define the relation ::~zc; as a subset of V* × V' consisting of all derivation steps of rank r for G' with "r > l.
p =>a '0 holds for 99,~/, G V* if and only if there ex\[st (k, .....,k,) -~ (-* ..... -,) e P,,*,,,*,,,, e V', and u2,...,Ur E ED(K,T) such that 9~ = ulkau.fl~2...u,.k,.u,.+l and ~\]~ .~: Itlt~l//2e¢ 2 •,,ltv('gr?lr+l, -'~6' denotes the reflexive, transitive CIOSII|'(: Of ~'(~', ()bviously, 'al .u,+\] (5 I')D(/C,'/') follows from S =*>c; (p for ~2 and ~b siuce the result of the substitution is a sequence of parentheses correctly nestcd if and only if the original word was.
The language generated by C is defined as LaG) := {w ~ 7'" 1.9 -4~,,,}.
A sequence ~1,..., 90, with 9~i -~c; (~'~i-{-1 for all I < i < n and ~1 -g, (P.
= ¢ is called a derivation o\]'(, from g in C.
A deriwttion is righhaost if and only if in each derivation step, the parenthesis ending at the rlghtnlost point is substituted.
In analogy to C\]"Cls, it is obvions that for any derivation in CC1;'C there exists exactly one ri~htmost (h'.riwtt k,i.
Ex,,,np\[,, ~ c: _({s, (x, x)), {a, (',S,'t}, P, s) is i,, cc/,'6'(2),.here 1' := {S -.
XSYf, (X, X) -~ (aXb, e~,t) I (.~, ea)}.
c ~e,,e,'(,.,s the lan:tt,.g.
{."~*'e"d" I '* -> ~}, e.g.
S :~'6' X$.~ =>(~ aXb$c~;d :>c; aaXbb$ccX-dd =>c1 aaabbbeccddd In order to be able to describe the generative cal)acity of Coupled-Context-Free Crammars of different ranks exltctly, we need the following notions: Definition 5 (Rank, CCFG(l)) Foe any (5' = (K,7', P,S) G C(21,'C,', let the rank of (l be d,'finc,l,,s,'ank(G) :=,,,ax {" I (< ..... k,).
C,~}.
The.at, we define for all l > l: CCl,'C(l) := {c, E ccrc;' l,.a,,k(c') < l} The following theorem prowm in \[Gua92\] shows that CCI,'(I In,\[his up an infinite hierarchy of languages and, at the same time, represents a prel)er extension of CI"Cs not exceeding the lmwer of context-sensitive granlolars: Theorem 1 (llierarehy) Let CI"L be the family of all eontext-free, CSL the family of all context-sensitive languages, TAL the family of all languages generated by 7'A (.Is and CCI;'L(I) Ihe one generated by CCFG(l).
It hohls: (1) c't,u, = cc/,'t,(1), "eAL = c'cl.'t,(2).
(2) cct.'t,(l) ~ C'C'FL(I + ~) /o,.
.. l > i.
(a) 6'CVL(I) c cs/, /or,n l > i.
Sometimes, i* is useful to "neglect" the relations beg tween the components of a parenthesis for a short time.
Then, wc investlg~tte C/ :== (eomp()C),7', P',S) instead of G = (K, T, P, S) C~ .CI'G for P' :-U {ki -, ~v~ll _< i <.
r}. (~,...,~..)-.(,,,...,,~,.)~P Since C' is certainl~ a CI'G we &mote 6" (resl).
P'), by CI"(G) (resp.
CI'(I')) in the sequel.
Obvmus,y, G' satisfies LaG) C LAG").
402 3 Context-Free L\]?,-Parsing Now, we shortly recall the deterministic context-free LR(k)-parsing strategy of I(nuth (or.
\[Kmt65\]). 1,'or slmplicity, we restrict ourselves on the case k = O.
The strategy essentially renlains unchanged if lookahead is necessary.
It uses a deterministic finite antoniaton (dfa) to drive a pushdown stack while scilnliiiig the inpnt from left to right.
'l.'}uis, it COllstrllcts a riglitnlost derivation bottom-up.
The states of the d.fa for a given LR(0)-CI"G consist of subsets of the set of all context-free items for (; (N,T, P,S'), i.e. of the set {\[X --~ ~,.fit\] I x .... i~ e v).
'\['hey result from dcternilning the deternlinistic w~rslon of the following nondeternfinistic automaton for (:l: \]!\]aeh context-free item is a state.
There are.
three kinds of state transitions: \[x ...... yf~\] "~Z \[x ....
Y.fq, \[X .~,r . • -~ ..,,i7}, b': -' <,,./~\], a,,d \[Y > "~.X~\]-<, \[X --, .<,.1.
In the (leternllnlstic version, all those context-free \tents are grouped in one state which can he reaclled from tile initial st~tte by the sail)e Setltle.itce of symbols) with ally possible number of e-transltions in-between.
The stack symbols are the states of the dfa.
At first, the state containing the item \[S' -, .S\] is llushed.
(The addithmal l)rodnction .S '~ --,,S' serves to define exactly the start and the end of the analysis).
Then, we iterate the following actions delmndhlg on the toImlost state q: (Shift) lfq contains \[X-,~*.a/f\] and a is the next input synt\])ol to be read, we push the state reached froln r 1 vl .....
(it coiitaiits at least {X ~ <,a.fl\]).
(Reduce) if q contai,,s \[X -~ c<.}, we I,Ol, tim I-I tov,il,ist states.
Let q' be the state now OH top of the stack.
Then, we push the state reached via X from q'.
(q' eoutains at least one it.e,n \[Y--.
T.XS\] and \[X -~ .~\] while the new topniost state contains \[Y -~ 7X.@) 'l?he pushdown is driven determlnlsth:ally hy the Ilia if this d fa contains no state wliere th('~e are two different Reduce-items (Ih:duce-lteduce conllict) or as well it Shiftas a lt.ednee-itent (Shift-Reduce conflict).
A (~'1"(1 is LR(O) ill" the states of its dfa show no Shift-i\[e.dnce and 11o Reduce-l/.educe conflict.
For LR(k)-grammars, conflicts in the LR(O)-dfa are solved by it h)okahead of k syml)ols.
4 The
Finite Automaton One possibility to generalize dfa is to construct the usnal dJa for 6'F(G), (I E CCI,'G.
In l)rinciph!, this idea is used in \[SVg0\].
"|'lie fl)llowing example shows that this produces unnecessary contlicts: I,et (; --.({s,(X,A_~),S)},{.,*,,~,i~},V,.s ') c= c'cva(2)re, Z" := {s--~ XXD$,D -, D,Z l d, (x,~;) ---+ (t,,e) l (,O,,<:d)} a,,d C(a) = {b,:d"$,,d,e<t,P$1,, > 1).
its <q<, is sl.>w,, hi Figure l.
(~ is not LI~(O) in this way since this dSa ohvlously has a Sllift-l\[educe conflict (in the box doubly lined).
This conflict cannot he solved by loekahead since at this point, the lookahead is always d x.
Therefore, (l is not LR(k) for ~tlly k ~ 0.
But this conflict is liOt necessary.
I",g., when analysiug bedd bottoni-up, we first haw..
to reduce X --+ b.
This inlplies that lie|ere coming to the conflict state, we have to choose X -, e in order to get a correct derlwttion.
This is the case \])ecause X an(I X resnlthlg from applyh~g the productiou 5; '-~ XX D$ ar(: /x ...... b I IN -,,e J ID -+ .d l Lx --, J ....
L--l:igure 1: dfa((;) <:mq)h'.d and therefm'e haw~ to be substitut~M by coupled I)roducLiolls.
To awfid these conflicts, we extend the dfa.
If" we use the context-free LR-I)arsing strate.gy, we know which product\o,, we have to choose for any Xi G eoinp(K).
\ compl (K).
because we first encounter alld reduce the corresponding X1 E co,lpj (hT).
Suppose that we can store the infornlatlm, ahout X ......
X,., (Xl .....
X,).
E K.\[,'\], when X~ is reduced, let us say as the "future".
(\[low to do this is shown in Section 5).
Can we use this to awfid the conflict?
Now, our automaton needs additim,fl transitions under s,,ch ~,~ c cv(P) where S(7,~) ¢,,o,,,V~(JC) h,)las.
"rh,,s, we split ways inside the dfa which lead to conflict si.ates.
"Fo formalize our atltOlt)aiA}ll) We need the following Definlt.hni 6 (1-Closure) /,'o,.
<,..\'c=,.o,,,p4sc ), t,.~,'e.<,h.bte(X):= (v c ......
~,,(E).
I -Ix -.
Y. e or(v)}.
reachabb:+(X) denotes its reflexive transitive closure.
For .,y q E f,({\[X --, a./7\] \[ X --+ c~fl G CI"(I')}), wc define the I-Closure(q) as q untied to Ihe set {\[X .... q l X e,:o,,,I,,(X:), X -,,~ e C'F(P) ..d .-3Y c coi,+,(sc) : (3\[z -,/~Yv\] c,s,,,,J x e,.~.~.h.bte'(Y))}.
iClosure formalizes the construction of the deterministic version of a nondeterministic finite autonhM, On as it is done for the dJ'a of (Jl"Cls.
Its special feature is that it uses o,,ly those X ~,* E CI"(P) f,,lfilling X Ce,,,,,p,(K).
If A" c,,o,,,v(JC) \ c,,,,,v, UC), ti,e expa,,di,,g prod,,,:ti<),, is detc.rmhmd hy the corresponding first component.
l)eflnlthm 7 (1)1"/1((_;)) Let G' = (K, 7', 1", .q') ~ CCb'(l.
The l)ete.rmildstk: l"hdte Autonlaton for (I is defined as DI"A((1) := (Qa, ~a, ~G, S'c~, l"a),,,he,',: S'.
:= l-Cto..,,'e({\[,V'-~ .Sl}) is 0.
initial state, >2~ :--=eo,,u,(Jc)u ~/'u D, e cv(l')ls(p) ¢_ co,,,vi(sc)) the input alphabet, bc, the transition function defined/or (2 eOliip(~C) U'r a,,d L e C'F(P), S(L ) ¢ c,,,,,,l(/C), by 6<dq, ~):: 1-Cto.~,,i.4\[xs->-s~.~J\] I \[A'j ....
J.~fls\] c q)), 5c,,(q, fi) := i-CIosurc({\[S(fi) --~ "P(I')\] I ~\[x: -, .~.s(fd/~s\] c q}), (2(;' is the set of the states given by {'l I =~" C= (eo,.p(IC) U "rU OF(P))" : ~;(S., u) = 'd,,,,,~ l,'~, := (,~ c O.
I\[X ~ -.\] c q,x -.
<,< ~ cs,'(v)) is the set of the final states.
403 sl /x ~ ~_ I d s,-~ .s_ ~s ~ xX.D, I s~'xxD*l Iv_.,, I D ~ 'D' I I x -~'~ I ~_12_~ ....
ID ~.,l Figure 2: DFA(G) The first difference to the usual context-free automaton is that we allow transitions nnder fl C CI;'(P), if we have S(fl) ¢~ comps(It).
The second point is that we use 1-Closure instead of the usual closure.
DFA(G') for the example grammar is shown in Figure 2.
The conflict is removcd because we can now distinguish two cases by looking at the information additionally stored.
Ill \[SV90\], only the first i(te~t was realized ohviously leading to a weaker antolnaton.
5 The
Analysis "Po use DFA(G), the usual pnshdown is extended by a data-structure consisting in a list of partial derivation trees.
This list future collects all information determined by Reduce's relative to first nonterminal components and is used to drive the transitions under p G CF(P) in DFA(G) as soon as we have to investigate nontermlnal components Xi ~ compl(K.
). The change between the two different kinds of control leads to a new characterization of conflicts.
For better explanation, we use a list past paralM to future where all Reduce operatimls performed so far ale stored.
An example for tile new data-structnres is shown in Figure 3.
We use it to explain how they arc built up during the analysis.
The first operations on this past were Shift(w1), Shift(w2), Reduce(A -+ w2).
From CFGs, we know that any Reduce takes place at the end of the sententlal {'orm generated so far.
This remains true.
Thus, we Call a.rgue completely analogolls as f~kl' its l)(18l iS COtlC(!l'lICd.
But we investigate coupled productions as, e.g., (Z,,Z~) --, (w~A,U,V~), A, (Z~,Z~), (Vl,U~) C*C.
We know that coupled nonterminal components are located at the same depth of the derivation tree and that they are substitnted by components of tile same coupled production.
Therefore, when insertiilg any p, S(p) G eomlh(K.
), in past, e.g., Zl -~,viA, we additionally insert the coupled productions, e.g., Z2 --+ UtU2, in future.
In general, Yt -~w4 "-'-tll ",~-past fld."~ B2 -" B:l -~ V2 2-, i"-.
I//%, Z, N ws wo a D Z~ Ql (22 5,\ A wl A wa U1 U2 *lJ 2 Figure 3: The New Data-Structures there are two cases to distinguish depending oil l)l inserted in pnst.
If Dips) cont,(ins only sYmbols in /C\[1\] O 'F (i.e.
only uncoupled ones), the conpled p2,...,p,, are inserted as the first up to the (r 1)th element in future.
(E.g. for (Z1,Z~) ---+ (wlA, U1U'~)).
Otherwise, we behave as it is do,le for (Y,,~) ~ (Z~N,Z./&Q2)in V@,re a.
~ .... the sllbtr~es i,, Iut,,re for those sy,nbols i.
"(V~) .....
"D(V,,) coupled to first comlmnents in 7)(pt) become the sons of these elements.
T|ms, wc maintain the property that the symbols at each fixed depth ill past and future together form an element of 13D(~,T).
Thereby, in addition to Shift's which are handled as usual, we know what to do during a se(ltlelice Of Reduce operatk)ns relative to elements of co,np~(K).
Now, let us be in the situation that we have to use the information in future, e.g. a transition under B2 --+ a =: pi frmn the topnlost state.
Then, we create a pointer prise(tee walking on future.
We ptlsh ~Sc;(qtov, pl) ;rod make presence point onto the first son {" o1' "D(pi).
Let q be the new topmost state.
We have to distinguish three cases: GT': If ~" is tile next input symbol, we push ~a(q,~).
Otherwise, the whole, input is rejected, preseuce now points on the brother of ~'.
e G eomp(~) \ comlh(J~): fulurealready stores theexp;tnsion ~ --+ ft.
We push 6c~(q,( -fl).
presence now points on the first symbol in ft.
(7_ eompl(K): \],du,'e does not store information +tl)oltt (, but ~ and its coupled components rel)resent ;t complete independent analysis probh:n~ which has to bc solved rccurslvely.
E.g., this is the casc for D, (I:~, U~) ......
I (q~, Q~).
The recursive call of the procedure starts with tlu'.
topmost state since, it contains all items \[~" -~ .~,\].
Each recursion needs separate data-structures.
I)etails are described in \[Pitg3\].
If l)Feserlce encollllters no brot\]ler~ We }13.ve to redllce.
Let Y -~ 3' be the production at whose last synlbol presence points.
We pop 171 -I1 states.
The additional Imp conll)ared to the context.-fi'ee case results from the transition under }: ~ 7.
peesenee walks to tim brother of Y in fut,,re and we push 6c;(q', Y) if q' is the IleW toi)nlost state.
1\[ Y is the root of the tirst tree in f,l,,'e, its complete subtree is nlovcd \['rom flttm'e to past and presence is deleted.
~Ve Ollllllt 19 ~ 1) whell redueiug its last conll)onent.
"\['hus, ollr result ix a uiphtmost dcrlval.ion in inverse or(h:r.
13 q?he Definition Go far, we.
did not discuss the situation that there /tre distinct transitions fitting for the same state in DFA((\[).
S h if tRed u ce and Red nceRed u(:e con flic ts are for bklde.n as they are for Cl"(\]s.
The new conflicts result if we have to decide whether we.
push &~(q,,,,, fj), fj e CI"(P), or Shift resp.
Reduce as usual.
If a state q shows such a <'llew" conflict, it contains two items of the kind \[Zi -~ 7i.Yflli\] and \[Xt ---* (tt.~fll\], ~ Q :\[', or \[XI -* (~t.\].
~l'his is easy to deeide as far as we are wadking on future, since tile inforlllatiolI llecessal'y is store.d there, r\]'}lllSl We only \],ave a real con\[\[let if" i = 1 :tnd l =: 1 holds for the M)ove items.
Obviolmly, this cannot })e decided determinlstically, sluce we would h:tve to know about the structure of the derivation tree not constructed so far.
E.g., in the first conflict, we wouhl \]lave to s;ty whether ~" is,~ son of )~ (cltoose &;(q,) 5 .... 21(f,))) or whet|let e is a son of X, (choose 8c:(q,~)).
It follows that( we need a modified dclinitio,I of "conllicts" compared to CI;'Cs.
404 l)eflnithm 8 ((hmtllcl,) Fo,,.,,,,y 0 =: (/C, 7', P,,S') c.2 6'CI,'G, DI,'A((;) show,~, contlict q at least one of it,~ slules conlai.s a subset of lhe following kind: (ILR) {\[X-r c~.\], \[~ ....
#diS, Y ~,,o,,,v, fie), 2: --, .,Y -, fle or(?)} (s40 {\[x -~ ~.\],{Y-~ ft.,v\] I x,Y c:,,o,,,,~Oc), x ~-,Y-, #.v ~ elf(u),.
~i 71 (xq0 {IX--, ...#\],\[z., %~3.\] I x, z ~ eo,,,Vs(,~:), x -...#, z -> vS,~ e c's,'(u),,< ~ % ~9 c,..o,,,p(;c) \ co,,,,,(;c)} Ut-/c) {\[x -, ~,\], \[z -+ %5,1\] I x, z ~~!,;o,.a (x:), ',.
e ~o,,,p(~c) \ eo,s,m (~:), x -,,~,z -, ~5,/e or(p),) Definition 9 (Lie(o) in COl,'(;) (I G C(71,'(I is ./;R(0) < > l)I;'A((;') h.s no conflicts.
Thenrem 2 Let Off CUb'(2 be I,R(O).
Our cdgorilhm deterministieally solves the wordprohlem for any w ~? 7", n := \[wl, in time O(n) by eortstrt.:ting, rightmosl de,'iva6on rela6ue to G if 'to (i L(C), and, if w (L(O), by rejecting tits i.put.
In .ddition, the algorithm,~hows liter Valid Prefix I'ropert!l.
Proot5 The linear time eomphMl, y follows since we only need a Ct)llStltllt itlllOllllt Of additional steps per eontextfi'ce step lor past and fulure.
DI,'A(G) is determined only once for each G'.
The VPP hohls since it holds for tlle contcxt-fi'ec algorithm and fldure additionally e.sures that tim ctmpling is correct.
~1 LR(k)(?oupled-Context..l"ree (lI';tllllll~tl'S l'CSIlIl~ \[lOm the above by resolving conflicts in I)I"A((;) by addi.g st h)okahead set to tim items which are involved in it conflict.
For this purpose, we lsse Lhe m;tpphtgs b'll~ST'~ ~tst(I l"OLLOWk as defined fin" LL(k) ~ (\]Oul)led-ContextFree Grammars in \[Pit94\].
There, these mappings are generalized such that they take the couplinl, Imtween the eOllll)otleltts of each lloiaterlllilla\] ilttoo ;I.CCOIIIS~, illSte;td o\[ working simply on C/"(G).
Thus, we tre;tt only colnplete parentheses as ~t context-free IiotltersIlillal itlld the i'(~Slllt is much ltlo|:e ex~Lct as, e.g., ill \[SVgl)\].
This results in an adequate generalization of the LR(k)-notion for CCI"C.
s .... w,12x@_, x ~~~;?v/\] Ix .... t, r"l.
t " i.l ....
L;..... l q,, .... x.,,l \[,...... l \] \[.,.,,,.,..,l\],I -:l .\[ '1 \[-C-:J:~Z:j IA;:Y, Sbq I~;,),(1 \[:¥;-,,:,~:~.J Example 2 The lanyuage {a"b"c"d'* \] "n > l} generalcd by the gmut.u". in l'):rttmple 1 shows the .LR(O)-properly.
DFA(G) is shown i.
Figure 4.
l~x,~,~q,h, :t 7'/,e: l.,,.,,.:., (,w$,,, lw ~ {., ~,}') .,o&ni,,q cross-seri(d dcpemh'ncics c.n be .qencroled by lhe L R( l )r..,,.,.,s.
({s, (._5 x)), {,,., I,},/', s) ~ ¢cro(2),,..,,e P :: {s-~ x,x, (x, x)-~ (.x,,,x) lO, x, ~x)I (~, ~:)}.
References \[I) P89\],1.
I)assow, C.
P,~.n: Regulated Reweiti.g its Forrn.l l,m~gem9 e 77wory.
Springer 11989 \[G1169\] S.A.
Greibach, J.E.
/\[opcroft: Seallercd Con° lexl (;r.mmnrs.
J. (9olnp,lt.
Syst. S(:i.
3 (1969), pp.
232-247 \[CHI91~\] Y.
Cluan, C.
llotz, A.
Reichert: Tree (:ramrn.rs with mullilinem" lnte~7.'elallon.
Technical Report, Univ.
Saarbrik:lu:n 1992 \[(\]ua92\] Y.
(',II&SH l(lammerqraramatiken, Nelzgrmmnaliken und l.lerprelalionen yon Nelzen.
PhD thesis, UU'niv.,q~tarbrlicken 199'2 \[1IP94\] G.
llotz, (',.
Pitsch: It.st IIrdform Annlysis of Coupled-Oonle:rl-l"ree (/rammm's.
In Pro(:.
of ICAI,P'g4 \[liigS,l\] .1.
Iligginbotham: l';nglish is nol a Contexl-f, Yee Langu.ye. lang.
lilquiry 15 (1984), pp.
225-235 \[,112\['75\] A.K.
Joshi, I,.S.
l,evy, M, TakMm~hi: 7)'ee Adjunct (h'amut,,rs.,I. CComput.,Syst. Sci.
10 (1975).
pp. 136-163 \[,Ios85\] AA.K.,Ioshl.
Tree Adjoinim.!
CTvlmm.rs: llow Much Conle:vl-.$'ensilivity is I~equired to Ptvvide Heasomdde Sh'uelural Descriptions.
In Natural \[,;tnguage Parsing, (~ambridge U,iver..fity Press 1985, pp.
206-2/;0 \[.los87\] A.K..Ioshi: hsh'oduction to Tree Adjoinin9 (;r.zttzttars.
lit M a.thematics of Language, John BelLiamins l'ublishing Comp~uty 1987 \[Knu65\] D.E.
Kntttls. On the Translation o/Languages from Left 1o INflht.
I.formation ;und Control g (1965), pp.
607-(;39 SPit93\] (\].
Pitsch: An(llyse yon l(lammer!lrmnm.tiken.
l'hl) thesis, Univ.
~t~trbrfi(:ken 1993 \[Pitg,l\] (\].
Pitsch: LL(k) l'arsin 9 of Couple,l-Oonh::,:l/"tee (/r.mmnrs.
to iq)peal iik (iJOmlmt;tLional I nlelli~en(:e 199,t \[.qhia/;\] .q..qhielmr.
I';videm:e again*st Uonleittl /"reeness of Natm'al L,nguage.
Linguistics and Philosophy 8 (198(i), pp.
333-3,13 \[SV!)0\] Y.
Schid)es, K.
Vi.iay-,%:tnl(er: Deterministic Left Io I?dght Parsin 9 of 7Yce Adjoining Lmt9uages.
ACI,'90, pp.
276-283 Figured: I ....
{a"b"c"d" l n'~ 1) 405

