SOLVING ANALOGIES ON WORDS: AN ALGORITHM 
Yves Lepage 
ATR Interpreting Telecommunications Research Labs, 
Hikaridai 2-2, Seika-tyS, Sgra.ku-gun, Ky5to 619-0288, Japan 
lepage~itl, atr. co. jp 
Introduction 
To introduce the algorithln presented in this pa
per, we take a path that is inverse to the his
torical development of the idea of analogy (see 
(Hoffman 9.5)). This is necessary, because a 
certain incomprehension is faced when speak
ing about linguistic analogy, i.e., it is generally 
given a broader and more psychological defini
tion. Also, with our proposal being computa
tional, it is impossible to ignore works about 
analogy in computer science, which has come 
to mean artificial intelligence. 
1 A
Survey of Works on Analogy 
This paper is not intended to be an exhaustive 
study. For a more comprehensive study on the 
subject, see (Hoffman 95). 
1.1 Metaphors, or Implicit Analogies 
Beginning with works in psychology and arti
ficial intelligence, (Gentner 83) is a milestone 
study of a possible modeling of analogies such 
as, "an atom is like the solar system" adequate 
for artificial intelligence. In these analogies, two 
domains are mapped, one onto the other, thus 
modeling of the domain becomes necessary. 
/ sun -~ nucleus 
planet ~ electron 
In addition, properties (expressed by clauses, 
formulae, etc.) are transferred from one domain 
onto the other, and their number somehow de
termines the quality of the analogy. 
attracts(sun, --+f'attracts(nucleus, 
planet) electron) 
moremassive(sun, -~fmoremassive(nucleus, 
planet) electron) 
However, Gentner's explicit description of 
sentences as "an A is like a B" as analo
gies is subject to criticism. Others (e.g. 
(Steinhart 94)) prefer to call these sentences 
metaphors 1, the validity of which rests on sen
tences of the kind, "A is to B as C is to D", for 
which the name analogy 2 is reserved. In other 
words, some metaphors are supported by analo
gies. For instance, the metaphor, "a.n atom is 
like the solar system", relies on the analogy, "an 
electron is to the nucleus, as a planet is to the 
8~tl~" .3 
The answer of the AI community is com
plex because they have headed directly to more 
complex problems. For them, in analogies or 
metaphors (Hall 89): 
* two different domains appear , for both domains, modeling of a knowledge
base is necessary , mapping of objects and transfer of proper
ties are different operations 
* the quality of analogies has to be evalu
ated as a function of the strength (number, 
truth, etc.) of properties transferred. 
We must drastically simplify all this and 
enunciate a simpler problem (whose resolution 
may not necessarily be simple). This can be 
achieved by simplifying data types, and conse
quently the characteristics of the problem. 
1If the fact that properties are carried over char
acterises such sentences, then etyulologically they are 
metaphors: In Greek, phercin: to carry; recta-: between, 
among, with, after. "Metaphor" means to transfer, to 
carry over. 
2In Greek, logos, -logia: ratio, proportion, reason, dis
course; ana-: top-down, again, anew. "Analogy" means 
the same proportions, similar ratios. 
aThis complies with Aristotle's definitions in the 
Poetics. 
728 
1.2 Multiplicity
vs Unicity of Domains 
In the field of natural language processing, there 
have been plenty of works on pronunciation of 
English by analogy, some being very much con
cerned with reproducing human behavior (see 
(Damper &: Eastmond 96)). Here is an illustra
tion of the task from (Pirelli & Federici 94): 
: /vejn/ 
.L g .1. h 
sane-X = /sejnl 
Similarly to AI approaches, two dolnains ap
pear (graphemic and phonemic). Consequently, 
the functions .f, 9 and h are of different types 
because their dolnains and ranges are of differ
ent data types. 
Similarly to AI again, a common feature in 
such pronouncing systems is the use of data 
bases of written and phonetic forms. R.egard
ing his own model, (Yvon 94) comments that: 
The \[...\] model crucially relies upon the 
existence of nunterous paradigmatic rela.
lionships in lexica.l data bases. 
Paradigmatic relationships being relation
ships in which fl~ur words intervene, they are 
in fact morphological analogies: "reaction is to 
reactor., a.s faction is to factor". 
reactor f reaction 
I g I g 
factor !. faction 
Contrasting sharply with A\[ approaches, 
morphological analogies apply in only one do
main, that of words. As a consequence, 
the nulnber of relationships between analogical 
terms decreases from three (f, 9 and h.) to two 
(f and g). Moreover, because all four terms 
intervelfing in the analogy are from the same 
domain, the domains and ranges of f and \[I 
are identical. Finally, lnorphological analogies 
can be regarded as simple equations indepen
dent of any knowledge about the language in 
which they are written. This standpoint elim
inates the need for any knowledge base or dic
tionary. 
reactor ~ rcactio.n 
.1. .L 
factor ---,I x? 
1.3 Unicity
vs Multiplicity of Changes 
Solving morphological analogies remains diffi
cult because several simultaneous changes may 
be required to tra.nsform one word into a see
ond (for instance, doer -~ undo requires the 
deletion of the suffix -er anti the insertion of 
the prefix un-). This problem has yet to be 
solved sa.tisfactorily. For example, in (Yvon 94), 
only one change at a time is allowed, and 
multiple changes are captured by successive 
applications of morphological analogies (cas
cade lnodel). However, there are cases in the 
morphology of some languages where multiple 
changes at the same tilne are mandatory, for 
instance in semitic languages. 
"One change at a time", is also found in (Na
gao 84) for a translation method, called trans
lation b 9 analogp , where the translation of an 
input sentence is an adaptation of translations 
of similar sentences retrieved from a data base. 
The difficulty of handling multiple changes is 
remedied by feeding the system with new exam
ples differing by only one word commutation at 
a time. (Sadler and Vendelmans 90) proposed a 
difl'erent solution with all algebra on trees: dif
ferences on strings are reflected by adding or 
subtracting trees. Although this seems a more 
convincing answer, the use of data bases would 
resume, as would the multiplicity of domains. 
Our goal is a true analogy-solver, i.c., an algo
rithm which, on receiving three words as input, 
outputs a word, analogical to the input, l:or 
that, we thus have to answer the hard problem 
of: (1) performing multiple changes (2) using 
a unique data-type (words) (3) without dictio
nary nor any external knowledge. 
1.4 Analogies
on \Yards 
We have finished our review of the problem an d 
ended up with what was tlhe starting point of 
our work. In linguistic works, analog:j is tie
fined by Saussure, after Humboldt and B audoin 
de Courtenay, as the operation by which, given 
two forms of a given word, and only one form 
of a second word, the missing form is coined 4, 
"honor is to honorcm as 6rator is to oratorc,z" 
noted 6r~t6rcm : 6rgitor = hon6rcm : honor. 
This is the same definition as the one given by 
Aristotle himself, "A is to B as C is to D", pos
tulating identity of types for A, B, C, and D. 
4Latin: orator (arMor, speaker) ~md bona," (honour) 
nonfinative singular, 6rat6rcmt and honorcm ~ccusative singular. 
729 
However, while analogy has been mentioned 
and used, algorithmic ways to solve analogies 
seem to have never been proposed, maybe be
cause the operation, is so ':intuitive". We (Lep
age & Ando 96) recently gave a tentative com
putational explanation which was not always 
valid because false analogies were captured, it 
did not constitute an algorithm either. 
The only work Oll solving analogies on words 
seems to be Copycat ((Hofstadter et al. 94) 
and (Hoffman 95)), which solves such puzzles 
as: abe : abbccc -ijk : x. Unfortunately it 
does not seem to use a truly dedicated algo
rithm, rather, following the AI approach, it uses 
a formalisation of the domain with such fnnc
tions as, ':previous in alphabet", "rank in 
alphabet", etc. 
2 Foundations
of the Algorithm 
2.1 The
First Term as an Axis 
(Itkonen and Hauki0ja 97) give a. prograln in 
Prolog to solve analogies in sentences, as a refu
tation of C, homsky, according to whom analogy 
would, not be operational in syntax, because it 
delivers non-grammatical sentences. That anal
ogy would apply also to syntax, was advocated 
decades ago by Hernlann Paul and Bloomfield. 
C, homsky's claim is unfair, because it supposes 
that analogy applies only on the symbol level. 
Itkonen and Hankioja show that analogy, when 
controlled by some structural level, does d.eliver 
perfectly grammatical sentences. What is of 
interest to us, is the essence of their method, 
which is the seed for our algorithm: 
Sentence D is formed by going through 
sentences B a.nd C one element at ~ time 
and inspecting the relations of each ele
mere, to the structure of sentence A (plus 
the part of sentence D that is ready). 
Hence, sentence A is the axis against which sen
tences B and C are colnpared, and by opposition 
to which output sentence D is built. 
reader: u~__~readfble = doer : x ~ x = .undoabIe 
The method will thus be: (a) look for those 
parts which are not common to A and B Oll one 
hand, and not comlnon to A and C on the other 
and (b) put them together in the right order. 
2.2 Common
Subsequenees 
Looking for colnnlon subsequences of A and B 
(resp. A and C) solves problem (o,) by comple
mentation. (Wagner & Fischer 74) is a. method 
to find longest common subsequences by com
puting edit distance matrices, yielding the min
ilnal number of edit operations (insertion, dele
tion, substitntion) necessary to transform one 
string into another. 
For instance, the following matrices give the 
distance between like and unlike on one hand, 
and between like and k~mwn on the other hand, 
in their right bottom cells: dist(like, unlike) = 2 
and dist(like, know.n) = 5 
u n l i k e k 7~ o w n 
l 1 2 2 3 4 5 l 1 2 3 4 5 
i 2 2 3 2 3 4 i 2 2 3 4 5 
k 3 3 3 3 2 3 k 2 3 3 4 5 
e 4 4 4 4 3 2 e 3 3 4 4 5 
2.3 Similitude
between Words 
We call similitude between A and B the length 
of their longest common subsequence. It is also 
equal to the length of A, minus the number of 
its characters deleted or replaced to produce B. 
This number we call pdist(A, B), because it is 
a pseudo-distance, which can be computed ex
actly as the edit distances, except that inser
tions cost 0. 
sire(A, B) = I A I pdist(A, B) 
For instance, pdist(unlike, fikc) = 2, while 
p dist(/ike, unlike) = O. 
l i k e 
u 1 1 1 1 u ll l i k e 
n 2 2 2 2 
l 2 2 2 2 l 1 1 0 0 0 0 
i 3 2 2 2 i 2 2 1 0 0 0 
k 4 3 2 2 k 3 3 2 1 0 0 
e 5 4 3 2 e 4 4 3 2 1 0 
Characters inserted into B or C may be left. 
aside, precisely because they are those charac
ters of B and C, absent from A, that we want 
to assemble into the solution, D. 
As A is the axis in the resolution of analogy, 
graphically we make it the vertical axis around 
which the computation of pseudo-distances 
takes place. For instance, for like:unlike = 
kl2ow~ : x, 
n w o n k u n I i k e 
1 1 1 1 1 l 1 1 0 0 0 () 
2 2 2 2 2 i 2 2 1 0 0 0 
2 2 2 2 2 k 3 3 2 1 0 0 
3 3 3 3 3 e 4 4 3 2 1 0 
730 
2.4 The
Coverage Constraint 
It is easy to verify that there is no solution to an 
analogy if some characters of A appear neither 
in B nor in C. The contrapositive says that, 
for an analogy to hold, any character of A has 
to appear in either B or C. Hence, the sum 
of the similitudes of A with B and C must be 
greater than or equal to its length: sire(A, B) + 
sim(A,C) >_ I A I, or, equivalently, 
I A I >pdist(d,B) + pdist(d,C) 
When the length of A is greater than the sum 
of the pseudo-distances, some subsequences of 
A are common to all strings in the same order. 
Such snbsequences have to be copied into the 
solution D. We call com(A, B, C, D) the sum 
of the length of such subsequences. The del
icate point is that this sum depends precisely 
on the sohttion D being currently built by the 
algorithm. 
To sulnlnarise, for analogy A : B = C: D to 
hold, the following constraint must be verified: 
I A I = pdist(A, B)+pdist(A, C)+com(A, B, C, 1)) 
3 The
Algorithm 
3.1 Computation
of Matrices 
Our method relies on the computation of two 
pseudo-distance matrices between the three first 
terms of the analogy. A result by (Ukkonen 85) 
says that it is sufficient to compute a diagonal 
band phts two extra, bands on each of its sides in 
the edit distance matrix, in order to get the ex
act distance, if the value of the overall distance 
is known to be less than some given thresh
old. This result applies to pseudo-distances, 
and is used to reduce the computation of the 
two pseudo-distance matrices. The width of the 
extra bands is obtained by trying to satisfy the 
coverage constraint with the value of the current 
pseudo-distance in the other matrix. 
proc compute~natrices(A, B, C, pdAB, pdAc ) 
compute pseudo-distances matrices with 
extra bands of pdAB/2 and pdAc/2 
if \]A I>_ pdist(A,B)+ pdist(A,C) 
main component 
else 
compute_matrices(A, B, C, 
tnax(\[ A \] pdist(A, C),pdAB + 1), 
lnax(\] A \] paint(A,B),pdac + 1)) 
end if 
end proc compute_matrices 
3.2 Main
Component 
Once enough in the matrices has been com
puted, the principle of the algorithm is to follow 
the paths along which longest common subse
quences are found, simultaneously in both ma
trices, copying characters into the solution ac
cordingly. At each time, the positions in both 
matrices must be on the same horizontal line, 
i.e. at a same position in A, in order to ensure 
a right order while building the solution, 1). 
Determining the patlhs is done by compar
ing the current cell in the matrix with its three 
previous ones (horizontal, vertical or diagonal), 
according to the technique in (Wagner £~ Fis
cher 74). As a consequence, paths are followed 
from the end of words down to their begin
ning. The nine possible combinations (three di
rections in two matrices) can be divided into 
two groups: either the directions are the same 
in both matrices, or they are different. 
The following sketches the al
gorithm, corn(A, B,C, D) has been initialised 
to: I A l (pdist(A,B) + pdist(A,C)), iA, iB 
and iv are the current positions in A. B and 
C. dirAn (resp. dirac) is the direction of the 
path in matrix A x B (resp. A x C) from the 
current position. "copy" means to copy a char
acter from a word at the beginning of 1) and to 
move to the previous character in that word. 
if constraint(iA, iB, ic, corn(A, B, C, D)) 
case: dirAB --dirAc = diagonal A\[:A\] 
= = Clio\] 
decrement corn(A, B, C, D) 
end if 
copy B\[iB\] + C\[ic,\]A\[iA\]:' 
case: dirAB = dirAc = horizontal 
copy c hath/min(pdist(A\[1..ia\], B\[l ..iB\]), 
pdist(A\[t..iA\]. C\[1..ic\])) 
case: dirAB = dirAc = vertical 
move only in A (change horizontal line) 
case: dirAB # dirAc 
if dirAB = horizontal 
copy B\[il~\] 
~In this case, we move in tile three words at tile 
same time. Also, the character arithnmtics factors, 
in view of generalisations, different operations: if the 
three current characters in A, B and C are equal, copy 
this character, oiherwise copy that character from B 
or C that is different from the one in A. If all current 
characters are different, this is a faihtre. 
bThe word with less similitude with A is chosen, so 
as to make up for its delay. 
731 
end 
else if dirAB = vertical 
move in A and C 
else same thing by exchanging B and C 
end if 
if 
3.3 Early
Termination in Case of 
Failure 
Complete computation of both matrices is not 
necessary to detect a failure. It is obvious when 
a letter in A does not appear in B or C. This 
may already be detected before any matrix com
putation. 
Also, checking the coverage constraint allows 
the algorithm to stop as soon as non-satisfying 
moves have been performed. 
3.4 An
Example 
We will show how the analogy like: unlike = 
known : x is solved by the algorithm. 
The algorithm first verifies that all letters 
of like are present either in unlike or known. 
Then, the minimuln computation is done for the 
pseudo-distances matrices, i.e. only the nfini
real diagonal band is computed. 
e k i l n u k n o w n 
0 1 1 1 1 1 
0 1 2 i 2 2 
0 1 2 k 3 3 
0 1 2 e 4 4 
As the coverage constraiut ix verified, the 
main component is called. It follows the paths 
noted by values in circles in the matrices. 
e k i l n u k n o w n 
@ O O I O @ @ @ 1 2 i 2@ 
1 2 k 3 ~) 
@ 1 2 e 4 (~) 
The succession of moves triggers the following 
copies into the solution: 
dirAB dirAc 
diagonal 
diagonal 
diagonal 
diagonal 
horizontal 
horizontal 
horizontal 
copy 
diagonal n 
diagonal w 
diagonal o 
diagonal n 
horizontal k 
diagonal n 
diagonal u 
At each step, the coverage constraint being veri
fied, finally, the solution x = unknown is ouptut. 
4 Properties
and Coverage 
4.1 Trivial
Cases, Mirroring 
Trivial cases of analogies are, of course, solved 
by the algorithm, like: A:A=A:x ~ x= 
A or A:A = C:x =~ x = C: Also, by 
construction, A:B= C:x and A: C= B:x 
deliver the same solution. 
With this constructi_ on, mirroring poses no 
problem. If we note A the mirror of word A, 
then A:B=C:D ~ A:B=C:D. 
4.2 Prefixing, Suffixing, Parallel 
Infixing 
Appendix A lists a numl)er of examples, actu
ally solved by the algorithm, froln simple to 
complex, which illustrate the algorithm's per
formance. 
4.3 Reduplication
and Permutation 
The previous form of the algorithm does not 
produce reduplicotion. This would be neces
sary if we wanted to obtain, for example, pin• 
v. rals in Indonesian°: orang: orang-orang = 
burung : x ~ x = burung-bu, ru.ng . In this 
case, our algorithm delivers, x = orang-burung, 
because preference is given to leave prefixes un
challged. However, the algorithna may be easily 
modified so tha.t it applies repeatedly so as to 
obtain the desired solution a. 
Permutation is not captured by the algo
rithm. An example (q with a and u.) in Proto
semitic is: yaqtilu : yuqtilu. = qataI : qutal. 
4.4 Language-independence/Co de
dependence 
Because the present algorithm performs compu
tation only on a symbol level, it may be applied 
to any language. It is thus language indepen
dent. This is fortunate, as analogy in linguistics 
certainly derives from a more general psycho
logical operation ((Gentner 83), (Itkonen 94)), 
which seems to be universal among human be
ings. Examples in Section A illustrate the lan
guage independence of the algorithm. 
Conversely, the symbols determine the gram~
larity of the analogies computed. Consequently, 
a commutation not reflected in the coding sys
tem will not be captured. This may be illus
trated by a Japanese example in three different 
5 orang (huInan being) singular, o,a,~g-oran 9 plural, 
burung (bird). 
6Similarly, it is easy to apply the algorithm in a 
transducer-like way so tlud it modifies, by analogy, parts 
of an input string. 
732 
codings: the native writing system, the Hep
burn transcription and the official, strict rec
omlnendation (kunrei). 
I(anji/Kana: ~9 : ~ ~ = {~JJ < : x 
Hepburn: motsu : machimosu. = hataraku : x 
Kunrei: matu : matimasu = hataroku : x 
x = hatarakimasu 
The a.lgorithm does not solve the first two analo
gies (solutions: {'~J 3 ~ ~, hatarakimasu) be
cause it does not solve the elementary analogies, 
: g = < : ~ and tsu:chi= ku:ki, which 
are beyond the symbol level r. 
More generally speaking, the interaction of 
analogy with coding seems the basis of a fre
quent reasoning principle: 
f(A) : f(B) = f(C) : x ¢> A:13==C : .f-' (x) 
Only the first analogy holds on the symbol level 
and. as is, is solved, by our algoritlun, f is an 
encoding fllnction for which an inverse exists. 
A striking application of this principle is the 
resolution of some Copycat puzzles, like: 
abc : abd = ijk : x ~ x= ijl 
Using a binary ASCII representation, which re
flects sequence in the alphabet, our algorithm 
produces: 
011000010110(1(11(/(111//(/011 : 0110000101.10001001100100 
OllOlO010110101001101011 : X 
--~ X : OllOlO01011010lO0110llO0 : /~\]1 
Set in tiffs way, even analogies of geometrical 
type can be solved under a convenient represen
tation. 
An adequate description (or coding), with no 
reduplication, is: 
obj(big)&~. . obj(smaIt)cobj(big)_ obj(big)g~ :x 
obj=circlc" &obj=circIc obj=squarc 
This is actually solved by our algorithm: 
obj(smalI)c obj(big) 
x = &obj=squ.are 
tOne could imagine extending the Mgorithm by 
parametrising it with such predcfincd analogical 
relations. 
In other words, coding is the key to many 
analogies. More generally we follow (Itkonen 
and Haukioja 97) when they claim that analogy 
is a.n operation against which formal represen
tations should also be assessed. But for that, of 
course, we needed an automatic analogy-solver. 
Conclusion 
We have proposed an algorithm which solves 
analogies on words, i.e. when possible it coins 
a fourth word when given three words. It re
lies on the computation of pseudo-distances be
tween strings. The verification of a constraint. 
relevant for analogy, limits the computation of 
matrix cells, and permits early termination in 
case of faihlre. 
This algorithm has bee\]\] proved to handle 
\]\]zany different cases in many different lan
guages. In particular, it handles parallel infix
ing, a property necessary for the lnorphologica\] 
description of semitic languages. Reduplication 
is an easy extension. 
This algorithm is independent of any lan
guage, but not coding-independent: it consti
tutes a trial at inspecting how much can be 
achieved using only pure COlnputation on sym
bols, without any external knowledge. We are 
inclined to advocate that lnuch in the lnatter of 
usual analogies, is a. question of symbolic rep
resentation, i.e. a question of encoding into a 
for\]\]\] solvable by a purely symbolic algorithm 
like the one we proposed. 
A Examples 
The following examples show actual resolution 
of analogies by tile algorithm. They illustrate 
what the algorithm achieves on real linguistic 
examples. 
A.1 
Latin: 
French: 
Malay: 
Chinese: 
Insertion or deletion of prefixes or 
suffixes 
or(ttoF(?D~ : OF(ItOY = \]IO~OF(:DZ : X 
X = honor 
r~prcssion : r~prcssionnairc = .rdaction : x 
x = rdactionnairc 
tinggal : k, ctinggaIan = duduk : x 
x = kedudukan 
x = ¢'~:~. 
733 
A.2 Exchange of prefixes or suffixes 
English: wolf: wolves =lcaf: x 
x = leaves 
Malay: kawan : mcngawani = kcliling : x 
x = mcngcIilingi 
Malay: keras : mcngcraskan = kcna : x 
x = mcngcnakan 
Polish: wys,vcdtcd : wysztad = poszcdted : x 
x = posztad 
A.3 Infixing and unflaut 
Japanese: ~.,5 : ~@7o = ~7o : x 
x = ~@Tz 
German: Ian9 : tSngste = scharf : x 
x = schgrfstc 
German: flichcn : cr floh = schIicflcn : x 
x = cr schlofl 
Polish: zgubiony : zgubicni = zmartwiony : x 
x = zmartwieni 
Akkadian: ukag.gad : uktanag.gad = ugal~.gad : x 
x = ugtanakgad 
A.4 Parallel infixing 
Proto-semitic: yasriqu : sariq = 9anqimu : x 
x = naqim 
Arabic: huziIa : huzal = ..sudi'a : x 
X ---8udo 
Arabic: arsaIa : mursihm = aslama : x 
x = muslimun 

References 

Robert I. Damper & John E.G. Eastman 
Pronouncing Text by Analogy 
Proceedings of COLING-96, Copenhagen, 
August 1996, pp. 268-269. 

Dedre Gentner 
Structure Mapping: A Theoretical Model for 
Analogy 
Cognitivc 5kicncc, 1983, col. 7, no 2, pp. 155
170. 

Rogers P. Hall 
Computational Approaches to Analogical 
Reasoning: A Comparative Analysis 
Artificial Intelligence, Vol. 39, No. 1, May 
1989, pp. 39-120. 

Douglas Hofstadter and the Fhfid Analogies Re
search Group 
Fluid Concepts and Creative Analogies 
Basic Books, New-York, 1994. 

Robert R. Hoffman 
Monster Analogies 
A\[ Magazinc, Fall 1995, vol. 11, pp 11-35. 
Esa Itkonen 
Iconicity, analogy, and universal grammar 
Journal of Pragmatics, 1994, col. 22, pp. 37
53. 

Esa Itkonen and Jussi Haukioja 
A rehabilitation of analogy in syntax (and 
elsewhere) 
in And%s Kert6sz (ed.) Mctalinguistik im 
Wandch die kognitivc Wcndc in Wis
scnschafi, sthcoric und Linguistik l:rankfurt 
a/M, Peter Lang, 1997, pp. 131-177. 

Yves Lepage & Ando Shin-Ichi 
Saussurian analogy: a theoretical account 
and its application 
P Ivcecdings of COLING-96, Copenhagen, 
August 1996, pp. 717-722. 

Nagao Makoto 
A Framework of a Mechanical Translation be
tween Japanese and English by Analogy Prin
ciple 
in Artificial ~( Human h~tclligcncc, Alick 
Elithorn and Ranan Banerji eds., Elsevier 
Science Publishers, NATO 1984. 

Vito Pirelli & Stefano Federici 
"Derivational" paradigms in morphonology 
Proceedings of COLING-94, Kyoto, August 
1994, Vol. I, pp 234-240. 

Victor Sadler and Ronald Vendelmans 
Pilot implementation of a bilingual knowl
edge bank 
Procccdin.qs of COLING-90, Helsinki. 1990, 
vol 3, pp. 449-451. 

Eric Steinhart 
Analogical Truth Conditions for Metaphors 
Metaphor and Symbolic Activity, 1994, 9(3), 
pp 161-178. 

Esko Ukkonen 
Algorithms for Approximate String Matching 
h~formation and CbntroI, 64, 1985, pp. 100
118. 

Robert A. Wagner and Michael J. Fischer 
The String-to-String Correction Problem 
Journal for the Associotion of Computing 
Machinery, Vol. 21, No. 1, January 1974, pp. 
168-173. 

Francois Yvon 
Paradigmatic Cascades: a Linguistically 
Sound Model of Pronunciation by Analogy 
P~vccedings of A CL-EACL-97, Madrid, 1994, 
pp 428-435. 

