Formal Syntax and Semantics of Case Stacking Languages Christian Ebert Lehrstuhl fiir Computerlinguistik UniversitSt Heidelberg Karlstr.
2 D-69117 Heidelberg Marcus Kracht II.
Matheinatisches Institut Freie Universitgt Berlin Arnimallee 3 D-14195 Berlin Abstract In this l)aper the t)henomenom of case stacking is investigated from a formM t)oint of view.
We will define a formal language with ide~dized case marking behaviour and prove that stacked cases have the ability to encode structural intbrmation on the word thereby allowing tbr unrestricted word order.
Furthermore, the case stacks help to comimte this structure with a low complexity bound.
As a second part we propose a compositional semantics for languages with stacked cases and show how this proposal may work for our tbrmal language as well as tbr an example from Warlpiri.
1 Introduction
Case stacking is a phenomenom that occurs in many Australian languages (such as Warlt)iri and Kayardild) and e.g.
Old Georgian.
Case stacking is known to pose t)roblems for the treatment of case in many fi)rmal ti'ameworks today 1.
In (Nordlinger, 1997) the problem was attacked by extending the fl'amework of LFG.
Nordlinger claims that case morphology can construct grammatical reb~tions and larger syntactic contexts.
In Section 2 we will introduce an ideal languge, which exhibits perfect marking.
This language captures Nordlinger's idea of case as constructors of grammatical relations, but is independent of any syntactic framework.
We will prove of this language that the case stacks provide all the intbrmation needed tbr reconstructing the flsnctor-argument relations and tim syntactic context a word appears in.
Additionally, since structure lies encoded in these case stacks there is no need to assume any phrase structure lsee (Nordlinger, 1997) and (Malouf, 1999) for a discussion on LFG and HPSG respectively.
or restriction on word order.
At the end of this section we consider tile computational complexity of our language and draw some conclusions about grammar formalisms that are able to generate it.
In Section 3 we propose a compositional semantics tbr our case stacking languages.
Unlike Montague semantics, where the management of variables is not made explicit, we will use rethrent systems to kee t) track of variables and to make semantic composition eflicently computable 2.
Tile proposal will be applied to our tbrmal language and to an example t'rom Warlpiri.
2 Syntax
In this section a perfectly case marked tbrmal language will be defined and investigated.
The definition of this language is based on terms consisting of functors and argmnents and tiros cases will be taken to mark arguments.
In the tbllowing we let N denote the set; of non-negative integers and ~ the concatenation of strings, which is often onfitted.
We shall use typewriter font to denote true characters in print tbr a tbrmal language.
2.1 Basic
Definitions An abstract definition of terms runs as tbllows.
Let F be a set of symbols and ~: F ~ N a flmction.
The pair {F, ~2} is called a signature.
We shall ofl;en write ~ in place of {F, f~}.
An element.f E F is called a functor and It(f) the arity off.
We let w := maxa(.f) I f E F} denote the maximal arity.
'l~rms are denoted here by strings in Polish Notation, tbr simplicity.
Definition 1.
Let ~ be a signature.
A term over ~ is inductively dc~fined as .follows.
2see (Venneulen, 1995) and (Kracht, 1999) on these issues.
250 /.
{1' ~(.1) = o, tl,.c,.
S i.,. a t('.,",,..
2. tl' ~(.1") > 0 a,.~ t~, i ~ ',: ~ ~(.1"), a,'~; terms, so 'i.'~ fl.\] .../.~(j.).
.l.h(. set C of case mart,;ers will be the sel; {l,,..., co}, which we assume t() 1)e disjoint fronl F.
(-liven a term, each t'uncl;or will 1)e case mm'kext a(:(:or(ling to l;h(: ;~rgum(ml, t)osilJon it occul)ie, s.
This is achieved throug\]~ tim notion of :~ unit, which consists of n fun(:tor ;rod ~ sequence of case m:u'kers (:;dled case stack.
Definition 2.
Let t be, a term over a siflnat'arc fL .77to corresponding bag, A(t.), is ind'actively dc/inc, d as ./b/lows.
1. tlt = .f, ~.l,.,,,.
a(-~.):= {t}.
2. s.f t -.lt,...t,,., hl,.<..,t A(t) ::: {.I'} U U'/-, {s",; I ~ ~ A(td}.
A'n oh:my.hi .f7 ~ A(t) is calh'.d a unit and q' C* its case stack.
For exmnl)h:, if .l',g~ im(l x a.re flint:tots of arity 2, 1 mtd 0, rcs\])e(:l;ively, l;he hag A(f:l:g:c) is {:f, xl, g2, xl2}.
The lllGtllillg ()t: :1.
unit Xi2 (:ould t)e (les(:rib(:(l t)y ':c is the fllllCt;Or of (;he tirsl: ~rgmnelll; t,J' the se(:on(l ;u:gmn(mI; of tim |;e t.lil ~ . Definition 3.
Let t be a tcr'm ov.r a siflnat'ur, ~..
A(t) t/,., ~:o,",',..Wo',,,li',,..,Z Z,a:t a,t(t ~X(t): : {~1 i < 'n} (tn avbitraT'y c.nv, memlio.n of its 'a',,its.
77tcn the st'rinfl dl ~'d2"~...
~-'5._.1 "-'5.
is s..id to be a A(t)-string.
Some of the A(.fxgx)-strings are (:.g.
fxig2xl2 and g2xl:fxi2.
We, m:e now l)rel)ared to d(:fine n tbrmM bmgm~ge over the alt)habet F U C t)y collecting all A(t)-si;rings for n given signature: Definition 4.
Let ~ be a signat'm'e.
The ideal ease marking language ZUAd£ ~ over this signature consists of all A(t)-strings s'ach k/taR t is a term o've'r ~.
2.2 Trees
and Unique Readability There is a strong corresl)ondence between bags and lat)elled trees sin(:e (:ase stncks can t)e identiffed with tree addrc.sscs: Definition 5.
A nonempty .linite set I) C N~_ 'is a tree domain ~f the .lbllowing h, ohh 1.
cc-D. 2.
if dl d2 cD then dl cD.
2. lJ'di ~ D, i cN then dj c D for all j < i.
Th, e.
eh:me.nts qf a t're(: domain arc called tree addresses.
A ~-labelled tree is a pai'r (1), 7) s'uch, that 1) is a tree domain and r: D -+ l" a labelling ./?re.orion s'ach, th.at th.c n'ambc.r of 'l"',:t/',t",".~' 4 d C J) i.~,',:t:acth/ ~(~(d) ).
To formalize the corresl)ondence we define a function 77' that assigns every b~g A(t) a ~hd)(:lh:d tre(:: "l'({f,7,,..., f,,,7,,}):= ({'Tff I 1 <,: < n}, ~-: 7/~ ~ .h (1 <,,: <,t)) The function 7' reverses l;he c;l.se sl;a(;ks of ~tll units to get a set of tree addresses.
Then the flmctor of the mill; is assigned to the (;rec a.ddress.
E.g. if the b:tg cont~dns i~ refit g32J_ the.
resull;ing tree dolna.in will contain :L tree address 2123 and the bflmlling flmction will ~msign 9 to iL Similarly one can define an inverse flmction assig\]dng a 1)ag |:o each ~Mal)ellexl tree.
Thus l;h(:re is a l)ije(:l;ion t)etween ~-lat)(:lled trees and bngs.
'l'\]mrelbre difthrent 1):~gs (:orr(:spond to (titfer(:nt ord(:red la,1)ell(:d trees.
This shows (;lint we h:w(: mfi(lUe r(widal)ility fi)r l)ags and sin(:(: every ZC.A4£ ~ string (:ira 1)(: mfiquely de(:()mposed into its milts we may sl;;~|;(~ the following l)rol)osition.
Proposition 6.
Let ~ bc a signature.
Then every ZC2vf£ ~ strinfl is 'aniq'acly readable.
2.3 Pmnpability
and Semilinearity We will first consider the prol)erty of being finitely pumpabh,, its detined in (Oroenink, 1997).
Definition 7.
A hm, g'aage L is finitely pumpable 'ill there is a constant c such th, at for any w C L with, \['w\[ > c, there arc a finite number k and strings uo,...
~'tt k and vt,,...,'ok s?tclt that w -uov\]u\] ?J2?t2""Ok'lt k and for each i, l < Iv/\[ < (: and for any p > 0 the string P P P 'aoV 1 'll d 't)2'a 2 • • • 'Dh'u,t; belongs to L.
Proposition 8.
Let ~ bc a signature.
Then ZC.Ad£ ~ is not finitely \])'alttpabld.
251 Pry@ It is easy to observe that the puml)able parts cannot contain a functor since that would lead to I)mnt)ed strings containing the same units more than once.
Hence the number of units cannot be increased by pumping and all pumpable parts must consist of case markers solely• But since the length of an ZC.Ad/2 f~ string consisting of a fixed munber of units is l)ounded each pumpable string could be pumped up such that it exceeds this bound.
Thus ZC.M£ a is not finitely 1)umpable at all.
\[\] Now we are concerned with semilinearity.
Definition 9.
Let M C N n.
Then M is a 1.
linear set, {f for some k C N there are u0,...,u~ ~ N '~, such, that M = {u0 + k N}, ~i=i niui \[ ni C 2.
semilineav set, if for" some t~: C N there are linear sets M\], •.
•, Mk C _ N 'z, such th, at M=U i=1 A lan.quage L over" an alphabet E = {wi I 0 _< i < n} is called a semilinear language if its image under the Parikh mapping is a semilinear set, where the PariMt mapping ~IJ : E* ~ N n is defined as follows: <o,,...,o) wi ~ e (i) .fi)r O < i < n or/3 ~ vI,((~) -F'I'(fl) for all ~,fl C E* wh, ere e (i) is the i + 1-ttL 'unit vector', wh, ich, consists of zeros except for the i-th component, wh, ich, is 1.
Note that given a term t the Parikh image of all A(t)-strings is the same since these are just concatenations of difthrent permutations of the units in A(t).
In the tbllowing we make use of a proof technique used in (Michaelis and Kracht, 1997) to show that Old Georgian is not a semilinear language.
We cite, a special instance of a proposition given therein: Proposition 10.
M be a subset of the properties 1.
For" any I~: E l~) 1(k) Let P(k) =,~k 2 + 2~-----~-k and N n, where n > 2, which has N+ there are some numbers E N for wh, ich the n-tuple (k, P(k),l~ k) I (k) \ belon(ls to M.
~''" ~ '~--11 2.
For" any k C N+ th, e value P(k) provides an upper bound .for th, e second component l\] of any n-tuple {k, ll,,...,l~z-1) E M (that means ll _< P(k) ./'or" any such n-tuple).
Then M is not semilinear.
In order to investigate the semilinearity of ZC,A'I/£ a we choose distinct symbols f, x C F, such that f/(f) = w and ~2(x) = 0.
We shall construct terms si by the following inductive definition: 1.
s0:=x 2.
Sn := f(sn-l,x,,...,:c) fbr n > 0 It is easy to observe that by virtue of construction sn consists of n leading functors f and that in each iteration the number of x increases t)y 1).
Lemma 11.
Let F U C = {f,\],:c,2,,...,w, fl,,-..,.flFI-2} be an enumeration of the alphabet underlying ZCA,4£ ~, where f\],,...,f1I,'1-2 are the remainin.q fl, nctor's in F {.f, z} Then the Parikh image of some A(sn)-strin9 5n is 2--60 = (.,, 2n 2 + -5--" (w--1)n+l,n,,...,n,O,,...,()) ~-1 IFI-2 Furthermore, ~ 2 '~n + ~n imposes a,n upper bound on the second component oof vIl(Sn).
Proof. The first part of the leunna can be proved in a straightforward way by induction on n.
The claim on the upper bound ibllows ii'om the observation that the nmnber of occurrences of case marker 1 can be maximized t)y repeated embedding of terms in the first arguinent position.
\[\] Proposition 12.
Let ft be a signature.
Th, en 27CAd£ f~ is not semilinear.
Proof. Let n = w + IF I and consider the linear, and hence semilinear, set R := 1) + 1)e (2) + w+2 hie(0 I m c 252 Then (;lit fllll pre, iniage Lh> of 17, under the Parikh niap consists of all strings which contain nu((w -1) + 1) occurrences of the symbol x (where 'n,2 is any number) and any number of occurrences of the symbols f, l,,...,w, and no other symbols.
We define the language Lj7 as the set of all strings belonging to Lst and the ideal case marking languages.
Then LM contains all A(s,)-strings.
Considtring the Parikh iniage M of LAf we gel; M =,I,\[CAd = m,I,\[ZCaaC = cq,I,\[IC54Z; because of the (lefinition of Llz as the flfll preimage of 1.
But then the set A// fultills the conditions of Prot)osition l 0 (tuc to \]xeillilla 1\].
Hence M is not sere|linear.
Since 17, is sere|linear 1)y definition and semilinearity is closed under intersection ZCAd£ t? is not sere|linear.
\[\] 2.4 Computational Complexity In this sul)section the COml)utai;ional (:onll)lexity of ZCJ%4£ ~ is (:onsidere(t.
r\]Jh(', results are achieved by defining a 3-tat)e-rl)uring machine accet)tor (det)ending on a given signature) that recognizes Zg3d£ ft.
Proposition 13.
Let tt be a,sig'natv, rc.
7Turn IcM£ c #)TS ME(,.,v&7 log % ZCM£ ~ C DSI'ACE('n,).
l'roo\]: In the following we lc, t 'n denote the hmgth of the inlmt string.
The 9~u:ing machilm algoril;hln can be subdivided into three main parts: 1.
The intmt string is segmentext into its units: The algorithm steps through the input and adds set)aration markers in 1)etween two units.
This can be done in O(n) time.
2. The llllits are sorted according to their case stacks: More tbrmally a 2-way straight rnc,#c sort is pertbrnmd.
This sorting algorithm is known for its worst case optimal complexity: it peril)tins the sort of ti: keys in O(klogk) steps.
In our case the keys are milts and thus their mnnl)er is clearly tmml(led by ~t..
Tim additional square root factor comes from the comparison stel).
One can show tha|; the maximal length of a (:ase sta('k occuring in an ZOJ~£ ~I string of Mlgth 'n is l)ounded above by O(v/77,).
Hence a comparison of two units takes at most O(v/77,) steps.
Thus the overall comt)lexity of the sorting part is O(nv/77 log 'n).
3. The sorte<l stquen<:e of units is (:hecked: The algorithm successively generates case stacks according to the fimctors it has read.
Each case stack is compared to the refit of the inlmt.
If they coincide the algorithm advances to the next unit on the input and generates the next case stack.
After all case stacks have been gel/erated the whole int)ut string must have been worked through, in this case the algorithm a(:cet)ts.
This (:an l)e done in O('n,) time.
Summing u t) the COml)lexities of these tln'ee l)arts shows that the time COml)lexity is as claimed in the proposition.
1;'urthel'nmre, the algorithm uses only the cells needed by the inlint plus at most t;:l (:ells tbr additional set)aration markers (due to the first part), where t,: is the nunlber of units the inlmt string consists of.
This shows thai; |;he space (:omph~xity ix linenr.
\[\] 2.5 Discussion A first ('on('lusion we lllay draw ix that cases btve the ability to (:onstruct the context they apl)em: in.
ZCML ~ strings encode the same structural intbrmation as ordered labelled trees do thereby allowing unconstrained order of milts.
Additionally each such string can be read unambigously.
This was shown by means of a bijtction l)etween bags and ordered labelled trees.
The fact that ideal case marking hmguages are neither finitely punq)at)le nor sere|linear means that they fall out of a lot of hierarchies of formal languages.
As (Weir, 1988) shows, multicomponent trcc adjoining 9ramm, aTw a generate only sere|linear languages.
Consequently, ideal case marking languages are not MCTALs.
However, (Groenink, 1.997) defines a class of grammars, called simple literal movement grammars, aand henc.c line.at con|ca;t-free rewrite systems, which are shown to l)e weakly equivalent to MCTAGs in (Weir, 1988) 253 which generate all and ouly the PTIME recognizable languages.
Ideal case marking languages should therefore be generated by some simple literal movement grammar.
We note fltrthermore that the (theoretical) time complexity is significantly better than the best known for recognizing context-free grammars.
In fact, we implemented a practically applicable algorithm which constructs the corresponding tree out of a given IC.Ad£ n string in linear time (in average).
3 Semantics
We are now going to propose a semmltics tbr languages with stacked cases.
The basic principle is rather easy: we are going to identify variables by case stacks thereby making use of referent systems.
3.1 Referent
Systems The semantics uses two levels: a DRS-level, which contains DRSs, and a referent level, which talks about the names of the refbrents used l)y the DRS.
Referent systems were introduced in (Vermeulen, 1995).
We keep the idea of a referent system as a device which adnfinistrates the variables (or referents) under merge.
Tile technical apparatus is however quite difli;rent.
In particular, the referent systems we use define exl)licit global string sul)stitutions over the referent names.
There is one additional symbol o.
It; is a variable over names of referents.
If we &SSUlne that a flmctor g has meaning g a simple lexical entry for g looks like this: /g/ I o:o I o g(1, a(g) o) Here, the upper part is the ret~rent system, and the lower part an ordinary DRS, with a head section, containing a set of referents, and a body section, containing a set of clauses.
This means that the semantics of a functor g is given by the application of g to its arguments.
However, instead of variables z, !/, etc.
we find 1~o, 2~'o, etc.
The semantics of a 0-ary functor z and a case marker, say 2, are: /2/ \[o2-o When two such structures come together they will be mcr.qcd.
The merge operation (9 takes two structures and results in a new one thereby using the retbrent systems to substitute the nmnes of referents if necessary and then taking the union of the sets of clauses.
E.g. the result of the merge/g/ (9 /2/ is /g2/ I 0:0 g(12 o, Tile meaning of o : 2r'o is as follows.
If some structure A is merged with one bearing that referent system, then all occurrences of the variable o in A are replaced by 2~o.
As the resulting rcti;rent system we get o : o.
This is exactly what is done in the merge shown above.
We shall call a structure with referent system o : o plain.
Merge is only defined if at least on structure is t)lain.
3.2 Semantics
for .ZC.Ad£ To see how the semantics works we shall reproduce an earlier example ~md take the ZC3dZ; f~ string g2xlfxl2.
Motivated by the definition of the ideal case marking language we shall agree to the conventions that 1.
Case markers may only be suffixes 2.
Case markers may only be attached to flmctors or case marked flmctors By these conventions the string under consideration must be parsed as (g2)(xl)(f)((xl)2).
They force us to combine tile fimctors with their case stacks first and afterwards combine the units.
We shall understand that this is a syntactic restriction and not due to any semantics.
The composition of g and 2 was already shown above and is repeated on the left hand side, using that ft(g) = 1.
The result of composing x and 1 is shown to the right.
254 /g2/ /xl/ o:o \] I o:o "-'O 2~o -g(12 ) 1~o -x Merging these two structures we get /g2~1/ o:o ~3 2~o -g(12~o) 1~o----" x Together with f this gives /g2xl~/ o:o 2~o ---g(12~o) l~o--x o = f(l~o, 2~o) By coml)osing the strucl;ures for x an(1 1 we get; the structm:e /xl/shown above.
We merge this one with that for 2 and get /~12/ o:o t ° 12~o -x The merge of l;h(; two sl;rucl;ures abov(; tinally gives /g2~,fx12/ 0:0 12~o -x 2~o -g(12~o) 1~o----" x o ----" f(1~o,2~o) We shall verify that the wflue of o is a(:tually the same as the value of f(x, g(x)).
Notice first that in the body of the DRS we find that 12~o and 1~o have the same value as x.
We may theretbre reduce the body of this structure to 2~o g(x) o -f(x, 2~o) Finally we m~\y replace 2~o by g(x) in the second line.
We gel; then o f(x, g(x)) whi(:h is the intended result.
After |;lit semantics of the mdts has been comlmted the order of merge is mdml)ortant.
If we (:hoose to merge these semantics in an order dif ti;r(;nt from the one above, we get the same result.
a.a An example from Warlpiri To show how this proposal may work for naturM languages we give an example fi'om Warlt)iri 4 in which (:as(; stacking oc(:urs.
We have to deal wit, h l;he t bur case markers ergative (ERe), past tense (PST), absolutive (ABS), and locative ((Loc).,lapanangl;:a-rlu Iuwa-rnu marlu Japanangka-ERg shoot-PST kangaroo-ABS pirli-v,.qka-rlu rock-LOC-ERG,lat)anangka shot the kangaroo (while) on the ro ck \¥e extend the t)roposal by taking into account that cases may not only flmction as argumind; markers but have a semantics, too.
This actually does not make much of a diflhrence for l;his calculus.
We propose the tbllowing semantics for the locative and the past tense case lllarker ILocl /psi/ o : LOC~o I ° located (o, LOC o) o:o past'(o) St), when the locative is attached, it; says that the thing to which it; attaches is located somewhere.
Here, o represents the thing that is locaLe(l, while I,OC~o is the location.
The past tense semantics simply says that the thing which it attaches to happened in the past.
We construe the meaning of the ergative as being the actor and the meaning of the absolutive as being the theme s.
dThis examl)h; is taken front (Nordlinger, 1997), p.171 '~In fact, ergative and absolutive should mark for grammatical flmctions, but since linking of grammatical functions and actants is quite a complicated matter (see (Kracht, 1999)) we make this simplification.
255 /ERe/ o EI\],G~ o actor'(o) --" ERC~o Again, we shall agree /ABS/ o : ABS'-'o 2~ theme'(o) AB8~o nl using the conventions stated in subsection 3.2.
First we have to attach the case markers to compose the resulting structures afterwards.
The semantics of the proper noun Japanangka is taken to be a plain structure with body o "-japanangka'.
The composition of this structure and the ergative semantics yields /,Japanangka-ERG / o:o ER.G~o ~ japanangka' actor'(o) -En.G~o We assmne that the nominals /pirli/ and /marlu/have the following lexical entries: /pirli/ /marlu/ o-o {o} rock'(o) o:o I {o} kangaroo'(o) Thus the semantic composition of pirli, LOG and ERG gives: / pirli-LOC-ERG / o:o rock'(LOC~ERC~o) actor'(o) -EROde Iocated'(ERC~o, LOC~EnO~ o) Similarly we can compose marlu with the absolutive case: /marl'a-aBS/ o:o {ABs o} kangaroo'(ABS~o) theme'(o) -ABS~o The semantics of the verb is shown on the left hand side and its composition with /PST/ on the right hand side.
/ l'a al I o:o I °1 sheet'(o) Iluwa-PST/ o:o shoot'(o) past'(o) Finally by inerging tile structures/JapanangkaERe~, /ma,+a-*BS/, /pi 'liLOC-ER,G/ ill rely order, we get tilt following result.
o:o {ABS~o, LOC~ER.G~o} ERG~'o -japanangka' shoot'(o) past'(o) actor'(o) ----" ERG~'o theme'(o) -ABS~o kangaroo'(ABS~o) rock'(LOC~ERO~-'o) Iocated'(EIC~o, LOC'-'Elm'-" o) It says that there was an event of shooting in the past, whose actor is 3apanangka and whose theme ix something that ix a kangaroo, and that there is a rock, such that Japanangka is located on it.
Note that the only syntactic restriction were the conventions stated in subsection 3.2 and thai; we (lid not make any fllrther assumptions on syntactic structure or word order.

