Deriving Transfer Rules from Dominance-Preserving Alignments 
Adam Meyers, Roman Yangarber, Ralph Grishman, 
Catherine Macleod, Antonio Moreno-Sandoval* 
New York University 
715 Broadway, 7th Floor, NY, NY 10003, USA 
tUniversidad Autdnoma de Madrid 
Cantoblanco, 28049-Madrid, SPAIN 
meyers/roman/grishman/macleod©cs, nyu. edu 
sandoval©lola.lllf.uam.es 
1 Introduction

Automatic acquisition of translation rules from 
parallel sentence-Migned text takes a variety of 
forms. Some machine translation (MT) svstems 
treat aligned sentences as unstructured word se
quences. Other systems, including our own ((Gr
ishman, 1994) and (Meyers et al., 1996)), syn
tactically analyze sentences (parse) before ac
quiring transfer rules (cf. (Kaji et al., 1992), 
(Matsumoto et al., 1993), and (Kitamura and 
Matsumoto, 1995)). This has the advantage of 
acquiring structurM as well as lexical correspon
dences. A syntactically analyzed, aligned cor~ 
pus may serve ~s an example base for a form of 
example-based NIT (cf. (Sato and Nagao, 1990), 
(I{aji et al.. 1992), and (Furuse and Iida. 1994)). 
This paper I describes: (1) an efficient algo
rithm for aligning a pair of source/target lan
guage parse trees; ~nd (2) a procedure for de
riving transfer rules from this alignment. Each 
transfer rule consists of a pair of tree fragments 
derived bv "cutting up" the source and target 
trees. A set of transfer rules whose left-hand 
sides match a source language parse tree is used 
to generate a target language parse tree from 
their set of right-hand sides, which is a transla.
tion of the source tree. This technique resembles 
work on MT using synchronous Tree-Adjoining 
Grammars (cf. (Abeille et al., 1990)). 
The Proteus translation system learns transfer 
rules from pairs of aligned source and target reg
ularized parses, Proteus's representation of pred
icate argument structure(cf. Figure 1)? Then 
it uses these transfer rules to map source lan
L We thank Cristina Olmeda Moreno for work on pars
ing our Spanish text. This research was supported by 
Nat, ional Science Fotmdat.ion Grant, \[R.\[-9303013. 
2Regularized parses (henceforth, "pmse trees") are 
like F-structures of Lexical }"tmctiou Grammar (LEG), 
except, that a depenclency st.ruct.ure is used." 
guage regularized parses generated by ou r source 
language parser into target language regularized 
parses. Finally a generator converts target reg
ularized parses into target language sentences. 
All Mignment f is a I-to-1 partial mapping 
from source nodes to target nodes. We con
sider only alignments which preserve the dom
inance relationship: If node a dominates node 
b in the source tree. then f(a) dominates f(b) 
in the target tree. In Figure 1. source nodes ,4. 
B, C and D map to the corresponding target 
nodes, marked with a prime, e.g., f(A) = A'. 
The alignment )nay be represented by the set 
{(A, A'), (B, V'), (C', C'). (D, D')}. We ~.an as
sign a score to each Mignment f, based on the 
(weighted) number of pairs in f; finding the best 
alignment translates into finding the alignment 
with the highest score. Our algorithms are based 
on (Farach et al., 199.5) and related work. 
We needed efficient alignment algorithms be
cause: (1) Corpus-based training requires pro
cessing a lot of text; and (2) An exhaustive 
search of all alignments is too computationally 
expensive for realistically sized parse trees. 
Eliminating dominance violations greatly re
duced our search space. Similar work (e.g., 
(Matsumoto et al., 1993)) considers ~dl possible 
matches. Although. our system cannot ¢~ccount 
for actual dominance violations in a given bi
text, there are no such violations in our corpus 
and many hypothetical cases can be aw)ided by 
adopting (;he appropriate grammar. Cases of ad
juncts aligning with heads and vice versa are not 
dominance violations if we replace our depen
dency analysis with one in which internal nodes 
have category labels and the head constituents 
are marked by HEAD arcs and we assume the 
following CategoriM Grammar (CG) style anal
yses. Suppose that verb (VI.) maps to adverb 
(A'I) and adverb (A2) maps to verb (V'2), where 
843 
Source Tree Target Tree 
("D = volver ~ ...................... -a~ 
...................... 
Excel vuelve a calcular vaiores en libro de trabajo Excel recalculates values in workbook 
Figure l: A Pair of Aligned Trees 
A2 modifies V1 and A'I modifies V'2. We as
sume the following structures: \[VP \[VP1 V1 ...\] 
A2\] and \[VD \[VP2 V'2 ...\] A'I\]. No dominance 
violation exists because no dominance relation 
holds between V1 and A2 or V'2 and A'I. Y. 
Matsumoto (p.c.) notes that the subordinate 
clause of a source sentence may align with the 
main clause of a target language and vice versa, 
e.g., X after Y aligns with Y' before X'. where 
X, X', Y and Y' are all clauses. Assuming a CG 
style analysis, \[S X \[after Y\]\] aligns with \[S Y" 
\[before X'\]\] with no dominance violations. 
2 The
Least-Common-Ancestor 
Constraint 
Our earlier tree alignment algorithms (cf. (Mey
ers et al., 1996)) were designed to produce align
ments which preserve the least common ancestor 
relationship: If nodes a and b map into nodes 
a' = f(a) and b' = f(b), then I(LCA(a,b)) = 
LCA(I(a), f(b)) = LCA(a',b'). The least com
mon ancestor (LCA) of a and b is tile lowest node 
in the tree dominating both a and b. The LCA
preserving approach imposes limitations on the 
quality of the resulting alignments. In Figure l, 
the LCA-preserving Mgorithm will match node 
I:2 with node D' and report that as the best match 
overall. The score S(D, D') would take into ac
count only the match (E, D'), which in turn in
cludes (B, B') and (C, C'). (S(D, D') would be 
penalized for collapsing the arc from D to E.) 
We seek a better alignment scheme, in which 
the score S(D, D') could benefit from S(A, A'). 
We are willing to pay a small penalty to collapse 
the path from D to E, and align the resulting 
structure. This leads to new algorithms where 
the LCA-preserving restriction is replaced by the 
weaker, dominance-preserving constraint. The 
rationale behind allowing an edge, say (v, u) to 
be collapsed when matching two nodes v and v'. 
is that we may find some children of u which cor
respond well to some children of v', while other 
children of ~, correspond well to other children of 
v'. (This is not possible if LCA's are preserved.) 
The algorithm relies on the assumption that two 
different children of v will not match well with 
the same child of v'. 
3 The
Dominance-Preserving 
Algorithm 
Let T and T ~ be the source and the target trees. 
We use a dynamic programming algorithm to 
compute, in a bottom-up fashion, the scores for 
matching each node in T against each node in T'. 
There are O(n 2) such scores, n = max(IT\], \]T'l) 
is number of nodes in the trees. Let the d(v) be 
the degree of a node v. We denote children of t, 
by vl, / = 1,..., d(v), and arc (v, vi) by ffi. 
For all pairs of nodes v E T and v' E T', the 
algorithm computes the score function S(v, v'). 
S(v, v') corresponds to tile best match found be
tween the subtrees rooted at v in T and at v' in 
T'. The values ors are stored in a IT\[ x IT'I ma
trix, also denoted by S. Initially, we fill the ma
trix S with undefined values, and invoke the pro
cedure SCOREdo~, described below, to con> 
pute S(root (T), root(T')), the score for matching 
the root nodes of the trees. During the compu
tation of the score for the roots, the procedure 
recursively finds the best-scoring matches for all 
the nodes in the trees. This yields the best align
ment of the entire trees. 
Table l(a) shows tile values of S for the trees 
in Figure 1. Whenever we compute a score for 
internal nodes, we also record the best way of 
pairing up their children in Table t(b). 3 Tile 
a Children pairings include child/child pairs and par
ent/child pairs: (D.D')'s pairing is {(A, A'), (E, D')}. 
844 
alignment, implicit in these children pairings, is 
used in a later phase (Section 4) to recover the 
alignment for the entire trees. 
Procedure SCOREgo,~: For a pair of nodes, 
(v, v'), recursively compute the score S(v, v'): 
Construct an intermediate child-scoring ma
trix M = M(v,v'), for the children of v and v'; 
the dimensions of M are (d(v) + t) x (d(v') + 1). 
That is, the number of rows in M is one more 
than the number of children of v, and the number 
of columns is one more than number of children 
of v'. We label row d(v) + t and column d(v') + 1 
with a "*" Fill the matrix M: 
1. Vi, j, where 1 <_ i <_ d(v),l <_ j <_ d(v') 
compute the corresponding entry in ,g\[ij: 
The function Lex,~o&(V,v') > 0 (used be
low) is the quality of translation, i.e. the 
measure of how closely the label (word) at 
source node v corresponds to the label at 
target node v ~ in the bilingual dictionary, 
and Lex,~(ff, if') >_ 0 is the corresponding 
measure for arc labels. 
2. Fill the last colurnn as follows: Vi, where 
t _< i < d(v) compute the entries: 
Pen(iY4) > 0 is the penalty for collapsing tile 
edge ffi, which depends on tile value of tile 
label of that edge. 
3. Symmetrically, gj s.t. 1 _< j < 
d(v') fill the last row with the entries: 
M.s = 
4. The entry M.. is disfavored: ,~,l.~ = -:x) 
For example, during the calculation of the 
scores S(D, D') and S(E, D') from Table t, the 
corresponding matrices M ( D, D') and :'vl ( E, D') 
are filled in as in Table 2. The proper values for 
the parameter fimctions used above, such as tile 
penalty function Pen and the translation mea
sures, are chosen empirically, and constitute the 
tunable parameters of the procedure. Normally, 
we will expect that the values of Lexnod~ will be 
much larger than the values of Le:r.~,.~: and Pen. 
In the example we used the following settings: 
\[. Lex,~od~ = 100 for an exact translation, as for 
(A, A'), (B, B;) and (C, C'), and 0 otherwise. 
2. all values of Lex~c are set to zero 
3. all penalties Pen are set to 1 
Now, using the values in M, compute the score 
for matching v and v': 
S(v,v') = Lex,~o&(v,v')+ max ~ Mij (\[) PEEP 
(i,j)eP 
Here P is a legitimate pairing of v and its chil
dren against v' and its children. A legitimate 
pairing P is a set of elements of the matrix M. 
that conform to tile following conditions: 
1. each row and each column of M may con
tribute at most one element to P, except 
that the row and the column labeled * may 
contribute more than one element to P 
2. if P contains an element Mij correspond
ing to the node pair (to, w~), and some child 
node u appears in the Children-Pairing for 
(w, w'), then the row or column of u may 
not, contribute any elements to P. 
We use £79 = £/)(v, v') to denote the set of all 
legitimate pairings. There are O(d!) such pair
ings, where d is the greater of the degrees of v 
and #. The sunlmation in (1) ranges over all 
the pairs (i,j) that appear in a legitimate pair
ing P E £79(v, v'). We evaluate this summation 
for all O(d!) legitimate pairings in /279, and then 
) select the pairing \[best with the maximum score. 
/3)¢~ is then stored in the Children-Pairing ma
trix entry for (v, v'). 
Table 2 shows how scores are calculated. The 
best score for S(E, D') is 200, tile sum of the 
scores for (B, B') and (C,C'). S(D, O') = 
299 = S(A, A') + S(E, D') 1, a penalty of 1 
for collapsing tile edge from D to E. 
We can reduce the computatJon time of the 
max term in (1), if we do not consider all O(d!) 
pairings of the children of v and #. Instead 
of exhaustively computing the maximal-scoring 
pairing Pbe.~t in (1), we can build it in a 9reedy 
fashion: successively choos the d highest-scoring, 
mutually disjoint pairs from the O(d "2) possible 
pairs of children of v and v'. 
1. Initialize the set. of highest scoring pairs 
2. Pb~,.,, +Pb~.~eu{(i, j)} where Mij is the next 
largest entry in the matrix, which that sat
isfies both conditions 1 and 2 of legitimate 
pairings 
845 
Source 
Nodes 
A 
B 
C 
D 
E 
F 
Target Nodes 
A' B' C' 
100 0 0 
0 100 0 
0 0 100 
0 0 0 
0 0 0 
0 0 0 
D ~ A ~ 
0 A

0 B

0 Source
C 
299 Nodes D 
200 E 
0 F

Target Nodes 
B' C' DI 
(,4, A') ( S , o') 
( B, B')(C, C') 
Table l: (a) A Final Score Matrix: (b) Children-Pairing Matrix 
Source 
Chil
dren 
Target Children 
t: ,4' 2: B' 3: C' *: D' 
1: B 0 100 0 99 
2: C' 0 0 100 99 
*: E 0 99 99 -~c 
'The Score S( } = 100 + 1.00 = 200 
~ource 
Chil
dren 
Target Children 
t: .4' 2: B' 3: C' *: D' 
t: A 100 0 0 99 
2: E? 0 99 99 199 
*: D 99 98 98 -:v 
The Score S( ) = 199 + 100 = 299 
Table 2: Computing Child-Scoring Matrices 
3. Repeat the above step until no more pairs 
can be added to Pb~t, at most d times. 
where d = min(d(v), d(v')). 
4. Compute the result: 
S(v, "v') = LeXnode(U, v') + ~(i,j)ePb..~, *~/\[ij 
The greedy algorithm aligns trees with n 
nodes and maximal degree d in O(n2d 2) time. 
4 Acquiring
Transfer Rules 
This section describes the procedure for deriving 
transfer rules from aligned parse trees. 
First, the best-scoring Mignment is recovered 
from the Children-Pairing matrix, (Table l(b)). 4 
Start by including the root node-pair in the 
alignment, (here (D, D')). Then, for each pair 
(v, i/) already in the alignment, repeat the fol
lowing steps, until no more pairs can be added to 
the alignment: (t) look up the Children=Pairing 
for (v.v'); (2) for each pair in the children
pairing, if it does not include either v or v', add 
the pair to the alignment, (e.g. (,4, ,4'), etc.). 
4When sentences in the bitext have multiple parses, 
we align structure sharing forests of trees. \[f one pair 
of trees has the highest scoring alignment, we acquire 
transfer rules from that alignment. When more than one 
pair of trees tie for the highest score, we acquire t.ransfer 
rules from the set of pairs of aligned subtrees which are 
shared by each of these high scoring alignments. 
In tile running example, the final align
ment (t:A)is {(D, D'), (A, A'), (B, S'), (C, C')). 
Based on this Mignment we can "chop up" the 
trees into fragments, or substructures ((Mat
sumoto et al., 1993)), where each substructure 
of a tree is a connected group of nodes in the 
tree. together with their joining arcs. In Fig
ure 1, dashed arrows connect aligned pairs of 
source and target substructures. These corre
spondences become our transfer rules. 
\[rot" each pair of aligned nodes (v, v') in F,4, 
there is a pail' of substructures hi Figure l such 
that v and v / are the roots of the source and tar
get substructures. These substructures include 
all unaligned source and target nodes v~ and 
vl~ below v and v', which have no intervening 
/ aligned nodes y or y' dominating .v~ or v,. 
The transfer rules derived from Figure \[ may 
be written as follows: 
f. < root : Excel > -+ < root : Fxcel > 
2. < root : valores > -* < root : values > 
3. < root : libro, de : trabajo > --+ < root 
workbook > 
4. < root : volver, aubj : zl,a :< root 
calcular, obj : x2,en :x3 >> --+ 
< root : recalculate, subj : Tr(:ct),obj 
Tr(x2), in: Tr(xa) > 
Each substructure is represented as a list con
846 
taining a root lexical item, and a set of arc
value pairs. An arc (role) al with head (value) 
h is written as al : h, where h is a fixed la
bel (word), a substructure or a variable. If the 
source substructure has n of the leaves labeled 
with variables zl, ...,zn, the target will have 
n of the leaves labeled with Tr(xl),...,Tr(xn), 
where Tr(x) is the lexical translation function. 
This general structure allows us to capture re
lations between multi-word expressions in the 
source and target languages. 
5 Translation

The described procedure for acquisition of trans
fer rules from corpora is the basis for our trans
lation system. A large collection of transfer rules 
are collected from a training corpus. When new 
text is to be translated, it is first parsed. The 
source tree is matched against the left hand sides 
of tile transfer rules which have been collected. 
If a set of transfer rules whose left-hand sides 
match tile parse tree is found, the corresponding 
target structure is generated from the right hand 
sides of these transfer rules. Typically, several 
sets of transfer rules meet this criterion. They 
are ranked by their frequency in the training cor
pus. Once a target tree has been produced, it is 
conve.rted to a word sequence by a target lan
guage generator. Vv% have applied this approach 
to the translation of Microsoft l-lelp files in En
glish and Spanish. The sentences are moderately 
simple and quite parallel in structure, which has 
made the corpus suitable for our initial system 
development. To date, we have been using a 
training corpus of about 1,000 sentences, and a 
test corpus of about 100 sentences. 
6 Evaluation

Real eva.luation of performance of MT systems 
is time consuming and subjective. Neverthe
less, some evaluation system is needed to insure 
that incremental changes are for the be~/er, or 
at least, are not detrimental. We measured the 
success of our translation by how closely we re
produced Microsoft's English (target language) 
text. Our evaluation procedure computes the 
ratio between (a) the complement of the inter
section set of words in our translation and the 
actual Microsoft sentence; and (b) the combined 
lengths of these two sentences. An exact trans
lation gives a score of 0. If the system generates 
the sentence "A B C D E" and the actual sen
tence is "A B C F", the score is 3/9 (the length 
of D E F divided by the combined lengths of 
A B C D E and A B C F.) The dominance
preserving version of the program produced out
put for 88 out of 91 test sentences. The average 
score for these 88 sentences was 0.29:0.21 due 
to incorrect word matches and 0.08 due to failure 
to translate because insufficient confidence levels 
were reached. The LCA-preserving version pro
duced output for only 83 sentences with an aver
age score of over 0.30: about 0.23 due to incor
rect word matches and about 0.08 due to insuffi
cient confidence levels. This crude scoring tech
nique suggests that the dominance-preserving al
gorithm improved our results: more sentences 
were translated with higher quality. One limita
tion of this scoring technique is that paraphrases 
are penalized. An imperfect score (even .20) 
may signify an adequate translation. 

References 

A. Abeille, Y. Schabes. and A. K. aoshi. 1990. 
Using Lexicalized Tags for Machine Transla
tion. In COLING90. 

M. Farach, T. M. Przytycka, and M. Thorup. 
1995. On the agreement of many trees. Infor
mation Processing Letters, 55:297--301. 

O. Furuse and H. \[ida. 1994. Constituent 
Boundary Parsing for Example-Based Ma
chine Translation. In COLINGOg. 

R. Grishman. 1994. Iterative Alignrnent of Syn
tactic Structures for a Bilingual Corpus: In 
Proceedin9s of the Second A,nual Work'shop 
for Very Lar9e Corpora, Tokyo. 

H. Kaji, Y. Kids. and Y. Morimoto. 1992. 
Learning Translation Templates from Bilin
gual Text. In COLING92. 

M. Kitamura and Y. Matsumoto. 1995. A Ma
chine Translation System based on Transla
tion Rules Acquired from Parallel Corpora. In 
RANLP95. 

Y. Matsumoto, H. Ishimoto. T. Utsuro, and 
M. Na.gao. 1993. Structural Matching of Par
allel Texts. In ACLg3. 

A. Meyers, R. Yangarber, and R. Grishman. 
1996. Alignment of Shared Forests for Bilin
gual Corpora. In COLING96, pages 460-465. 

S. Sato and M. Nagao. 1990. Toward Memory
based Translation. In COLING90, volume 3, 
pages 247-252. 

