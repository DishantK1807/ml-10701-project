DCKR -Knowledge Representation in Prol0g and Its Application to Natural Language Processing Hozumi Tanaka Tokyo Institute of Technology Dept.
of Computer Science O-okayama, 2-12-1, Megro-ku Tokyo, Japan ABSTRACT: Semantic processing is one of the important tasks for natural language processing.
Basic to semantic processing is descriptions of lexical items.
The most frequently used form of description of lexical items is probably Frames or Objects.
Therefore in what form Frames or Objects are expressed is a key issue for natural language processing.
A method of the Object representation in Prolog called DCKR will be introduced.
It will be seen that if part of general knowledge and a dictionary are described in DCKR, part of contextprocessing and the greater part of semantic processing can be left to the functions built in Prolog.
1. Introduction Relationships between knowledge represented in predicate logic formulas and knowledge represented in Frames or ~Kt~i~K~ fihi~i~ are clarified by \[Hayes 80\], \[Nilsson 80\], \[Goebel 85\],\[Bowen 85\], et al, but their methods requires separately an interpreter for their representation.
The authors have developed a knowledge representation form called DCKR (Definite Clause Knowledge Representation) \[Koyama 85\].
In DCKR, each of the ~i~%~ composing of a Structured Object (hereinafter simply called an ~hJ~Gi) is represented by a Horn clause (a Prolog statement) with the "sem" predicate (to be explained in Section 2) as its head.
Therefore, an Object can he regarded as a set of Horn clauses (slots) headed by the sem predicate with the same first argument.
From the foregoing it follows that almost all of a program for performing semantic intepretations relative to lexical items described in DCKR can be replaced by functions built in Prolog.
That is, most of programming efforts of semantic processing can be left to the functions built in Prolog.
DCKR will be described in detail in Section 2.
Section 3 will discuss applications of DCKR to semantic processing of natural languages.
2. Knowledge Representation in DCKR The following examples of knowledge representation in DCKR will be used in Section 3 and later.
:-op(lO0,yfx,'~'), op(100,yfx,':'), op(90,xfy,'#').
01) sem(clyde#t,age:6,_).
02) sem(clyde#1,P,S) :isa(elephant,P,\[clyde#11S\]).
03) sem(elephant#1,birthYear:lg80, ).
04) sem(elephant#1,P,S) :isa(elephant,P,\[elephant#1:S\]).
05) sem(elephant,P,S) :isa(mammal,P,\[elephantlS\]).
06) sem(mammal,bloodTemp:warm,).
07) sem(mammal,P,S) :isa(animal,P,\[mammallS\]).
08) sem(animal,P,S) :isa(oreature,P,\[animallS\]); hasa(faee,P,\[animallS\]); hasa(body,P,\[animallS\]).
09) sem(animal,age:X, ) :bottomof(S,B), sem(B,birthYear:Y,_), X is 1986 Y.
i0) sem(face,P,S) :hasa(eye,P,\[facelS\]); hasa(nose,P,\[facelS\]); hasa(mouth,P,\[facelS\]).
Now the meanings of the sem, i~ and h~a predicates, which are important to descriptions in DCKR, are explained later using the DCKR examples given above.
The first argument in the sem predicate is the Qhl~! ngm~.
Objects are broadly divided into two types, in~iEi~i~ and RE~!Q%X~.
Psychologists often refer to prototypes as stereotypes.
An Object name with # represents an in~%~i~i n~ and the one without #, a ~K~!~!Z~ n~.
For example, clyde#1 and elephant, which appears in 01l and 05), represent an individual name and a prototype name, respectively.
A set of Horn clauses, headed by the sem predicate with the same individual name or prototype name represents an /.~i~i~IA~! object or a PK~iXP~ object, respectively.
The second argument in the sem predicate is a pair composed of a ~!~i nfi~ and a sift!
Xg!B~. The pair is hereinafter called @ ~ ~iE.
The description in 02) is to be read as showing that clyde#l is an instance of the prototype elephant.
Here, note that 02) is a direct description of inheritance of knowledge from prototypes at higher level.
02) means that if a prstotype called elephant has a property P, the individual clyde#1 also has the same property P.
05) arid 07) describe the fact that an elephant is a mammal and that a mammal is an ~nimai.
08) describes the fact that an animal is a creature and has a face, body.....
From the foregoing it can be seen that the isa predicate used for the inheritance of knowledge is a predicate for traversing the hierarchy of prototype Objects.
The predicates, isa and hasa are defined below.
Ii) isa(Upper,P,S) :P = isa:Upper; sem(Upper,P,S).
12) hasa(Part,X:Y,S) :X == hasa, (Y = Part; sem(Part,hasa:Y,S)).
The i~ predicate and the ha~a predicates are used for the inheritance of knowledge through subordinate-superordinate and part-whole relations, respectively.
DCKR is provided with the bottomof predicate, which is used in the body of 09).
By using the predicate, it is possible to know what the calling individual (the individual that called the world of prototypes) is and extract the knowledge held by that individual.
This is accomplished by using the third argument in the sem predicate, since in the third argument of the sem predicate is stacked the route followed in tracing the hierarchy.
For example, 09) identifies the individual .(caller) B by means of the bottomof predicate and 222 calculates his age by using B's birthyear.
Tilerefore, if ?-sem(el ephan t#1, age: X,_).
is executed, 09) is reached by the isa predicate in 0,t), 05) and 07).
As a result.
X=6 is derived by the Prolog interpreter.
Also, if ?-sem(elephant#1,P, ).
is exeellted, all properties about elephant#l call be obtained as follows: P = birthYear:1980; P = isa:elephant; P = isa:mamnlal ; P = bloodTelnp:warnti P = isa:animal; P = isa:creature; P = age:6 Nste that all knowledge (SV pairs; propcFtie!) at higher level prototypes than elephant#1 is obtained ttlr'ough tire unification mechanism of Prolog.
\[a other' words, inileri lance of knowledge is carried out automatically by tile functions built in Prolog.
As yell may notice'., if ?-sem(K,Y, ).
is executcd, the system begins calculating all knewledF, e it hat; (as X-Y pairs).
If 9....sem(~, i sa :lllallufla 1 . ) . is exeeutcd, it.
i5. r) lssi.ble to aq~'.es.5 an illc~.ividua oE I~EP~Yt~ ~t-k %he loy!eL" l(~yet.
.fJiqm a Iqt~DIJ!tAj at tile high~E Ir/v~.\[: X :~ clyde#l; X :: elephant#l; X = elephant Finally, if ?-sem (animal,hasa:X,_t . is executed, you may have tile following results: X = face ; X = eye; X = nose; X = mollth; X = body From the foregoing explanation, yen will understand that i! o_nlg .k_l/p_~£!edge .!~ 4e_s.e_,Eib(2_d ira D_CIjR.
_i nf_eEfu!ce !.~t a l~!_oma.t!c,a.\[ i Y LJ e E f o E_m._ed_ by t.f~e i~nierp3x~t__e_ r _b~li!t k n,E~_'o_j_og.
3. Semalltte PPocessing of Natural Language 3.1 Dsecripfions of Lexical Items in DCKR Semantic processing is one of tile important tasks for natural language processing.
Basle to semantic processing are descriptions of lexieal items.
The most frequently used form of description of lexical items is probably Frames or' Objects, A method of the Object representation in Prolog called DCKR is introduced in section 2.
In this section, it will be shown that DCKII represeutation of lexical items enables to alleviate a lot of programming efforts of semantic processing.
\[n I)CKI1, all Object consists of a set of slots each of which is represented by a Horn clallse headed by the sere predicate.
Ilowever, tile first aF/funlellt in tile sere predicate is tile Object name.
Tile values of slots used in semantic processing are initial ly undecided but are deterntined as semantic processing progresses.
This is referred to as slots beinK satisfied by fi\].!e_rs.
To be tire value of a slot, a filler must stttisfy tile pp.nsty'_a, ir!ls written in tile slot.
If the fillet" satisfies the constraints written in a slot, action is started to extract a semantic structure or to make a more profonad inference.
Constraints written in slots are broadly divided into two, syntactic constraints and semantic constraints.
The former represents the syntactic roles to be played by fillers ill sentences.
Tile letter are constraints on tile meaning to be carried by fillers.
Typical semantic pronessin K proceeds rOllghly as follows: i) If a fille.r satisfies tire syntactic and semantic constraints on a siot selected, start action and end with success.
Else, go tn ii) it) If there is soother slot to select, selecl it and I~0 to it.
Else, Ko to iii) iii) If there is a higher-level prototype, get its slot and go to it.
Else, and oe the assumption that the semantic processing is a failure.
14'FOIII tile semantic processing procedllrns ill i) through iii) above, tile following call be seen: at 'rile semantic constraints in i) are often expressed ill logical formulas.
This call be easily done witll DCKR as explained later.
b) The slot selection in it) can use the backtrackin/~ mechanism built in i~rolog, leer in I)CK}{ a slot is repre.sented as a IIorn clause.
el iii) can be.
easily implemented by the knowledge inheritance mechanism of DCKR expiaioed ill 2.1.
Thus, if lexica\[ items are described in I)CKR, programs central to senlaat ie processing call be replaced by the.
basic eompllt&tion mcnhanism built in Prolog.
Tills will be demonstrated by examples below.
Cited first is a DCKR description of the lexlcal item "open" \[Tanaka 85a\].
13) sem(open,subj:Filler"~in~Out, ).
:sem(Fi 1 let, i sa : htllllan, _), ext roe £se.ul(agell t : Fi 11 e.r~I n"Ou t ) ; (sem(Filler,isa:eventOpen,); sem(Fi 1 ler, isa: till ngOpen, ).
), extraetsem(object:Filler~In~Out); sem(ti'i i let', isa: ins trument, ), extractsem( ins t rumen t : Fi I 1 er *° l n~Out ) sem(Filler,isu:wind,.
), ext ran tsem( reasoa : Fi 11 er ~ \[ n~Ou t ) . 14) sem(open,obj:Filler~ln~Out, ) :(semtFi 1 Ier, isa: eventOpen,_) ; sem(Fi I 1 or, i sa: thi ngOpen, )), extraetsem(objuet :Fi 1 let~In~Out ) . 15) sem(open,with:Filler'~In~Out,__) :sere (Fi 11 er, i so: i ns trumen t, ), extractsem(i ns trumen t : l.'i 1 lel "~I n~Out t 16) sem(open,P,S) :isa(aetion,P,\[openlS\]); isa(event,P, \[ol)enlS\]).
13),i,i) and 15) are slots named sttbj, obj and with, which constitute open.
Variable Filler is tile filler for these slots.
The slot names represent tile syntactic constraints to be satisfied by tile Filler.
Subj, obj and with show that the l,'iller must play tile roles of the subject, object, and wi th-headed prepositional phrase, respectively, in sentences.
The body of each of the Horn clauses corresponding to tile slots describes a pair conlposed of semantic constraint and action (hereinafter called an .CA pair').
For example, tile body of 13) describes four CA pairs eocb of thenl joined by or(";').
The first CA pair: 223 sem(Filler,isa:human, ), extractsem(agent:Filler~In~Out); shows that if the Filler is a human (a semantic constraint), the action extractsem(agent:Flller~In~Out) starts making the deep case of the Filler the agent case that is added to In sent to Out.
As described above, checking semantic constraints can be replaced by direct Prolog program execution.
Therefore, relatively complex semantic constraints, e.g., person of blood type A or AB, can be easily described as shown below: sem(Filler,isa:human,_), (sem(Filler,boodType:a,); sem(Filler,boodType:ab,_)) The meaning of the second, third and forth SA pair in 13) is obvious now.
Form the foregoing explanation, the meaning of the slots in 14) and 15) will be evident.
In addition to "with", there are many slots corresponding to prepositional phrases, but they are omitted to simplify the explanation.
16) shows that if the Filler cannot satisfy the slots in 30), 31) and 32), the slots in the prototype action or event is accessed automatically by backtracking.
This was explained in detail as inheritance of knowledge in 2, and provides an example of multiple inheritance of knowledge as well.
The descriptions of 13) through 16) can be completely compiled, thus ensuring higher speed of processing.
This makes a good contrast with most conventional systems which cannot compile a description of lexical items because it is represented as a large data structure.
3.2 Description
of grammar rules The DCG notation \[Pereira 80\] is used to describe grammar rules.
Semantic processing is performed by reinforcement terms in DCG.
An example of a simple grammar rule to analyze a declarative sentence is given below.
sdec(SynVp,SemSdec) --> np(SynSubj,SemSubj), vp(SynVp,SemVp), (eoncord(SynSubj,SynVp), seminterp(SemVp,subj:SemSubj,SemSdec)}.
The part encircled by ( } is a reinforcement term.
The predicate concord is to check concord between subject and verb.
The predicate seminterp, intended to call sem formally, is a small program of about five lines.
In this example the grammar rule checks if the head noun in SemSubj can satisfy the subj slot of the main verb frame (e.g., open in 13) 16)) in SemVp and returns the results of semantic processing to SemSdec.
Therefore, we can see that there is little need to prepare a Program for semantic processing.
As semantic processing is performed by reinforcement terms added to DCG, syntactic processing and semantic processing are amalgamated.
This has been held to be a psychologically reasonable languageprocessing model.
3.3 Test
result Some comments will be made on the results of semantic processing based on the concept explained in 3.1 and 3.2.
The sentence used in the semantic processing is "He opens the door with a key".
input sen lences: He opens the door with a key.
Semantic structure is: sem(open#5,P,S) :isa(open,P,\[open#SIS\]).
sem(open#5,agent:he#4, ).
sem(open#5,instrument:key#7,).
sem(open#5,object:door#6, ).
sem(he#4,P,S/ :isa(he,P,\[he#41S\]).
sem(door#6,P,S) :isa(door,P,\[door#61S\]).
sem(door#6,det:the, ).
sem(key#7,P,S) :isa(key,P,\[key#71S\]).
sem(key#7,det:a,_).
Besides, results of semantic processing of "the door with a key" are obtained but their explanation is omitted.
Here it is to be noted that results of semantic processing are also in DCKR form.
By obtaining semantic processing results in DCKR form, it is possible to get, for example, sem(open#J,instrument:X, ) from the interrogative sentence "With what does he open the door"? and get the answer ...............
ISemantic Structurel ................ l I (DCKR) I I ....................
\[ I ........... t ..........
IInferencet t IContext,, .....
IEngine I ................
I IAnalysis I I .........
I I I I I I I ..........
I ..........................
\[ } .....
IKnowledge Base(DCKR + ?){ I ..........
I I ..........
{Semanticl .........
I { ..... lSentence} IAnalyslsl I ................... l IGeneraI : l I Dictionary(DCKR) I Ition I ..........
I L I ........
I i, I I ...........
{ I \[Syntacticl ........
I .................
I IAnalysis I I Grammar t Input Sentence(Source) Fig.
1 Answer
(Target) DCKR and Natural-Language-Understanding System 224 X=key#7 by merely executing that.
4. Conclusion Now the relationship between DCKR and a natural language understanding system will be touched on.
From what has no far been discussed, we can envision a natural-language-understanding system architecture as illustrated in Fig.
1. The shaded parts in Fig.
1 are those will be achieved by the interpreter built In Prolog.
From the foregoing explanation, it will be seen that if part of general knowledge and a dictionary are described in DCKR, part of context-processing and the greater part of semantic processing can be left to the functions built in Prolog.
As for syntactic processing, the grammar rules described in DCG \[Pereira 802 automatically converted into a Prolog program, and parsing can be replaced by Prolog program execution.
Given the foregoing facts and assuming the inference engine to be the Prolog interpreter, it may be concluded that a Prolog machine plus something else will be a natural-language-processing machine.
If asked what that something will be, we might say that it will be a knowledge base machine.
Anyway, this concept is in line with what the Japanese fifthgeneration computer systems project is aimed eL.
\[Acknowledgment\] Authors wish to express their great gratitude to Mr.
Kazuhiro Fuchi, the director of the Research Center of ICOT, and Dr.
Koichi Furukawa, the chief of the Research Center of ICOT, for their encouragements and valuable comments.
Mr.ltaruo goyama,Mr.Manabu Okumura, Mr.Teruo Ikeda, Mr.Tadashi Kamiwaki, who are students of Tanaka Lab.
of Tokyo Institute of Technology, helped us to implement some application programs based on DCKR.
Mrs. Saehie Salts helped us for preparing this manuscript.
References \[Bobrow 77\] Bobrow,D.G.
et.al.: An Overview of KRL-O, Cognitive Science, i, i, 3-46(1977).
\[Bowen 85\] Bowen,K.A.: Mete-Level Programming and Knowledge Representation, Syracuse Univ.,(1985). \[Colmeraure 78\] Colmeraure,A.: Metamorphosis Grammer, in Bole (edl:Natural Language Communication with Computers, Springer-Vcrlag 133-190(1978).
\[Goebel 85\] GoeiJel, R.: Interpreting Descriptions in a Prolog-Based knowledge Representation System, Proc.of IJCAI'85,711-716(1985).
\[Hayes 80\] Hayes,P.J.: The Logic of Frame Conceptions an Text Understanding, Walter de Gruyer, Berlin,,16-61(1980).
\[Koyama 85\] Koyama,H.
and Tanaka,H.: Definite Clause Knowledge Representation, Proc.of LPC'85, ICOT 95-106(1986), in Japanese.
\[Matsumoto 83J Matsumoto,Y.
et.al,: BUP-~A Bottom-UP Parser Embedded in Prolog, NEW Generation Computing, I, 2, 145-158(1983).
\[Mukai 85\] Mukai,K.: Unification over Complex Indeterminates in Prolog, Free.of LPC'85, ICOT 271-278(1985).
\[Nilsson 80} Nilsson,N.J.: Principles of Artificial Intelligence,Tioga, (1980).
\[Pereira 803 Pereira,F.
et.al: Definite Clause Grammar for Language Analysis --A Survey of the Formalism and a Comparison with Augmented Transition Networks, Artificial Intelligence, 13, 231-278 (1980).
\[Tanaka 84\] Tanaka,H.
and Matsumoto,Y.: Natural Language Processing in Prolog, Information Processing, Society of Japan, 25, 12, 1396-1403 (198,t), in Japanese.
\[Tanaka 85a\] Tanaka,H.
et,al: Definite Clause Dictionary and its Application to Semantic Analysis of Natural Language, Prec.
of LPC'85, ICOT, 317-328(1985), in Japanese.
\[Tanaka 86\] Tanaka,H.: Definite Clause Knowledge Representation and its Applications, ICOT-TR(in press) .

