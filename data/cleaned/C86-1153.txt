Construction of a modular and portable translation system Fujio NISIIIDA, Yoneharu FUJITA and Shi.nobu 'FAKAMATS\[I Department of Electrical Engineering, Faculty of Engineering, University of Osaka Prefecture, Saka\], Osaka, Japan 59\] i.
Introduction In recent years the study of nlachJ ne trans\].ation has made great advances and the translation system has been larger and complicated wJ th augmenting faei\] \]ties.
Furthermore, most recently, many powerfu\[ workstations have been developed and wtrious MT systems for special purposes are ready to be mounted on these workstations.
\]in snch a state of affairs Jt will be needed that many MT systems are reorganized or reconstructed on a program module basis for easy modification lllaJ ntainance and transplantation.
'\]'h:is paper has two purposes.
One of th~i~l :{s to show a method of constructing an MT system ~'3" on a library module basis by the aids ~ a progralnming construction system called L-MAPS.
~) The M\]' system can be written in any progranm~Jng language designated by a user if an appropriate data base and the appropriate processing functions are imp\].emented in advance.
For example, it call be written in a coml)i\].er language like C \]aeguage, which Js preferable for a workstation with a relative slow running machine speed.
4) The other purpose is to give a brief :introduction of a program generating system called Library-Modul.e Aided Program SynthesizJ ng system (abbreviated to \[,-MAPS ) running on a library module basis.
L-MAPS permits us to write program specifications in a restricted natural \]anguage like Japanese and converts them to formal specifications.
It refines the formal specifications using the library modules and geeerates a readable comment of tile refiined specification written in tlre above natural language every refinement in option.
Tim conversion between formal expressions and natural language expressions is performed efficient\]y on a case grammar basis.
• 2):~) 2.
Overview of the MT system organizat\].on Our machine translation system is constructed on the intermediate expressions based on universal subframes of predicates and predicative nouns.
It aims at a multiliugual transfer system.
\[\]p to now, however ~ no universal precise semant J c category system over various languages has been constructed yet, and our MT system is compelled to work rather on a bilingual basis in the selection of equivalent.s, The first versio~of the par~q~ was written in an extended version " of LINGOL -'~'.
It has an advice part and a semantic part in each rewriting rule.
Both parts of them pernlit users to describe any Lisp program for designating details of the reduction procedures.
These techniques used Jn LINGOL and ATN seem apparently convenient.
However, they often make the data part inseparable from the program part and bring an MT system to much complexity, and accordingly, prevents applicability of tire programs of the MT system Lo another translation between other languages.
Recently, a revised version of our MT system has been constructed, rfhe main program or procedural part cons:i sts of uni f:i cat\] on arKl substJtut:ion, while the data part consists of frame knowledge rewriting ruins and word dictionaries.
Rewriting ru\]es wi th arguments describe the details of the syntactic and semantic structure of the language explicitly.
For example, the predicate part: of the Hornby's verb llattern VP\]3A of Eagl:ish is written as follows: PREDP( PRED-co:to,MOI):m, kl-C \]:t\],k2-c2:t2) --> VP( PRED-co:to,MOD:m ) NP(k\]-Cl:t\]) PP( k2-c2:TO-t 2) where PREDP, VP, NP and PP denote a PR\]'\]DJcage Phrase, a Verb Phrase, a Noun Phrase and a Prepositional Phrase respecively, k-c:t denotes a triple of a case label, a semantic category and a term and in denotes var:ious modal values such as tense an(\] aspect.
These rewriting rules are tabnlated in several tab\] es :\[or an effJ (lent processJ ug.
The parsing system first applies the syntactic part of a rewriting rule to that of a handle in a reduction sequence of a given source sentence, ff tile system finds a unJf:iable rewriting rule, :it checks whether the semantic part is unifiable.
\]'he category check of a term in a handle for the case-frame condition is processed by a special kind of unification under an interpretation that the term category in a rule :is a restricted variable.
The intermediate expression of tile handle part is constructed by substituting the unified terms for the arguments in the left-hand side of the rewriting rule.
3. The L-MAPS system aud language conversion The L-MAPS system is costructed on a fundamental \].ibrary module basis.
When a user gives a specification by referrkng to the libraly module, L-MAPS searches applJ(.:able library modules and refines the spa(if J cation by linking several modules or replacing :it by the detailed procedure called the Operation Part of an applicable library module.
The formal specifications of programs as well as tile library modules are generally difficult for users to read and write correctly though they are efficient and rigorous for inachine operation.
Hence, it is desirab\].e to rewrite the formal specification Jn a natural l.anguage.
I.-MAPS performs a conversion between a restricted natural language expression and a fornlal language expression through the intermediate (or the internal) expression of the natural language expression with the aids of case \].abels.
The conversion between a restricted natural language expression and the intermediate expression can be done Jn a similar manner to the conversion carried out in machine translation.
Formal specifications generaJ.ly have different forms from those of the intermediate expressions.
649 The intermediate expression of a sentence takes the following form : (PRED:tp, Kl:tl.......
Kn:tn) (I) where PRED K1 and Kn are case labe\].s and tp tl and tn are terms corresponding to their cases° On the other hand, a procedure expression appearing in formal specifications as well as in a heading of each library module has tile following form: proc-label(Kl':tl', K2':t2', .....
Kri':tn') (2) where the procedure name plays a role of the key word and it is constructed from the predicate term the object term and others of the intermediate expression° It is used for retrieving library modules applicable to a given specification.
\].-MAPS performs the conversion between the intermediate expression(I) and the procedural expression(2) by a method similar to the case structure conversion between different languages.
The conversion :ks applied not onJy to the construction of a formal specJ fJeation from an informal specificatJ on written Jn restricted Japanese or English but also to the generation of Japanese or English comments on the refJ ned specifications generated by L-MAPS itself.
4. Modularization of programs The revised MT system is reconstructed based on library modules by the aids of L-MAPS.
Each library module has a structure as shown in Table i.
Table 1 A part of library modules PROC: HANDLE_REDUCE(SO:reduced_sequence, OBJ:handle, INSTR:reduction rule, GOAL:new_reduce~_sequence) IN: GIVEN(OBJ:reduced_sequence,handle, reduction_rule) OUT: REDUCED_FORM(OBJ:new_reduced_sequence) ENTITYTYPE: ................................
OP: RULE_APPLY(OBJ:reduction_rule, PARTIC:handle, GOAL:reduced_symbol) BRARCIII(COND:EQUAL(reducedsymboI,NULL), OP:RETURN(FAIL)) FOR(COUNT:n,FROM:l,TO:-(stack_pointer, symbol_number ofhandle), OP:COPY(OBJ:reduced_sequence(n), GOAL:new_reducedsequence(n))) COPY(OBJ:reduced_symbol, GOAL:newreduced_sequence(+(n,l))) RETURN(TRUE) The heading of each module has both the procedural expression and the input-output predicate expression (abbreviated to the IO expression).
Program specifications given by a user can call a module by using one of these headings.
The IO expression consists of a pair of an input and an output predicate and asserts that the output predicate holds under the given input predicate.
The IO expressions are used to automatically link some modules for a specification and to check linking of modules specified by their procedural expressions.
The type part describes the types of regions structures and roles of input output or local variables.
650 Tile OP part describes the procedures for the ~nnction assured in the heading part.
\]'he procedures are described in a little more detail by using tile headings of more fundainental modules° Control statements are represented by using a prefixed-form of Pascal called the General Control Expression (abbrewkated to GCE,) here° The control statements are expanded into a programming language such as L:isp and C designated by users.
Some conversion rules are shown in Table 2.
Table 2 Conversion rules to objective lauguages IF TIIEN(CONI): p.
OP: s ....................
(GCE) (CORD (p s)) ........................
(Lisp) IF(p) s ; ...........................
(C) IF TIIEN_I~,LSE(COND: p, OPI: sl, OP2:s2 ....
(GCE) (CON:\[) (ps\]) (t s2)) ................
(Lisp) IF(p) s\] ELSE s2 ; ..................
(C) FOR(COUNT: i, FROM: m, TO: n, OP: s) ......
(GCE) (SETQ J m) (\],OOP ()(CORD ((EQUAL i n) (EXIT-LOOP)) (T ~ (SETQ i (ADm i))) )) ...........................
(map) FOR(J = m; J <= n; J++) s ..........
(C) •,o.0,oo¢.0.o°.
.... ~,.0.o.ooo.....oo~ oooo,oo,,.0.o~,,,.o~0.°o..,.oo,.0©°.G Corresponding to tlle genera\] control \]anguage~ general data structures are also introduced.
If refined specifications are designated to be expanded to a programming language which do not have the corresponding data structures inherently, the equivalent data structures and the access function must be imp\].emented in advance by combining the fundamental data structures in the language.
For example, if Lisp is designated as the programming language, a struct which appears in a general data structure of a specification is expanded to the correspondig associative list structure and the lists can be accessed by associative functions.
5. Refinement and Expansion by the L-MAPS system Figure 1 shows an outline of the processing by L-MAPS.
\[ specificati°ns' I £J~llibrary modules (i) Iprocedural l~{input-output\] ~ --' \[expressionsJ ~expressions I ",\]specification by I ~input-output I J, .11 "~expr essions I (2) I detection of ~I I/ ....
\[ insuf ficiency\]~$/~-~subproblems I, /,/~-q~requests of I "/I"" \]additional modules I / / ....
(3) ~ ~ ......
~ad'ditional modules I ~ ~intermediate I -jpr°gra.ms I j~ ~ |object language,l (4) ~efinement,expansion~---Jexpansion mode I -~ ~ -~object programs\[ Fig.l The processing by L-MAPS In refinement, L-MAPS tries to un:i.fy the heading el an expression in a given speeifJcation and the corresponding heading of a l:ibrary module.
If L-MAPS succeeds in the unification, it constructs a more detaJ\]ed description of the specificatfion by using the unified Operation Part of the module . The refined part with a more detailed description can be substituted directly for the original part in the specification or can be called in a form of a subprogram as a procedure or a dosed subroutine from the specification part.
One of them is selected by the user.
The principal part of the above refinement is unification of a specification and the heading of a library module.
When the arguments of a module are confined to the individual variables and the number of arguments of a function is confined to a constant the unification caa be carried out; by an ordinary unification of the first order logic.
0therwJse, the unification procedure for the second order ilogic is needed.
L-MAPS has a unification procedure for the second order logic.
IIowever, the un~ fJcatJon procedure is confined to a unilateral unification from a module to a specification in which each symbol is J nterpreted as a constant under the condition that any substitution for the symbol Jn the specifications is forbidden.
Accorddagly, the unification procedure can be much simplified for practical purpose.
Fig.2 shows parts of a given specification written in the restricted English for a parsing program of EngIish sentences and Fig.3 shows a part of the generated formal specification.
...,.,,...........,.....,°o for i from i to m js:=j search handles from reducedsequences(i) by using reduction rules, and store it in handle(l..k) and rule(\[..k) if k is greater than 0 for n from 1 to k reduce handle(n) Jn reduced_sequences(i) by using rule(n), and store the result in new_reduced_sequences(j) ...,,...o.,..........,..*....
Fig.2 The informal specification for a parsing program FOR(COUNT:I,FROM:I,IO:M, OP: =(JS,J) HANDLE_SEARCH(SO:REDUCEDSEQUENCES(I), INSTR:REDUCTIONRULES, GOAL:(HARDLE(1..R),RULE(I..K))) BRANCNI(COND:>(K,O) OP:FOR(COUNT:N,FROM:I,TO:K, OP:HANDLE REDUCE (SO:REDUCEDSEQUENCES(I), OBJ:HANDLE(N), INSTR:RULE(N), GOAL:NEW_REDUCED _SEQUENCES(J)) ) ) Fig.3 A part of formal specifications \[,-MAPS refines the formal specification by referrdng to library modules such as shown in Table \] and generates a ref:ined specification and the comment: shown in Fig.4.
RULE APPI,Y(OBJ: REDUCTION_RULE, PARTIC : HANDLE, GOAL:REDUCED SYMBOL) BRANCH1 (COND: EQUAL(REDUCED_SYMBOL, NULL), OP:RETURN(FAIL) ) FOR (COUNT: N, FROM: 1, TO :(STACK_POINTER, SYMBOL NUMBER OF HANDI,E), OP: COPY(OBJ: REDUCED_SEQUENCE(N), GOAL: NEW_REDUCED _SEQUENCE ( N ) ),........~.....o..............
Fig.4(a) A part of tile refined specification apply t:he rnl.e to the handle, and store t;he result; in a reduced symbol.
Jf the reduced_symbol Js null return(fail).
for n from t.
t:o stack_po:inter-synlbol_number of hand\] e copy reducedsequence(n) :into new reduced sequence(n).
.o................,...,....
Fig.4(b) The comments of the refined specification in Fig.4(a) In the refinement process global optimizations are tried to be done at the user's option.
Some of them are rearrangement of conditional control statements and fusion of several iteration loops :i.nto one loop.
6. Conclusion The translation system :is constructed on a modular basis consisting of 24 application modules and 30 bas:\[c modules by refining and expanding specifications by the aids of the L-MAPS system consisting of about 1000 lines of Lisp statements.
The generated translation-system programs is about i000 lines in both C language and Franz Lisp.
Besides various advantages due to the modular:\[zation, the translation speed is almost the same as that of the old version in LISP.
Furthermore, the translation speed in C language is about three times faster than that of Franz Lisp at a compiler mode in English-Japanese translation.
References l)Pratt,V.R.: LINGOL-A Progress Report, IJCAI4, 422-428 (1975).
2)Nishida,F., Takamatsu,S.
and Kuroki,B.: English-Japanese Translation through Case-Structure Conversion, COLING-80, pp.447 -454 (1980).
3)Nishida,F.
and Takamatsu,S.: Japanese-English Translation through Internal Expressions, COLING-82, pp.271-276 (1982).
4)Nishida,F.
and Fujita,Y.: Semi-Automatic Program Refinement from Specification Using Library Modules, Trans° of IPS of Japan, Voi.25, No.5, pp.785-793,(1984), (Written in Japanese).
5)Tanaka,ll., Sato,T and Motoyoshi,F.: Predictive Control Parser: Extended LINGOL, 6th IJCAI, Vol.2, pp.868-870, (1979) .

