Proceedings of the 2007 Joint Conference on Empirical Methods in Natural Language Processing and Computational Natural Language Learning, pp.
315–324, Prague, June 2007.
c©2007 Association for Computational Linguistics A New Perceptron Algorithm for Sequence Labeling with Non-local Features Jun’ichi Kazama and Kentaro Torisawa Japan Advanced Institute of Science and Technology (JAIST) Asahidai 1-1, Nomi, Ishikawa, 923-1292 Japan {kazama, torisawa}@jaist.ac.jp Abstract We cannot use non-local features with current major methods of sequence labeling such as CRFs due to concerns about complexity.
We propose a new perceptron algorithm that can use non-local features.
Our algorithm allows the use of all types of non-local features whose values are determinedfromthesequenceandthelabels.
The weights of local and non-local features are learned together in the training process with guaranteed convergence.
We present experimental results from the CoNLL 2003 named entity recognition (NER) task to demonstrate the performance of the proposed algorithm.
1 Introduction
Many NLP tasks such as POS tagging and named entity recognition have recently been solved as sequence labeling.
Discriminative methods such as Conditional Random Fields (CRFs) (Lafferty et al., 2001), Semi-Markov Random Fields (Sarawagi and Cohen, 2004), and perceptrons (Collins, 2002a) have been popular approaches for sequence labeling because of their excellent performance, which is mainly due to their ability to incorporate many kinds of overlapping and non-independent features.
However, the common limitation of these methods is that the features are limited to “local” features, which only depend on a very small number of labels (usually two: the previous and the current).
Although this limitation makes training and inference tractable, it also excludes the use of possibly useful “non-local” features that are accessible after all labels are determined.
For example, non-local features such as “same phrases in a document do not have different entity classes” were shown to be useful in named entity recognition (Sutton and McCallum, 2004; Bunescu and Mooney, 2004; Finkel et al., 2005; Krishnan and Manning, 2006).
Weproposeanewperceptronalgorithminthispaper that can use non-local features along with local features.
Although several methods have already been proposed to incorporate non-local features (Sutton and McCallum, 2004; Bunescu and Mooney, 2004; Finkel et al., 2005; Roth and Yih, 2005; Krishnan and Manning, 2006; Nakagawa and Matsumoto, 2006), these present a problem that the types of non-local features are somewhat constrained.
For example, Finkel et al.(2005) enabled the use of non-local features by using Gibbs sampling.
However, it is unclear how to apply their methodofdeterminingtheparametersofanon-local model to other types of non-local features, which they did not used.
Roth and Yih (2005) enabled the use of hard constraints on labels by using integer linear programming.
However, this is equivalent to only allowing non-local features whose weights are ﬁxed to negative inﬁnity.
Krishnan and Manning (2006) divided the model into two CRFs, where the second model uses the output of the ﬁrst as a kind of non-local information.
However, it is not possible to use non-local features that depend on the labels of the very candidate to be scored.
Nakagawa and Matsumoto (2006) used a Bolzmann distribution to model the correlation of the POS of words having the same lexical form in a document.
However, their method can only be applied when there are convenient links such as the same lexical form.
Since non-local features have not yet been extensively investigated, it is possible for us to ﬁnd new useful non-local features.
Therefore, our objective in this study was to establish a framework, where all 315 types of non-local features are allowed.
With non-local features, we cannot use efﬁcient procedures such as forward-backward procedures and the Viterbi algorithm that are required in training CRFs (Lafferty et al., 2001) and perceptrons (Collins, 2002a).
Recently, severalmethods(Collins and Roark, 2004; Daum´e III and Marcu, 2005; McDonald and Pereira, 2006) have been proposed with similar motivation to ours.
These methods alleviate this problem by using some approximation in perceptron-type learning.
In this paper, we follow this line of research and try to solve the problem by extending Collins’ perceptron algorithm (Collins, 2002a).
We exploited the not-so-familiar fact that we can design a perceptron algorithm with guaranteed convergence if we can ﬁnd at least one wrong labeling candidate even if we cannot perform exact inference.
We ﬁrst ran the A* search only using local features to generate n-best candidates (this can be efﬁciently performed), and then we only calculated the true score with non-local features for these candidates to ﬁnd a wrong labeling candidate.
The second key idea was to update the weights of local features during training if this was necessary to generate sufﬁciently good candidates.
The proposed algorithm combined these ideas to achieve guaranteed convergence and effective learning with non-local features.
The remainder of the paper is organized as follows.
Section 2 introduces the Collins’ perceptron algorithm.
Although this algorithm is the starting point for our algorithm, its baseline performance is not outstanding.
Therefore, we present a margin extension to the Collins’ perceptron in Section 3.
This margin perceptron became the direct basis of our algorithm.
We then explain our algorithm for nonlocal features in Section 4.
We report the experimental results using the CoNLL 2003 shared task dataset in Section 6.
2 Perceptron
Algorithm for Sequence Labeling Collins (2002a) proposed an extension of the perceptron algorithm (Rosenblatt, 1958) to sequence labeling.
Our aim in sequence labeling is to assign label yi ∈ Y to each word xi ∈ X in a sequence.
We denote sequence x1,...,xT as x and the corresponding labels as y.
We assume weight vector α ∈ Rd and feature mapping Φ that maps each (x,y) to feature vector Φ(x,y) = (Φ1(x,y),···,Φd(x,y)) ∈ Rd.
The model determines the labels by: y′ = argmaxy∈Y|x|Φ(x,y)·α, where · denotes the inner product.
The aim of the learning algorithm is to obtain an appropriate weight vector, α, given training set {(x1,y∗1),···,(xL,y∗L)}.
The learning algorithm, which is illustrated in Collins (2002a), proceeds as follows.
The weight vector is initialized to zero.
The algorithm passes over the training examples, and each sequence is decoded using the current weights.
If y′ is not the correct answery∗, the weights are updated according to the following rule.
αnew = α+ Φ(x,y∗)−Φ(x,y′).
This algorithm is proved to converge (i.e., there are no more updates) in the separable case (Collins, 2002a).1 Thatis,ifthereexistweightvectorU (with ||U|| = 1), δ (> 0), and R (> 0) that satisfy: ∀i,∀y ∈ Y|xi| Φ(xi,yi∗)·U −Φ(xi,y)·U ≥ δ, ∀i,∀y ∈ Y|xi| ||Φ(xi,yi∗)−Φ(xi,y)|| ≤ R, the number of updates is at most R2/δ2.
The perceptron algorithm only requires one candidatey′ foreachsequencexi, unlikethetrainingof CRFs where all possible candidates need to be considered.
This inherent property is the key to training with non-local features.
However, note that the tractability of learning and inference relies on how efﬁciently y′ can be found.
In practice, we can ﬁnd y′ efﬁciently using a Viterbi-type algorithm only when the features are all local, i.e., Φs(x,y) can be written as the sum of (two label) local features φs as Φs(x,y) = ∑Ti φs(x,yi−1,yi).
This locality constraint is also required to make the training of CRFs tractable (Lafferty et al., 2001).
One problem with the perceptron algorithm described so far is that it offers no treatment for overﬁtting.
Thus, Collins (2002a) also proposed an averaged perceptron, where the ﬁnal weight vector is 1Collins(2002a)alsoprovidedproofthatguaranteed“good” learning for the non-separable case.
However, we have only considered the separable case throughout the paper.
316 Algorithm 3.1: Perceptron with margin for sequence labeling (parameters: C) α ← 0 until no more updates do for i ← 1 to L do8 >> >< >> >: y′ = argmaxyΦ(xi,y)·α y′′ = 2nd-bestyΦ(xi,y)·α if y′ ̸= y∗i then α = α+ Φ(xi,y∗i)−Φ(xi,y′) else if Φ(xi,y∗i)·α−Φ(xi,y′′)·α ≤ C then α = α+ Φ(xi,y∗i)−Φ(xi,y′′) the average of all weight vectors during training.
Howerver, we found in our experiments that the averaged perceptron performed poorly in our setting.
We therefore tried to make the perceptron algorithm more robust to overﬁtting.
We will describe our extension to the perceptron algorithm in the next section.
3 Margin
Perceptron Algorithm for Sequence Labeling Weextendedaperceptronwithamargin(Krauthand M´ezard, 1987) to sequence labeling in this study, as Collins (2002a) extended the perceptron algorithm to sequence labeling.
In the case of sequence labeling, the margin is deﬁned as: γ(α) = minx i miny ̸=y∗i Φ(xi,yi∗)·α−Φ(xi,y)·α ||α|| Assuming that the best candidate,y′, equals the correct answer, y∗, the margin can be re-written as: = minx i Φ(xi,yi∗)·α−Φ(xi,y′′)·α ||α||, wherey′′ = 2nd-bestyΦ(xi,y)·α.
Using this relation, theresultingalgorithmbecomesAlgorithm3.1.
The algorithm tries to enlarge the margin as much as possible, as well as make the best scoring candidate equal the correct answer.
Constant C in Algorithm 3.1 is a tunable parameter, which controls the trade-off between the margin and convergence time.
Based on the proofs in Collins (2002a) and Li et al.(2002), we can prove that the algorithm converges within (2C + R2)/δ2 updates and that γ(α) ≥ δC/(2C + R2) = (δ/2)(1 − (R2/(2C + R2))) after training.
As can be seen, the margin approaches at least half of true margin δ (at the cost of inﬁnite training time), as C → ∞.
Note that if the features are all local, the secondbestcandidate(generallyn-bestcandidates)canalso be found efﬁciently by using an A* search that uses the best scores calculated during a Viterbi search as the heuristic estimation (Soong and Huang, 1991).
There are other methods for improving robustness by making margin larger for the structural output problem.
Such methods include ALMA (Gentile, 2001) used in (Daum´e III and Marcu, 2005)2, MIRA (Crammer et al., 2006) used in (McDonald et al., 2005), and Max-Margin Markov Networks (Taskar et al., 2003).
However, to the best of our knowledge, there has been no prior work that has applied a perceptron with a margin (Krauth and M´ezard, 1987) to structured output.3 Our method described in this section is one of the easiest to implement, while guaranteeingalargemargin.
WefoundintheexperimentsthatourmethodoutperformedtheCollins’averaged perceptron by a large margin.
4 Algorithm
4.1 Deﬁnition and Basic Idea Having described the basic perceptron algorithms, we will know explain our algorithm that learns the weights of local and non-local features in a uniﬁed way.
Assume that we have local features and nonlocal features.
We use the superscript, l, for local features as Φli(x,y) and g for non-local features as Φgi(x,y).
Then, feature mapping is written as Φa(x,y) = Φl(x,y) + Φg(x,y) = (Φl1(x,y),···,Φln(x,y),Φgn+1(x,y),···,Φgd(x,y)).
Here, we deﬁne: Φl(x,y) = (Φl1(x,y),···,Φln(x,y),0,···,0) Φg(x,y) = (0,···,0,Φgn+1(x,y),···,Φgd(x,y)) Ideally, we want to determine the labels using the whole feature set as: y′ = argmaxy∈Y|x|Φa(x,y)·α.
2(Daum´e III and Marcu, 2005) also presents the method using the averaged perceptron (Collins, 2002a) 3For re-ranking problems, Shen and Joshi (2004) proposed a perceptron algorithm that also uses margins.
The difference is that our algorithm trains the sequence labeler itself and is much simpler because it only aims at labeling.
317 Algorithm 4.1: Candidate algorithm (parameters: n, C) α ← 0 until no more updates do for i ← 1 to L do8 >> >> >< >> >> >: {yn} = n-bestyΦl(xi,y)·α y′ = argmaxy∈{yn}Φa(xi,y)·α y′′ = 2nd-besty∈{yn}Φa(xi,y)·α if y′ ̸= yi∗ & Φa(xi,y∗i)·α−Φa(xi,y′)·α ≤ C then α = α+ Φa(xi,y∗i)−Φa(xi,y′) else if Φa(xi,y∗i)·α−Φa(xi,y′′)·α ≤ C then α = α+ Φa(xi,y∗i)−Φa(xi,y′′) However, if there are non-local features, it is impossible to ﬁnd the highest scoring candidate efﬁciently, since we cannot use the Viterbi algorithm.
Thus, we cannot use the perceptron algorithms described in the previous sections.
The training of CRFs is also intractable for the same reason.
To deal with this problem, we ﬁrst relaxed our objective.
The modiﬁed objective was to ﬁnd a good model from those with the form: {yn} = n-bestyΦl(x,y)·α y′ = argmaxy∈{yn}Φa(x,y)·α, (1) That is, we ﬁrst generate n-best candidates {yn} under the local model, Φl(x,y) · α.
This can be done efﬁciently using the A* algorithm.
We then ﬁndthebestscoringcandidateunderthetotalmodel, Φa(x,y)·α, only from these n-best candidates.
If n is moderately small, this can also be done in a practical amount of time.
This resembles the re-ranking approach (Collins and Duffy, 2002; Collins, 2002b).
However, unlike the re-ranking approach, the local model, Φl(x,y)· α, and the total model, Φa(x,y)·α, correlate since they share a part of the vector and are trained at the same time in our algorithm.
The re-ranking approach has the disadvantage that it is necessary to use different training corpora for the ﬁrst model and for the second, or to use cross validation type training, to make the training for the second meaningful.
This reduces the effective size of training data or increases training time substantially.
On the other hand, our algorithm has no such disadvantage.
However, we are no longer able to ﬁnd the highest scoring candidate under Φa(x,y) · α exactly with this approach.
We cannot thus use the perceptron algorithms directly.
However, by examining the Algorithm 4.2: Perceptron with local and non-local features (parameters: n, Ca, Cl) α ← 0 until no more updates do for i ← 1 to L do8 >> >> >> >> >> < >> >> >> >> >> : {yn} = n-bestyΦl(xi,y)·α y′ = argmaxy∈{yn}Φa(xi,y)·α y′′ = 2nd-besty∈{yn}Φa(xi,y)·α if y′ ̸= y∗i & Φa(xi,y∗i)·α−Φa(xi,y′)·α ≤ Ca then α = α+ Φa(xi,y∗i)−Φa(xi,y′) (A) else if Φa(xi,y∗i)·α−Φa(xi,y′′)·α ≤ Ca then α = α+ Φa(xi,y∗i)−Φa(xi,y′′) (A) else (B) 8> < >: if y1 ̸= yi∗ then (y1 represents the best in {yn}) α = α+ Φl(xi,y∗i)−Φl(xi,y1) else if Φl(xi,y∗i)·α−Φl(xi,y2)·α ≤ Cl then α = α+ Φl(xi,y∗i)−Φl(xi,y2) proofs in Collins (2002a), we can see that the essential condition for convergence is that the weights are always updated using some y (̸= y∗) that satisﬁes: Φ(xi,y∗i)·α−Φ(xi,y)·α ≤ 0 (≤ C in the case of a perceptron with a margin).
(2) That is, y does not necessarily need to be the exact best candidate or the exact second-best candidate.
The algorithm also converges in a ﬁnite number of iterations even with Eq.
(1) as long as Eq.
(2) is satisﬁed.
4.2 Candidate
Algorithm The algorithm we came up with ﬁrst based on the above idea, is Algorithm 4.1.
We ﬁrst ﬁnd the nbest candidates using the local model, Φl(x,y)·α.
At this point, we can determine the value of the nonlocal features, Φg(x,y), to form the whole feature vector, Φa(x,y), for the n-best candidates.
Next, we re-score and sort them using the total model, Φa(x,y) · α, to ﬁnd a candidate that violates the margin condition.
We call this algorithm the “candidate algorithm”.
After the training has ﬁnished, Φa(xi,y∗i) · α − Φa(xi,y) · α > C is guaranteed for all (xi,y) where y ∈ {yn},y ̸= y∗.
At ﬁrst glance, this seems sufﬁcient condition for good models.
However, this is not true because if y∗ ̸∈ {yn}, the inference deﬁned by Eq.
(1) is not guaranteed to ﬁnd the correct answer, y∗.
In fact, this algorithm does not work well with non-local features as we found in the experiments.
318 4.3 Final Algorithm Our idea for improving the above algorithm is that thelocalmodel,Φl(x,y)·α,mustatleastbesogood that y∗ ∈ {yn}.
To achieve this, we added a modiﬁcation term that was intended to improve the local model when the local model was not good enough even when the total model was good enough.
The ﬁnal algorithm resulted in Algorithm 4.2.
As canbeseen, thepartmarked(B)hasbeenadded.
We call this algorithm the “proposed algorithm”.
Note that the algorithm prioritizes the update of the total model, (A), over that of the local model, (B), although the opposite is also possible.
Also note that the update of the local model in (B) is “aggressive” since it updates the weights until the best candidate output by the local model becomes the correct answer and satisﬁes the margin condition.
A “conservative” updating, where we cease the update when the n-best candidates contain the correct answer, is also possible from our idea above.
We made these choices since they worked better than the other alternatives.
The tunable parameters are the local margin parameter, Cl, the total margin parameter, Ca, and n for the n-best search.
We used C = Cl = Ca in this study to reduce the search space.
We can prove that the algorithm in Algorithm 4.2 also converges in a ﬁnite number of iterations.
It converges within (2C + R2)/δ2 updates, assuming that there exist weight vector Ul (with ||Ul|| = 1 and Uli = 0 (n+1 ≤ i ≤ d)), δ (> 0), and R (> 0) that satisfy: ∀i,∀y ∈ Y|xi| Φl(xi,yi∗)·Ul−Φl(xi,y)·Ul ≥ δ, ∀i,∀y ∈ Y|xi| ||Φa(xi,yi∗)−Φa(xi,y)|| ≤ R.
In addition, we can prove that γ′(α) ≥ δC/(2C + R2) for the margin after convergence, where γ′(α) is deﬁned as: minx i miny ∈{yn},̸=y∗i Φa(xi,yi∗)·α−Φa(xi,y)·α ||α|| See Appendix A for the proofs.
We also incorporated the idea behind Bayes point machines (BPMs) (Herbrich and Graepel, 2000) to improvetherobustnessofourmethodfurther.
BPMs try to cancel out overﬁtting caused by the order of examples, by training several models by shufﬂing the training examples.4 However, it is very time consuming to run the complete training process several times.
We thus ran the training in only one pass over the shufﬂed examples several times, and used the averaged output weight vectors as a new initial weight vector, because we thought that the early part of training would be more seriously affected by the order of examples.
We call this “BPM initialization”.
5 5 Named Entity Recognition and Non-Local Features We evaluated the performance of the proposed algorithm using the named entity recognition task.
We adopted IOB (IOB2) labeling (Ramshaw and Marcus, 1995), where the ﬁrst word of an entity of class “C” is labeled “B-C”, the words in the entity are labeled “I-C”, and other words are labeled “O”.
We used non-local features based on Finkel et al.(2005). These features are based on observations such as “same phrases in a document tend to have the same entity class” (phrase consistency) and “a sub-phrase of a phrase tends to have the same entity class as the phrase” (sub-phrase consistency).
We also implemented the “majority” version of these features as used in Krishnan and Manning (2006).
In addition, we used non-local features, which are based on the observation that “entities tend to have the same entity class if they are in the same conjunctiveordisjunctiveexpression”asin“··· inU.S., EU,andJapan”(conjunctionconsistency).
Thistype of non-local feature was not used by Finkel et al.(2005) or Krishnan and Manning (2006).
6 Experiments
6.1 Data and Setting We used the English dataset of the CoNLL 2003 named entity shared task (Tjong et al., 2003) for the experiments.
It is a corpus of English newspaper articles, where four entity classes, PER, LOC, ORG, and MISC are annotated.
It consists of training, development, and testing sets (14,987, 3,466, 4The results for the perceptron algorithms generally depend on the order of the training examples.
5Note that we can prove that the perceptron algorithms converge even though the weight vector is not initialized asα = 0.
319 and 3,684 sentences, respectively).
Automatically assigned POS tags and chunk tags are also provided.
TheCoNLL2003datasetcontainsdocumentboundary markers.
We concatenated the sentences in the same document according to these markers.6 This generated 964 documents for the training set, 216 documents for the development set, and 231 documents for the testing set.
The documents generated as above become the sequence, x, in the learning algorithms.
We ﬁrst evaluated the baseline performance of a CRF model, the Collins’ perceptron, and the Collins’ averaged perceptron, as well as the margin perceptron, with only local features.
We next evaluated the performance of our perceptron algorithm proposed for non-local features.
We used the local features summarized in Table 1, which are similar to those used in other studies on named entity recognition.
We omitted features whose surface part listed in Table 1 occurred less than twice in the training corpus.
We used CRF++ (ver.
0.44)7 as the basis of our implementation.
We implemented scaling, which is similar to that for HMMs (see such as (Rabiner, 1989)),intheforward-backwardphaseofCRFtraining to deal with very long sequences due to sentence concatenation.8 We used Gaussian regularization (Chen and Rosenfeld, 2000) for CRF training to avoid overﬁtting.
The parameter of the Gaussian, σ2, was tuned usingthedevelopmentset.
Wealsotunedthemargin parameter, C, for the margin perceptron algorithm.9 TheconvergenceofCRFtrainingwasdeterminedby checking the log-likelihood of the model.
The convergence of perceptron algorithms was determined by checking the per-word labeling error, since the 6We used sentence concatenation even when only using local features, since we found it does not degrade accuracy (rather we observed a slight increase).
7http://chasen.org/˜taku/software/CRF++ 8We also replaced the optimization module in the original package with that used in the Amis maximum entropy estimator (http://www-tsujii.is.s.u-tokyo.ac.jp/amis) since we encountered problems with the provided module in some cases.
9For the Gaussian parameter, we tested {13, 25, 50, 100, 200, 400, 800} (the accuracy did not change drastically among these values and it seems that there is no accuracy hump even if we use smaller values).
We tested {500, 1000, 1414, 2000, 2828, 4000, 5657, 8000, 11313, 16000, 32000} for the margin parameters.
Table 1: Local features used.
The value of a node feature is determined from the current label, y0, and a surface feature determined only fromx.
The value of an edge feature is determined by the previous label, y−1, the current label, y0, and a surface feature.
Used surface features are the word (w), the downcased word (wl), the POS tag (pos), the chunk tag (chk), the preﬁx of the word of length n (pn), the sufﬁx(sn), thewordformfeatures: 2d-cp(theseare based on (Bikel et al., 1999)), and the gazetteer features: go for ORG, gp for PER, and gm for MISC.
These represent the (longest) match with an entry in the gazetteer by using IOB2 tags.
Node features: {””,x−2,x−1,x0,x+1,x+2}×y0 x =, w, wl, pos, chk, p1, p2, p3, p4, s1, s2, s3, s4, 2d, 4d, d&a, d&-, d&/, d&,, d&., n, ic, ac, l, cp, go, gp, gm Edge features: {””,x−2,x−1,x0,x+1,x+2}×y−1 ×y0 x =, w, wl, pos, chk, p1, p2, p3, p4, s1, s2, s3, s4, 2d, 4d, d&a, d&-, d&/, d&,, d&., n, ic, ac, l, cp, go, gp, gm Bigram node features: {x−2x−1,x−1x0,x0x+1}×y0 x = wl, pos, chk, go, gp, gm Bigram edge features: {x−2x−1,x−1x0,x0x+1}×y−1 ×y0 x = wl, pos, chk, go, gp, gm number of updates was not zero even after a large number of iterations in practice.
We stopped training when the relative change in these values became less than a pre-deﬁned threshold (0.0001) for at least three iterations.
We used n = 20 (n of the n-best) for training sincewecouldnotusetooalargenbecauseitwould have slowed down training.
However, we could examinealargernduringtesting,sincethetestingtime did not dominate the time for the experiment.
We found an interesting property for n in our preliminary experiment.
We found that an even larger n in testing (written as n′) achieved higher accuracy, although it is natural to assume that the same n that was used in training would also be appropriate for testing.
We thus used n′ = 100 to evaluate performance during parameter tuning.
After ﬁnding the best C with n′ = 100, we varied n′ to investigate its 320 Table 2: Summary of performance (F1).
Method dev test C (or σ2) local features CRF 91.10 86.26 100 Perceptron 89.01 84.03 Averaged perceptron 89.32 84.08 Margin perceptron 90.98 85.64 11313 + non-local features Candidate (n′ = 100) 90.71 84.90 4000 Proposed (n′ = 100) 91.95 86.30 5657 Table 3: Effect of n′.
Method dev test C Proposed (n′ = 20) 91.76 86.19 5657 Proposed (n′ = 100) 91.95 86.30 5657 Proposed (n′ = 400) 92.13 86.39 5657 Proposed (n′ = 800) 92.09 86.39 5657 Proposed (n′ = 1600) 92.13 86.46 5657 Proposed (n′ = 6400) 92.19 86.38 5657 effects further.
6.2 Results
Table 2 compares the results.
CRF outperformed the perceptron by a large margin.
Although the averaged perceptron outperformed the perceptron, the improvement was slight.
However, the margin perceptron greatly outperformed compared to the averaged perceptron.
Yet, CRF still had the best baseline performance with only local features.
The proposed algorithm with non-local features improved the performance on the test set by 0.66 points over that of the margin perceptron without non-local features.
The row “Candidate” refers to the candidate algorithm (Algorithm 4.1).
From the results for the candidate algorithm, we can see that the modiﬁcation part, (B), in Algorithm 4.2 was essential to make learning with non-local features effective.
We next examined the effect of n′.
As can be seen from Table 3, an n′ larger than that for training yields higher performance.
The highest performance with the proposed algorithm was achieved when n′ = 6400, where the improvement due to non-local features became 0.74 points.
The performance of the related work (Finkel et al., 2005; Krishnan and Manning, 2006) is listed in Table4.
Wecanseethattheﬁnalperformanceofour algorithm was worse than that of the related work.
We changed the experimental setting slightly to investigate our algorithm further.
Instead of Table 4: The performance of the related work.
Method dev test Finkel et al., 2005 (Finkel et al., 2005) baseline CRF 85.51 + non-local features 86.86 Krishnan and Manning, 2006 (Krishnan and Manning, 2006) baseline CRF 85.29 + non-local features 87.24 Table 5: Summary of performance with POS/chunk tags by TagChunk.
Method dev test C (or σ2) local features CRF 91.39 86.30 200 Perceptron 89.36 84.35 Averaged perceptron 89.76 84.50 Margin perceptron 91.06 86.24 32000 + non-local features Proposed (n′ = 100) 92.23 87.04 5657 Proposed (n′ = 6400) 92.54 87.17 5657 the POS/chunk tags provided in the CoNLL 2003 dataset, we used the tags assigned by TagChunk (Daum´e III and Marcu, 2005)10 with the intention of using more accurate tags.
The results with this setting are summarized in Table 5.
Performance was better than that in the previous experiment for all algorithms.
We think this was due to the quality of the POS/chunk tags.
It is interesting that the effect of non-local features rose to 0.93 points with n′ = 6400, even though the baseline performance was also improved.
The resulting performance of the proposed algorithm with non-local features is higher than that of Finkel et al.(2005) and comparable with that of Krishnan and Manning (2006).
This comparison, of course, is not fair because the setting was different.
However, we think the results demonstrate a potential of our new algorithm.
The effect of BPM initialization was also examined.
The number of BPM runs was 10 in this experiment.
The performance of the proposed algorithm dropped from 91.95/86.30 to 91.89/86.03 without BPM initialization as expected in the setting of the experiment of Table 2.
The performance of the margin perceptron, on the other hand, changed from 90.98/85.64 to 90.98/85.90 without BPM initialization.
This result was unexpected from the result of our preliminary experiment.
However, the performance was changed from 91.06/86.24 to 10http://www.cs.utah.edu/˜hal/TagChunk/ 321 Table 6: Comparison with re-ranking approach.
Method dev test C local features Margin Perceptron 91.06 86.24 32000 + non-local features Re-ranking 1 (n′ = 100) 91.62 86.57 4000 Re-ranking 1 (n′ = 80) 91.71 86.58 4000 Re-ranking 2 (n′ = 100) 92.08 86.86 16000 Re-ranking 2 (n′ = 800) 92.26 86.95 16000 Proposed (n′ = 100) 92.23 87.04 5657 Proposed (n′ = 6400) 92.54 87.17 5657 Table 7: Comparison of training time (C = 5657).
Method dev test time (sec.) local features Margin Perceptron 91.04 86.28 15,977 + non-local features Re-ranking 1 (n′ = 100) 91.48 86.53 86,742 Re-ranking 2 (n′ = 100) 92.02 86.85 112,138 Proposed (n′ = 100) 92.23 87.04 28,880 91.17/86.08 (i.e., dropped for the evaluation set as expected), in the setting of the experiment of Table 5.
Since the effect of BPM initialization is not conclusive only from these results, we need more experiments on this.
6.3 Comparison
with re-ranking approach Finally, we compared our algorithm with the reranking approach (Collins and Duffy, 2002; Collins, 2002b), where we ﬁrst generate the n-best candidates using a model with only local features (the ﬁrst model) and then re-rank the candidates using a model with non-local features (the second model).
We implemented two re-ranking models, “reranking 1” and “re-ranking 2”.
These models differ in how to incorporate the local information in the second model.
“re-ranking 1” uses the score of the ﬁrst model as a feature in addition to the non-local features as in Collins (2002b).
“re-ranking 2” uses the same local features as the ﬁrst model11 in addition to the non-local features.
The ﬁrst models were trained using the margin perceptron algorithm in Algorithm 3.1.
The second models were trained using the algorithm, which is obtained by replacing {yn} with the n-best candidates by the ﬁrst model.
The ﬁrstmodelusedtogeneraten-bestcandidatesforthe development set and the test set was trained using the whole training data.
However, CRFs or perceptrons generally have nearly zero error on the training data, although the ﬁrst model should mis-label 11The weights were re-trained for the second model.
to some extent to make the training of the second model meaningful.
To avoid this problem, we adopt cross-validation training as used in Collins (2002b).
Wesplitthetrainingdatainto5sets. Wethentrained ﬁve ﬁrst models using 4/5 of the data, each of which was used to generate n-best candidates for the remaining 1/5 of the data.
As in the previous experiments, we tuned C using the development set with n′ = 100 and then tested othervaluesforn′.
Table6showstheresults. Ascan be seen, re-ranking models were outperformed by our proposed algorithm, although they also outperformed the margin perceptron with only local features (“re-ranking 2” seems better than “re-ranking 1”).
Table 7 shows the training time of each algorithm.12 Our algorithm is much faster than the reranking approach that uses cross-validation training, while achieving the same or higher level of performance.
7 Discussion
As we mentioned, there are some algorithms similar to ours (Collins and Roark, 2004; Daum´e III and Marcu, 2005; McDonald and Pereira, 2006; Liang et al., 2006).
The differences of our algorithm from these algorithms are as follows.
Daum´e III and Marcu (2005) presented the method called LaSO (Learning as Search Optimization), in which intractable exact inference is approximated by optimizing the behavior of the search process.
The method can access non-local features at each search point, if their values can be determinedfromthesearchdecisionsalreadymade.
They provided robust training algorithms with guaranteed convergence for this framework.
However, a difference is that our method can use non-local features whose value depends on all labels throughout training, and it is unclear whether the features whose values can only be determined at the end of the search (e.g., majority features) can be learned effectively with such an incremental manner of LaSO.
The algorithm proposed by McDonald and Pereira (2006) is also similar to ours.
Their target was non-projective dependency parsing, where exact inference is intractable.
Instead of using 12Training time was measured on a machine with 2.33 GHz QuadCore Intel Xeons and 8 GB of memory.
C was ﬁxed to 5657.
322 n-best/re-scoring approach as ours, their method modiﬁes the single best projective parse, which can be found efﬁciently, to ﬁnd a candidate with higher score under non-local features.
Liang et al.(2006) used n candidates of a beam search in the Collins’ perceptron algorithm for machine translation.
CollinsandRoark(2004)proposedanapproximate incremental method for parsing.
Their method can be used for sequence labeling as well.
These studies, however, did not explain the validity of their updating methods in terms of convergence.
To achieve robust training, Daum´e III and Marcu (2005) employed the averaged perceptron (Collins, 2002a) and ALMA (Gentile, 2001).
Collins and Roark (2004) used the averaged perceptron (Collins, 2002a).
McDonald and Pereira (2006) used MIRA (Crammer et al., 2006).
On the other hand, we employed the margin perceptron (Krauth and M´ezard, 1987),extendingittosequencelabeling.
Wedemonstrated that this greatly improved robustness.
With regard to the local update, (B), in Algorithm 4.2, “early updates” (Collins and Roark, 2004) and “y-good” requirement in (Daum´e III and Marcu, 2005) resemble our local update in that they tried to avoid the situation where the correct answer cannot be output.
Considering such commonality, the way of combining the local update and the non-local updatemightbeoneimportantkeyforfurtherimprovement.
It is still open whether these differences are advantages or disadvantages.
However, we think our algorithm can be a contribution to the study for incorporating non-local features.
The convergence guarantee is important for the conﬁdence in the training results, although it does not mean high performance directly.
Our algorithm could at least improve the accuracy of NER with non-local features and it was indicated that our algorithm was superior to the re-ranking approach in terms of accuracy and training cost.
However, the achieved accuracy was not better than that of related work (Finkel et al., 2005; Krishnan and Manning, 2006) based on CRFs.
Although this might indicate the limitation of perceptron-based methods, it has also been shown that there is still room for improvement in perceptron-based algorithms as our margin perceptron algorithm demonstrated.
8 Conclusion
In this paper, we presented a new perceptron algorithm for learning with non-local features.
We think the proposed algorithm is an important step towards achieving our ﬁnal objective.
We would like to investigate various types of new non-local features using the proposed algorithm in future work.
Appendix A: Convergence of Algorithm 4.2 Letαk be a weight vector before the kth update and epsilon1k be a variable that takes 1 when the kth update is done in (A) and 0 when done in (B).
The update rule can then be written asαk+1 = αk +epsilon1k(Φa∗−Φa + (1−epsilon1k)(Φl∗ −Φl).13 First, we obtain αk+1 ·Ul = αk ·Ul + epsilon1k(Φa∗ ·Ul −Φa ·Ul) +(1−epsilon1k)(Φl∗ ·Ul −Φl ·Ul) ≥ αk ·Ul + epsilon1kδ + (1−epsilon1k)δ = αk ·Ul + δ ≥ α1 ·Ul + kδ = kδ Therefore, (kδ)2 ≤ (αk+1 · Ul)2 ≤ (||αk+1||||Ul||)2 = ||αk+1||2 — (1).
On the other hand, we also obtain ||αk+1||2 ≤ ||αk||2 + 2epsilon1kαk(Φa∗ −Φa) +2(1−epsilon1k)αk(Φl∗ −Φl) +{epsilon1k(Φa∗ −Φa) + (1−epsilon1k)(Φl∗ −Φl)}2 ≤ ||αk||2 + 2C + R2 ≤ ||α1||2 + k(R2 + 2C) = k(R2 + 2C)— (2) We used αk(Φa∗ − Φa) ≤ Ca, αk(Φl∗ − Φl) ≤ Cl and Cl = Ca = C to derive 2C in the second inequality.
We used||Φl∗−Φl|| ≤ ||Φa∗−Φa|| ≤ R to derive R2.
Combining (1) and (2), we obtain k ≤ (R2 + 2C)/δ2.
Substituting this into (2) gives ||αk|| ≤ (R2+2C)/δ.
Sincey∗ = y′ andΦa∗·α−Φa′′·α > C after convergence, we obtain γ′(α) = minx i Φa∗ ·α−Φa′′ ·α ||α|| ≥ Cδ/(2C + R 2).
13We use the shorthand Φa∗ = Φa(xi,y∗ i), Φ a = Φa(xi,y), Φl∗ = Φl(xi,y∗i), and Φl = Φl(xi,y) where y represents the candidate used to update (y′, y′′, y1, or y2).
323 References D.
M. Bikel, R.
L. Schwartz, and R.
M. Weischedel.
1999. An algorithm that learns what’s in a name.
Machine Learning, 34(1-3):211–231.
R. Bunescu and R.
J. Mooney.
2004. Collective information extraction with relational markov networks.
In ACL 2004.
S. F.
Chen and R.
Rosenfeld. 2000.
A survey of smoothing techniques for ME models.
IEEE Transactions on Speech and Audio Processing, 8(1):37–50.
M. Collins and N.
Duffy. 2002.
New ranking algorithms for parsing and tagging: Kernels over discrete structures, and the voted perceptron.
In ACL 2002, pages 263–270.
M.Collins and B.Roark. 2004.
Incremental parsing with the perceptron algorithm.
In ACL 2004.
M. Collins.
2002a. Discriminative training methods for hidden Markov models: Theory and experiments with perceptron algorithms.
In EMNLP 2002.
M. Collins.
2002b. Ranking algorithms for named-entity extraction: Boosting and the voted perceptron.
In ACL 2002.
K. Crammer, O.
Dekel, J.
Keshet, S.
Shalev-Shwartz, and Y.
Singer. 2006.
Online passive-aggressive algorithms.
Journal of Machine Learning Research.
H. Daum´e III and D.
Marcu. 2005.
Learning as search optimization: Approximate large margin methods for structured prediction.
In ICML 2005.
J. R.
Finkel, T.
Grenager, and C.
Manning. 2005.
Incorporating non-local informationin to information extraction systems by Gibbs sampling.
In ACL 2005.
C. Gentile.
2001. A new approximate maximal margin classiﬁcation algorithm.
JMLR, 3.
R. Herbrich and T.
Graepel. 2000.
Large scale Bayes point machines.
In NIPS 2000.
W. Krauth and M.
M´ezard. 1987.
Learning algorithms with optimal stability in neural networks.
Journal of Physics A 20, pages 745–752.
V. Krishnan and C.
D. Manning.
2006. An effective two-stage model for exploiting non-local dependencies in named entity recognitioin.
In ACL-COLING 2006.
J. Lafferty, A.
McCallum, and F.
Pereira. 2001.
Conditional random ﬁelds: Probabilistic models for segmenting and labeling sequence data.
In ICML 2001, pages 282–289.
Y. Li, H.
Zaragoza, R.
Herbrich, J.
Shawe-Taylor, and J.
Kandola. 2002.
The perceptron algorithm with uneven margins.
In ICML 2002.
P. Liang, A.
Bouchard-Cˆot´e, D.
Klein, and B.
Taskar. 2006.
An end-to-end discriminative approach to machine translation.
In ACL-COLING 2006.
R. McDonald and F.
Pereira. 2006.
Online learning of approximate dependency parsing algorithms.
In EACL 2006.
R. McDonald, K.
Crammer, and F.
Pereira. 2005.
Online large-margin training of dependency parsers.
In ACL 2005.
T. Nakagawa and Y.
Matsumoto. 2006.
Guessing parts-of-speech of unknown words using global information.
In ACL-COLING 2006.
L. R.
Rabiner. 1989.
A tutorial on hidden Markov models and selected applications in speech recognition.
Proceedings of the IEEE, 77(2):257–286.
L. A.
Ramshaw and M.
P. Marcus.
1995. Text chunking using transformation-based learning.
In third ACL Workshop on very large corpora.
F. Rosenblatt.
1958. The perceptron: A probabilistic model for information storage and organization in the brain.
Psycological Review, pages 386–407.
D. Roth and W.
Yih. 2005.
Integer linear programming inference for conditional random ﬁelds.
InICML 2005.
S. Sarawagi and W.
W. Cohen.
2004. Semi-Markov random ﬁelds for information extraction.
In NIPS 2004.
L. Shen and A.
K. Joshi.
2004. Flexible margin selection for reranking with full pairwise samples.
In IJCNLP 2004.
F. K.
Soong and E.
Huang. 1991.
A tree-trellis based fast search for ﬁnding the n best sentence hypotheses in continuous speech recognition.
In ICASSP-91.
C. Sutton and A.
McCallum. 2004.
Collective segmenation and labeling of distant entitites in information extraction.
University of Massachusetts Technical Report TR 04-49.
B. Taskar, C.
Guestrin, and D.
Koller. 2003.
Max-margin Markov networks.
In NIPS 2003.
E. F.
Tjong, K.
Sang, and F.
De Meulder.
2003. Introduction to the CoNLL-2003 shared task: Language-independent named entity recognition.
In CoNLL 2003.

