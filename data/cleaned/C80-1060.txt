AUTOMATIC TRANSLATION WITH ATTRIBUTE GRAMMARS Werner Dilger University of Kaiserslautern Computer Science Department D-6750 Kaiserslautern Federal Republic of Germany Summary Starting from an ATN-grammar and translation rules assigning expressions of a predicate calculus language to the symbols of the grammar one can produce an attribute grammar for the translation of natural language sentences (here German) into expressions of the predicate calculus language.
The paper illustrates that this can be done in a straightforward way and outlines further improvements of the resulting attribute grammar.
Introduction An important component of the natural language information system PLIDIS, developped by my colleagues and myself at the Institut fuer deutsche Sprache in Mannheim (cf.
\[BW 78\], \[KL 79\]), is the translation algorithm, which transduces natural language sentences into expressions of an augmented first order predicate calculus, called KS (cf.
\[DZ 78\],\[Zi 77\]).
Special features of KS going beyond ordinary predicate calculus are many-sorted domain of objects, l-abstraction, and complex term-building facilities.
The examples contained in this paper will illustrate these features.
Input for the translation algorithm are the parsed sentence and a set of translation rules (in the following: TR-rules) (cf.
\[Wu 79\]), which are defined for labels of the parse tree nodes, mainly for the labels of the terminal nodes, i.
e. for the words of the input sentence.
Working bottom up the parse tree the translation algorithm assigns a translation to each of the nodes of the tree by interpreting the TR-rules defined for the labels of the nodes.
If a translation has been successfully assigned to the root of the tree, which is labelled by S, this translation is the translation of the whole sentence.
The advantage of the translation algorithm, the most important part of which is the interpretation of the TR-rules, is its rather simple structure, which facilitated implementation.
But it also has several disadvantages.
First of all the algorithm is not very efficient since it runs separately from parsing, i.
e. it does not start before parsing has finished.
The TR-rules must take care of the structure of the parse tree, that means, during their interpretation we must check which steps were made in parsing some relevant part of the tree.
Next, the TR-rule for the label of a node must be completely evaluated, though it depends on the position of the node in the tree, which parts of the rule apply to the node or whether the rule applies as a whole.
Finally it is difficult to detect circularities in the translation process on the basis of the TR-rules.
To avoid these disadvantages we can use attribute grammars for the translation.
The content of the TR-rules must then be represented by attributes and semantic functions.
But for this purpose we need a context free grammar as a basis of the parsing.
In PLIDIS, however, we have no such grammar, parsing is done by means of an ATN-grammar (cf.
\[Wo 70\], \[Wo 73\], \[Ba 78\], \[EL 79\]), adapted for German.
Though the networks of the ATN-grammar are not context free productions, we can produce such productions out of them.
At first glance, by doing so, the contextsensitivity of the networks which is their main advantage is lost.
But we can regain it by providing the productions with appropriate attributes and semantic functions.
If we take a simpler version of the ATN-grammar, namely the RTN-grammar ("recursive transition networks") (cf.
\[Wo 70\]), then an ATN-grammar is nothing else but an attributed RTN-grammar; so we could read the letters "ATN" as "attributed transition networks" instead of "augmented transition networks".
In the remainder of the paper we omit the attributes needed to express context conditions, we only deal with those needed for translation.
To summarize, we have to show how to obtain context free productions from the networks and attributes and semantic functions from the TRrules.
We will demonstrate by examples that the method is straightforward, and we will outline how the resulting attribute grammar can be improved.
ATN-grammars and TR-rules We want to parse the following questions asking for facts of the PLIDIS mini-world, i.e. the control of water pollution: Enthielt eine Probe im Jahr 1979 in Stuttgart Arsen?
Did a sample in 1979 in Stuttgart contain arsenic?
Welche Betriebe in Stuttgart hat Zimpel im Jahr 1979 geprOft? which plants in Stuttgart Zimpel has inspected in 1979?
Welche Betriebe hat Zimpel im Jahr 1979 in Stuttgart gepr~ft? which plants Zimpel has inspected in 1979 in Stuttgart? --397-Welche Betriebe der Firma Lauxmann in Stuttgart hat Zimpel gepr~ft?
Which plants of the firm Lauxmann in Stuttgart Zimpel has inspected?
Welcher Probenehmer hat bei der Firma Lauxmann im Jahr 1979 Proben gezogen?
Which sampler has taken a sample from the firm Lauxmann in 1979?
We will give a small section of the ATN-grammar used within PLIDIS, reduced to an RTN-gr~mnar, which allows the parsing of these questions.
The networks and word classes of fig.
i are needed for this purpose.
NG PNG NG PNG _ w oq_/2Q/2 DET N AUXH: {hob} have DET = (der, die, das, ein, eine} the, a N = (Probe, Probenehmer, Jahr, Betrieb, Firma, Arsen} sample, sampler, year, plant, firm, arsenic NPR = {Stuttgart, Zimpet, Lauxmann} PRAEP = {in, bei} in, at VERB = {enthalt, pr~f, zieh} contain, inspect, take WDET= {welch} which Figure 1 We obtain by means of this grammar for the question Welche Betriebe in Stuttgart hat Zimpel im Jahr 1979 gepr0ft?
Which plants in Stuttgart Zimpel has inspected in 1979? the parse tree of fig.
2. We will now give TR-rules for the labels of some of the nodes occurring in fig.
2, using small 0~_ c g z _~-b f "N~ Q: • "~2 m o ~ z X ~ : • *lEE •,,=._ ~.c m 2= : u,~ e4 u_ diagrams which represent sections of possible parse trees.
The triangles in these diagrams denote arbitrary (perhaps empty) subtrees.
Because the TR-rules are defined for single symbols of the grammar regardless of their occurrences in parse trees, all possible natural language occurrences of the symbols must be described and dealt with in the TR-rules.
Therefore in the following TR-rules not all conditions will be immediately clear.
But that doesn't matter since we are not interested in the details of the TRrules, rather we will show below how the TRrules can be transformed into expressions containing attributes and semantic functions.
398 Betrieh (plant): if ~ an d sort(translat(Y)) = iBetrieb i if ¶#ont\].~.
a then i 'w'~'~ and sort(tr nslat / &Betrieb then translat(Betrieb) = \[LAMBDA X.BETR \[BETRIEB translat(Y) translat(PNG) X.BETR\]\] else translat(Betrieb) = \[LAMBDA X.BETR ~ \[BETRIEB translat(Y) X.ORT X.BETR\]\] else if~pN an ~ sort(translat(PNG)) = ORT ~Betrieb then translat(Betrieb) = \[LAMBDA X.BETR \[BETRIEB X.INDUSTRIE translat(PNG) X.BETR\]\] else translat(Betrieb) = \[LAMBDA X.BETR \[BETRIEB X.INDUSTRIE X.ORT X.BETR\]\] in: i..._,.f..
N~,pRNAGEp • in and N~yNG an d Y6 {N,NPR} and sort(translat (Y)) = ORT then translat(in) = \[LAMBDA X.ORT \[IN translat(Y) X.ORT\] \] else if N~p and NAy NO and in sort(translat(Y)) _~ INT then translat (in) = \[LAMBDA X.
INT\[INTEMP translat(Y) X.INT\]\] else if ~ and so ranslat (NG)) ~INT &in then translat(in) = \[LAMBDA X.INT \[INTEMP translat(NG) X.INT\]\] else translat(in) = 0o Stuttgart: translat(Stuttgart) = STUTTGART M: if ~ and Z' 6 {NG,PNG} and ~Z~' ~NG ((z6 {Monat,Jahr} and cat(translat(Y)) = KONST and sort(translat(Y)) = INT) o r(YE {N,NPR} and cat(translat(Y)) = TERM and cat(translat(Z)) = LTERM and sort(translat(Y)) = sort(translat(Z)))) then translat(N) = The else-part here is assumed to be substituted by the general rule prescribing that whenever a TR-rule does not apply, the translation of the node will be the translation of one of its daughter nodes, e.g. here we could write: else translat(N) = translat(Z) From the TR-rule for PNG we will only give some part: PNG : i_~ ~NG and cat (translat (N)) KONST then if ~PNG an d Y6 {DET,QDET,WDET,NEGPET, ZAHL } and cat (translat (Y)) = QUANT o¥ then if cat(translat(PRAEP)) = LTERM then translat(PNG) = \[translat(Y) translat(PRAEP) \] else translat(PNG) = -\[translat(Y) translat(N) \] else if cat(translat(?RAEP)) = LTERM then translat(PNG) = \[\[QUANT EIN\] translat(PRAEP) \] else translat(PNG) = -\[\[QUANT EIN\] translat(N)\] As with the rule for N the else-part is omitted here too.
Applying these TR-rules to the section of the parse tree of fig.
2 represented in fig.
3, we get as translation of this section: \[LAMBDA X.BETR \[BETRIEB X.INDUSTRIE \[~AMBDA X.ORT\[IN STUTTGART X.ORT\]\] x.
BETR \] \] --399-S Betriebe m Stuttgart plants in Stuttgart Figure 3 Transformation of the networks into context free _pro duc tiOns The first step is to produce sets of productions by means of the inscriptions of the nodes and edges, the right hand sides of which consist of at most two symbols.
s ÷ VERB S/VK I S/VK S/VK÷NG S/VK PNG S/VK AUXH S/~ \] ? S/S S/AA + NG S/AA PNG S/AA HSVK S/VERB S/VERB ÷ ? S/S S/S ÷ PNG + PRAEP NG NG ÷ DET NG/DET \[ NDET NG/DET \[ NG/DET DATUMSZAHL NG/NG NG/DET ÷ N NG/NG \[ NPR NG/NG NG/NG ÷ HSVK ÷ VERB HSVK/VK \] HSVK/VK HSVK/VK ÷ ¢ In the next step the sets of productions are combined for each network to a single production the right hand side of which consists of a regular expression.
The set for PNG is duplicated, omitting PRAEP, to get a separate production for NG.
S ÷ (VERBle) (NG\]PNG) @(AUxH(NG\[PNG) eHSVK ? \[ )?
PNG ÷ PRAEP((DET\]WDET\]¢) (N\]NPR) \]DATUMSZAHL) NG ÷ (DET\[WDET\[ ¢) (NINPR) I DATUMSZAHL HSVK ÷ VERBI ¢ NOW these productions are transformed step by step into "disjunctive normal form", where sequencing (represented by Juxtaposition) corresponds to the logical "and", \[ corresponds to the logical "or".
S ÷ (VERB\[E) (NGePNG e) e(AUXH(NGePNG e) eHSVK ? \[ )? e e % m e S ÷ (VERB e)(NG PNGe) eAUXH(NG PNG ) HSVK ? I (VERB ¢)(NG PNG ) ? S ÷ VERB(NGePNG~)wAUXH(NGePNGe)eHSVK ? I (NGWPNGe)~AUXH(NGePNGe)eHSVK ? \] VERB(NG~PNG~)%?
I (NGePNGe)e?
PNG ÷ P~EP (DET I WDET I ~ ) (N I NPR) I PRAEP DATUMSZAHL PNG ÷ PRAEP DET N I PRAEP WDET N I PRAEP N I PRAEP DET NPR \[ Pm~EP WDET NPR I PRAEP NPR \[ PRAEP DATUMSZAHL NG ÷ DET N I WDET N I N I BET NPR I WDET NPR I NPR I DATUMSZAHL Finally those parts provided with e are removed introducing new symbols and productions.
S ÷ VERB NG/PNG AUXH NG/PNG HSVK ? I NG/PNG AUXH NG/PNG HSVK ? I VERB NG/PNG ? I NG/PNG ? NG/PNG ÷ NG NG/PNG \[ PNG NG/PNGI NGI PNGI c If we form sets of productions out of the word classes, we get altogether: S ÷ VERB NG/PNG AUXH NG/PNG HSVK ? I NG/PNG AUXH NG/PNG HSVK ? I VERB NG/PNG ? \] NG/PNG ? NG/PNG ÷ NG NG/PNG \[ PNG NG/PNG \[ NG \[ PNG\[ PNG ÷ P~EP DET N I P~EP ~ET N I P~EP N \] PRAEP DET NPR \[ P~BP MET NPR I PRAEP NPR I PRAEP DATUMSZAHL NG ÷ DET N I WDET N I N I DET NPR I WDET NPR 1 NPR \] DATUMSZAHL HSVK + VERB I e AUXH ÷ hab DET ÷ der die I des \[ sin Ieine N ÷ Probe Probenehmer I Jahr I Betrieb I Firma Arsen NPR ÷ Stuttgart \[ Zimpel I Lauxmann PRAEP ÷ in I bei VERB + enthalt I prfif I zieh WDET + welch The parsing of our question example by means of these productions yields the parse tree of fig.
4. The section of this tree corresponding to that of fig.
3 is represented in fig.
5. Providing the productions with attributes We will now give a list of attributes and semantic functions for the productions and augment the productions by them such that the evaluation of the semantic functions yields the translation of the sentence.
We will do this only for those productions needed for the section of fig.
5. --400-welche Betriebe which plonts hat has IPR Zimpel Zimpel Stuttgart in d;s Jahr Stuttgart in the year Figure 4 NG T NG/PNG / in Stuttgart in Stuttgart Figure 5 VERB' I pr~f inspect, NG 79 DATUMSZAHL name +val +tree +tree %pos name cat sort symb nth valu~ del class synthesized synthesized inherited inherited Attributes domain n-tuple of KS-expressions (translations), in general n = 1 sets of triples, consisting of the position of a symbol in the parse tree, the symbol itself, and the value of the symbol same as with +tree finite sequences of positive integers, separated by dots mnemotechnb cate~ gory sort symbol n-th (=last elemen value delete Semantic functions argument translation t translation t position P position P position P position P use yields the KS-syntactic category of t yields the sort of t yields from %tree the symbol of the node with position p yields the last integer of p yields from +tree the value of the node with position p replaces in +tree the value of the node with position p by +val is the most important attribute, for it contains the translation of a node.
The other attributes are auxiliary attributes.
+tree contains in each node a relevant section of the parse tree with all necessary informations about the nodes of that section, namely their labels and their values.
Already Knuth (\[Kn 68\]) has given a technique for representing the attribute values of all other nodes at each node of the tree.
We adopt this technique here in a slightly modified way since it offers an elegant way to rewrite the conditions of the TR-rules as expressions containing semantic functions and attributes for appropriate productions.
We will illustrate how this technique works, using the structure of fig.
5. The only information we are interested in for this example are the labels of the nodes.
Let X ° + X I X 2 ...
X n (n ~ O) be a production, where the X.
(i = l,...,n) are terminal or nonterminal symbols.
If n=O, X is terminal.
Then: o --401-+pos(X i +tree(X ) =1 ) = {+p,oS(Xo)'i,.
if Xif X ° =# SS o +tree(X ), if X # S o +tree(X.), if X ° = S 1 o \[(+pos (x o),x o)} n +tree (X) = o U U +tree(Xi), if X ° # S i=l n U+tree(X')' if X = S l o i=l We can easily obtain the +pos-value for each node of fig.
5 beginning with the NG/PNG-node which is dominated by the S-node and for which we assume: +pos(NG/PNG) = k.
The +pos-values are given in fig.
6. Using these values, we obtain e.g.
+tree(PNG) = ~k.2.1,PNG), (k.2.1.1,PRAEP), (k.2.1.1.l,in), (k.2.1.2,NPR), (k.2.1.2.l,Stuttgart)} The +tree-value for NG/PNG (and thus for all other nodes) is +tree(NG/PNG) = {(k,NG/PNG), (k.i,NG), (k.l.l,N), (k.l.l.l,Betriebe), (k.2,NG/PNG), (k.2.1,PNG), (k.2.1.1,PRAEP), (k.2.1.1.l,in), (k.2.1.2,NPR), (k-2.1 • 2.
i, Stuttgart)} In order to obtain the values of attributes defined for the productions it is often necessary to determine a new position starting from a given one.
For this purpose some of the integers at the end of the position must be omitted or others must be appended.
If the last integer of the position belonging to symbol X shall be omitted we write = "NG ~ NG/PNG,!,pos =k.1 ~pos=k.2 ~pos=k4 1 ~ PNG k-2.1 Betriebe PR/AEP ~NPR in ~5tuttgart,I, pos =k.2.1.1.1 Spos=k.2.12'1 Figure 6 +pos (x) -i If the last two integers shall be omitted, we write +pos(X\]-2 etc.
If an integer, say k, shall be appended j times, we write +pos(X)'k j Now we are ready to give the productions needed for the structure of fig.
5, provided with attributes and semantic functions.
N ÷ Betrieb if symb(+pos(N)-l)ENG,PNG} A symb((+pos(N)-2).2.1)=NG ^ ((symb(%pos(N).l)eMonat,Jahr)} A 3j>O: cat(value((+pos(N)-2).2.l.j )=KONST ^ sort(value((+pos(N)-2).2.1.j))=INT) v (3j>O: symb((+pos(N)-2).2.l.j)EN,NPR} ^ cat (value ( (+pos (N) -2) • 2.1 .j) ) =TERM ^ cat (value ( +pos (N) • i ) ) =LTERM A sort (value (+pos (N) • 1 ) )= sort (value ( (+pos (N) -2) • 2.1 • j))) ) then +val(N) = else if sort(value((+pos(N)-l).2.1))=INDUSTRIE -then if 39>0: symb((+pos(N)-l).2J.l)=PNG sort(value((+pos(N)-l).2J.l)) =ORT then +val(N) = \[LAMBDA X.BETR\[BETRIEB value((+pos(N)-l).2.1) value((+pos(N)-l).2J.l) ×.BETR\]\] del((+pos(N)-1).2.1) del((+pos(N)-l).2J.l) else +val(N) = \[LAMBDA X.BETR\[BETRIEB value((+pos(N)-1).2.1) x.oRT X.B~TR\]\] del((+pos(N)-l),2.1) else if 3j>O: symb((+pos(N)-l),2J,l)=PNG sort(value((+pos(N)-l),2J,l)) =ORT then +val(N) = \[LAMBDA X.BETR\[BETRIEB X.INDUSTRIE value((+pos(N)-l)o2J,l) X.BETR\]I del((+pos(N)-l),2\],l) else +val(N) = \[LAMBDA X.BETR\[BETRIEB X.INDUSTRIE X.ORT X.BETR\]\] +tree(N) = {(+pos(N),N,+val(N)), (+pos(Betrieb),Betrieb,~)} +pos(Betrieb) = +pos(N).l The first part of the expression needed to determine the value of +val(N) comes from the TRrule for N, the second part from the TR-rule for Betrieb (plant).
For the symbol NG there is a TR-rule too.
We omit it here, because it does not apply to our example.
Therefore we deal with the production NG ÷ N in such a way, as if there were no TRrule for NG.
--402-NG ÷N i_~ value (+poe (N)) = ~0 then +val (NG) = else +val (NG) = +val (N) +tree(NS) = { (+pos(NG),NG,+vai(NG)) } U +tree(N) +tree(N) = +tree(NG) +poe(N) = +pos(NG),i PRAEP ÷ in if symb(+pos(PRAEP)-l) = PNG then if Hj#nth (4-poe (PRAEP)) : symb((+pos(PRAEP)-l).j eN,NPR} A sot t (value ( ( +pos (PRAEP) 1 ) ° j ) ) =ORT then +val (PRAEP) = \[LAMBDA X.ORT\[IN value ( (+poe (PRAEP) -i ) • j ) X.ORT\]\] de i ( ( +pos (PRAEP) i ) • j ) else if 3j#nth (+pos (PRAEP)) : sort (value ((+pos (PRAEP) "i ) .j ) ) g_ INT then +val (PRAEP) = \[LAMBDA X.
INT \[ INTEMP value ( (+poe (PRAEP) -i ) • j ) x.
IN~\] \] del ( (+poe (PRAEP) -i ) .j) else if ~j>O: symb((+po.s(PRAEP)-2) • 23.1) = NG sort (value ( ( +poe (PRAEP) -2).2J.i)) _~ INT then +val (PRAEP) = \[LAMBDA X, INT \[INTEMP value ( (+poe (PRAEP) -2),2J*l) X.
INT\] \] del ((+pos (PRAEP)-2) .23.
i) else +val (PRAEP) = else +val (PRAgP) = 0~ +tree (PRAEP) = { (+poe (PRAEP),PRAEP, +val (PRAEP)), (+poe (in),in,00) } +poe (in) : +poe (PRAEP) 'I NPR ÷ Stuttgart +val (NPR) = STUTTGART +tree (NPR) = { (+poe (NPR),NPR, +val (NPR)), (+poe (Stuttgart), Stuttgart, 0~) } +poe (Stuttgart) = +poe (NPR) .I PNG ÷ PRAEP NPR if ~j>o: symb(+pos(PNG) .j) = N cat(value(+pos(PNG).j)) ~ KONST then if 3i>O: symb (+poe (PNG) °i) EDET,QDET,WDET, NEGDET, ZAHL } cat (value (+poe (PNG) • i) ) = QUANT then if cat(+val(PRAEP)) = LTERM then +val (PNG) = \[value (%poe (PNG) .i) +val (PRAEP) \] del (+poe (PNG) • i) del (+poe (PRAEP)) else +vai(PNG) = \[value(+pos(PNG).i) value (+poe (PNG) .j ) \] del (+poe (PNG) .i) del (+poe (PNG) .j) else if cat(+val (PRAEP)) = LTERM then +val (PNG) = \[EIN +val (PRAEP) \] del (+poe (PRAEP)) else +val (PNG) = \[EIN value (+poe (PNG) "j)\] del (+poe (PNG) .j ) else if +val (PRAEP) = ~0 then +val (PNG) = +val (NPR) else +val (PNG) = +val (PRAEP) +tree (PNG) = { (+poe (PNG),PNG, +val (PNG)) } U +tree(PRAEP) U +tree(NPR) +tree (PRAEP) = +tree (PNG) %tree(NPR) = +tree(PNG) %poe (PRAEP) = +poe (PNG) .i +poe (NPR) = +poe (PNG) .2 NG/PNG ÷ PNG if value (+poe (PNG)) = ~0 then +val (NG/PNG) = 00 else +val (NG/PNG) = +val (PNG) +tree(NG/PNO) = {(+pos(NS/PNS),NG/PNG, +val (NG/PNG)) } U +tree (PNG) +tree(PNG) = +tree(NG/PNG) +poe (PNG) = +poe (NG/PNG) • 1 NG/PNG 1 ÷ NG NG/PNG~ if value (+poe (NG)) = then +val (NG/PNG i) = +val (NG/PNG 2) else if value (+poe (NG/PNGs)) = 0~ then +val (NG/PNG 1) = +val (NG) else +val (NG/PNG 1) = (+val (NG), +val (NG/PNG~)) +tree (NG/PNG I ) = {(+poe (NG/PNG 1 ),NG/PNG, +val (NG/PNG 1))} U +tree(NG) U +tree (NG/PNG 2) +tree(NG) = +tree(NG/PNG 1) +tree (NG/PNG2) = +tree (NG/PNG I) +pos(NG) = +pos(NG/PNG 1).I +poe (NG/PNGe) = +poe (NG/PNG 1) .2 With these productions we obtain immediately the value of the +tree-attribute for each node of the structure of fig.
5 or 6, when we postpone the evaluation of the +val-attribute.
The value is { (k,NG/PNG, +val (NG/PNG)), (k*l,NG, +val (NG)), (k.l *i,N, +val (N)), (k.l .i .l, Betriebe,00), (k.2, NG/PNG, +val (NG/PNG)), (k.2.1,PNG, +val (PNG)), (k.2.1.1,PRAEP,+Vai(PRAEP)), (k.2.1.1.l,in,~), (k.2°i°2,NPR,+vai(NPR)), (k.2.l.2.l,Stuttgart,~)} The production NPR + Stuttgart yields +val (NPR) = STUTTGART We can substitute this value in %tree or regard "+val (NPR)" as a pointer to this value.
Now we try to determine +val (PRAEP) from the production PRAEP ÷ in.
First we have symb(+pos(PRAEP)-l) = symb(k.2.1°l i~ = svmb(k.2.1) = PNG That is, the first condition holds.
Next nth (+poe (PRAEP)) = i therefore j>l.
Assume j=2.
Then symb((+pos(PRAEP)-l).j) = symb((k.2.1.1 I).2) = symb(k.2.1.2) = NPR --403-Further sort(value((+pos(PRAEP)-l).2)) = sort(value(k.2.1.2)) = sort(STUTTGART) = ORT The second condition holds too, thus we get +vai(PRAEP) = \[LAMBDA X.ORT\[IN STUTTGART X.ORT\]\] Within the production PNG ÷ PRAEP NPR the first condition needed to determine +vai(PNG) does not hold, so we get %vai(PNG) = +val(PRAEP) If we assume these values to be substituted in +tree, we now have the intermediate result {(k,NG/PNG,+vai(NG/PNG)), (k*l,NG,+val(NG)), (k.lol,N,+val(N)), (kolol.l,Betriebe,~), (k.2,NG/PNG,+vai(NG/PNG)), (k.2.i,PNG, ~LAMBDA X.ORT\[IN STUTTGART X.ORT\]\]), (k.2°l°l, PRAEP, LLAMBDA X.ORT\[IN STUTTGART X.ORT\]\]), (k*2.1.1-l,in,~), (k.2.1°2,NPR,~), (k°2*1.2.i, Stuttgart,e)} It is left to the raeder to compute the final result applying the remainding productions.
Conclusion We have illustrated how an attribute grammar can be produced from the networks and TR-rules used within PLIDIS, which has the same expressive power as the underlying networks and rules.
The advantages of the ATN-grammars for the parsing of natural language sentences are well known.
Above all they are an elegant tool to write grammars especially suited for linguists.
TheeTR -rules have advantages similar to these.
Surely they are easier to write than the somewhat cumbersome expressions for determining attribute values, particularly those for the ÷val-attribute.
In the TR-rules, however, attempt is made to describe and deal with all possible occurrences of a symbol.
With the attributed productions tbis is not necessary, since for a single production some of the cases which stem from the possible occurrences of one or more symbols can be omitted a priori.
For example, in the production PNG + PRAEP NPR the whole first part for determining +vai(PNG) can be omitted, because the first condition does not hold for this production.
In a similar way we can omit some part in the production N ÷ Betrieb.
Further improvements can be made by changing the productions themselves, e.
g. by partly eliminating those symbols which denote word classes.
Performing all possible improvements certainly leads to an attribute grammar which yields translations of sentences in a rather efficient way.
On the basis of this grammar we can detect circularities which can occur in the translation process by means of well defined algorithms (cf.
\[Bo 76\]).
\[Ba 78\] \[BW 78\] \[Bo 76\] \[Dz 7s\] \[~ 6s \] \[m 71\] \[KL 79 \] \[Wo 70 \] \[We 73 \] \[~ 79 \] \[Zi 77 \] References M.
Bates, The theory and practice of augmented transition network grammars in: L.
Bolc (ed.), Natural language communication with computers Springer Lecture Notes in Computer Science, 63, 191-259, Berlin 1978 G.L.
Berry-Rogghe/H. Wulz, An overview of PLIDIS, a problem solving information system with German as query language in: L.
Bolc (ed.), Natural language communication with computers Springer Lecture Notes in Computer Science, 63, 87-132, Berlin 1978 G.V.
Bochmann, Semantic evaluation from left to right in: CACM 19(2), 1976, 55-62 W.
Dilger/G. Zifonun, The predicate calculus-language KS as query language in: H.
Gallaire/J. Minker (eds.), Logic and data bases Plenum Press New York, 1978, 377-408 D.E.
Knuth, Semantics of context-free languages in: Math.
Systems Th.
2, 1968, 127-145 and Math.
Systems Th.
5, 1971, 95-96 D.E.
Knuth, Examples of formal semantics in: E.
Engeler (ed.), Symposium on semantics of algorithmic languages Springer Lecture Notes in Mathematics, 188, 212-235, Berlin 1971 M.
Kolvenbach/A. L6tscher/H-D.
Lutz (eds).
KOnstliche Intelligenz und nat~rfiche Sprache Forschungsberichte des Institute f0r deutsche Sprache, 42, G.
Narr-Verlag Tfibingen, 1979 W.A.
Woods, Transition network grammars for natural language analysis in: CACM 13, 1970, 59~-606 W.A.
Woods, An experimental parsing system for transition network grammars in: R.
Rustin (ed.), Natural language processing Algorithmic Press New York, 1973, 112154 H.
Wulz, Formalismen einer Ubersetzungsgrammatik Forschungsberichte des Institute ffir deutsche Sprache, 46 G.
Narr-Verlag Tfibingen, 1979 G.
Zifonun, Die Konstruktsprache KS in: K.
Heger/J. PetSfi (eds.), Kasustheorie, Klassifikation, semantische Interpretation Papiere zur Textlinguistik ii, Hamburg 1977

