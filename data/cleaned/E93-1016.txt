Parsing with polymorphism * Martin Emms, The CIS Leopoldstr 139 8000 Munchen 40 Germany Abstract Certain phenomena resist coverage within the Lambek Calculus, such as scopeambiguity and non-peripheral extraction.
I have argued in previous work that an extension called Polymorphic Lambek Calculus (PLC), which adds variables and their universal quantification, covers these phenomena.
However, a major problem is the absence of a known decision procedure for PLC grammars.
This paper proposes a decision procedure which covers a subset of all the possible PLC grammars, a subset which, however, includes the PLC grammars with wide coverage.
The decision procedure is shown to be terminating, and correct, and a Prolog implementation of it is described.
1 The
Lambek Calculus To begin, I give a brief description of Lambek categorial grammar \[Lambek, 1958\].
The categories are built up from basic categories, using the binary categorial connectives '/' and 'V.
1 Then
a set of 'categorial rules' involving these categories is defined, of the form: xl,...x, =~ y (n > 1), xi and y being categories.
A distinctive feature is that the set of rules is defined inductively.
Using a term adopted from *This work was done whilst the author was in receipt of a six month scholarship from the German Academic Exchange Service, whose support is gratefully acknowledged 1Lambek also considered a third connective, the 'product'.
I, in common with several authors, use the name Lambek calculus to refer to what is really the product-free calculus logic, sequent, in place of 'categorial rule', Lambek presented this inductive definition as a close variant of Gentzen's sequent calculus for propositional logic.
Lambek's calculus, L(/'\), is given below: (Ax) x =~ z (/L) U, y, V =~ w T ::~ z /L U,y/x,T, V =~ w (\L) T =~ z U, y, Y =~ w \L U,T,y\~, V ~ w (/R) T, z =~ y (\R) z, T =~ y T =~ ylz T =~ y\z Here U, T, V are sequences of categories (U,V possibly empty), w,z,y are categories.
In the two premise rules, the T ::~ x premise is called the minor premise.
The fact that L(//\)derives r, I will notate as L(/'\) ~-r.
With regard to the names of the rules, 'L' and 'R' stand for left and right.
For example, (\i) (resp.
(\R)), derives sequents with 'V on the left (resp.
on the right) of the sequent arrow, ' =# ' For various purposes it is convenient to consider the addition of the 'Cut' rule, given below (in which z is referred to as the Cut formula, and T ::~ z as the minor premise): U,z,V =~ w T =~ z Cut U,T,V~w Lambek \[1958\] establishes that n(/,\)+ Cut \]-r iff L(/,\)~-r (Cut elimination), and that L(/'\)~r is decidable.
120 The proof of the decidability of L(/'\) }-r proceeds as follows.
First one reads the rules of L(/'\) 'backwards', as a set of rewrites, growing a tree at its leaves 'up the page'.
Call the trees grown this way deduction trees.
L(/,\)~-r iff r is the root of a deduction tree whose leaves are all axioms.
It remains to note that there are only finitely many deduction trees for a given sequent: a leaf can be grown in at most a finite number of different ways, and the added daughters have always a diminished complexity (complexity measured as number of occurrences of connectives).
This decision procedure is improved upon somewhat if the rules of the calculus are expressed as a Prolog data base of conditionals concerning a binary predicate seq, holding between a list of categories and a single category.
For later reference, let Lain stand for some such Prolog implementation of L(/'\).
A grammar, G, in this perspective is an assignment of categories to words.
Reading G }-s E y as 'according to G, s has category y', I will say G ~-s E y, if (i) s is lexically assigned y, or (ii) s = sl...so(n > 1), G~-s~ E xi, and L(/,\)~-xl,...xn =~ y.
For any Lambek grammar, G, the question whether G~s E x is decidable.
This is got by combining Cut elimination with the decidability of L(/'\)~-r.
Consider deciding whether G~sls2 E z, where 81 and s2 are lexically assigned the categories x and y.
One can first check whether L(\]'\)~-x,y:=~ z, which is decidable.
If L(/,\)~ x, y :=~ z, then one should try a 'non-flat' categorisation possibility.
That is, one should also consider derivable categorisations of the subexpressions, namely x I and y' such that L(/,\)~x =~ x', y ::~ y~, and check whether they may be combined to give z.
Here lurks a problem, because there are infinitely many x ~ and y~ such that L(/,\)\[ x :~ x I, y =V y~.
The way out of this problem is the relationship between the 'non-fiat' categorisation strategy and Cutbased proofs, to illustrate which, note that if there were derivable categorisations, x' and yl of the subexpressions, which combined to give z, then L(/'\)+ Cut ~x, y :=~ z: (1) Y ==~ y, x I,yl ==~ z Cut Cut x, y =C.
z So parsing with an L(/,\) grammar comes to deciding the derivability of Xl,..., xo =:~ s, where xi are the categories of the lexical items.
This Lambek style of grammar is associated also with a certain method for assigning meanings to strings.
The idea is that a proof, 7, of L(/'\)can mapped into a semantic operation, ~.
So, if there is a proof, 7, of Xl, ..., ;go ::~ Y, then a sequence of expressions with categories Xl,..., xn and meanings ml,..-, ran, has a possible meaning 6(ma,..., too).
As to which operation, G, goes with which proof, 7, this is defined by a term-associated calculus.
Representative parts of the (extensionally) term associated calculus, L~/'\), are given below: (Ax) x : a =~ x : a (/L) U,y : a( fl ), V =V w : e T =~ z : fl U,y/x : a,T,V ~ w :e /L (/R) T, x : ¢ :~ y : /R There are corresponding (\L) and (\R) rules.
L~/'\)derives sequents where in place of categories there are category:term pairs.
If we start with an L(/,\) proof of r, and add variables to the antecedent categories of r, there is a unique way to add terms to the rest of the proof so as to get a proof of L (/'\).
When this is done the term, a, associated with the succedent of r, represents the semantic operation.
The above mentioned decision procedure can be embellished to develop trees featuring semantic terms, some of them unknown, together with an evolving set of equations in these unknowns.
When a proof is discovered, the term for that proof can be obtained by solving the set of equations.
There is a semantic question to be asked about the acceptability of parsing simply by search through L(/,\) proofs: are all term-associated proofs for a sequent in L(/,\)+ Cut equivalent to some termassociated proof in L(/,\), and vice-versa ? The answer is yes \[Hendriks, 1989\], \[Moortgat, 1989\].
2 Polymorphism
Despite the great simplicity of Lambek grammars, a surprising amount of coverage is possible \[Moortgat, 1988\].
Two aspects of this are embryonic ac -.
counts of extraction, and scope-ambiguity, the latter arising from the fact that there may be more than one proof of a given sequent.
However, the accounts possible have remained only partial.
Nonperipheral extraction remainsd unaccounted for (eg.
the (man)/ who Dave told ei to leave) and only the scope-ambiguities of peripheral quantifiers are covered (as in the structure QNP TV QNP).
A simple account of cross-categorial coordination has also often been cited as an attractive feature of Lambek grammars (\[Moortgat, 1988\]).
However, the analyses are never in a purely Lambek grammar.
Belonging to Lambek grammar proper is a part assigning some category to the strings to be coordinated, and then lying without Lambek grammar, a coordination schema, such as x, and, x ::~ x.
121 To overcome these deficits in coverage, I have proposed a polymorphic extension of the calculus.
Added to the categorial vocabulary are category variables and their universal quantification, allowing such categories as: X, X/X, VX.X/(X\np).
To L(/,~ \~ are added left and right rules for V, to give what I will call L(/,\,v)(I given straightaway the term-associated calculus): (VL) U, x\[y/Z\] : c~(a), V :~ w: @ U, VZ.= : a, V =~ w : q~ (VR) T =V z : a \[Z is not free in 71 T =:~ VZ.z : Awa Notation: the terms are drawn from the language of 2nd Order Polymorphic A-calculus \[Girard, 1972\], \[Reynolds, 1974\].
Here, terms carry their type as a superscript, and one can have variables in these types (eg.
Axr.x~), one can abstract over such variable types, deriving terms of quantified type (eg.
A~r.Ax ~.z ~, of type Vr(Tr--*~r)), and terms of quantified type can be applied to types (eg.
Ar.Axr.=x(t), of type (Z-+Z)).
In the (VL) rule above, the type, a, that a is applied to, is the type that corresponds to the category, y, that is being substituted for the cate~ory variable, Z.
2 An
equivalent slight variant on L (/,\,v) takes as axioms only those z ::~ x sequents where z is basic or a variable, something I will call L~/'\'v).
It is easy to show L~/'\'v)~-r iff L(/,\,v)~--r (see \[Emms and Leiss, forthcoming\]).
By assigning conjunctions to YX.((X\X)/X), negation to VX.X/X, and quantifiers to VX.X/(X\np) and VX.X\(X/np), one obtains coverage of crosscategorial coordination and negation, as well as a comprehensive account of quantifier scope ambiguity \[Emms, 1989\],\[Emms, 1991\].
Assigning relativisers to VX.((cn\cn)/(s\X)/(X/np)), non-peripheral extraction can also be handled \[Emms, 1992\].
The meanings that go along with these categories are as follows.
Where £ is Q, ff or A f, let/:G vary over the conventional meanings of quantifiers, junctions and negation, with £:p the polymorphic version.
£p(t) = £G Q(a---*b)(pe'-"'~-"~)(x ") = Q(b)(y'---*Pyz) o) = who(a)(P~ a)(p~ t)(Qe t)(xe ) = P2(P~x) AQx I will give two illustrations.
The proof below would allow the embedded quantifier, every man, to be assigned a de-re interpretation in John believes every man walks.
Note (s\np)\((s\np)/s) : X.
2The (VR) given is a cut-down version of the 'official' version, which allows a change of bound variable np, s\np ~ X nP, (s\np)/s, X =~s s\np =~.''~npl: np, (s\np)/s, X/(X'\np) s\np ::~ s,¥L np, (s\np)/s, VX.X/(X\np), s\np ::~ s Now assuming j, bel, em and walk were the terms associated with the antecedents of the root sequent, the term for the proof is: emp (tel, et ) ( AxA f A y\[f ( walk( z ) )( y) \] ) ( bel)(j ) We obtain as a possible denotation for John believes every man walks: emp(ta, a)(=,/, y ~ f(walk(z))(y))(bel)(j) = emp(a)(~, y ~ b~t(waZk(=))(y))(j) = emp(t)(z ~-* bel(walk(z))(j)) = emG(= As an illustration of non-peripheral extraction, the proof below allows the string who John told to go to be recognised as a postmodifier of a common noun: s/vpc, vpc =~ s __ \R r vpc =~ s\X D (c.\c.)/(s\X), vpc ca\ca np, V, np, vpc ::~ s /L _ ./L np, V :~ X/np /L rip, v, vpc cn\cn VL VX.((cn\cn)/(s\X)/(X/np)), rip, V, vpc cn\cn Here r = cn\cn ~ cn\cn, V -((s\np)/vpc)/np, = s/vpc.
Assuming who, j, told, and go were associated with the antecedents of the root, the term for the proof is: who( (et, t ) )( AzAy\[told(z)(y)(j)l)( A f\[f (go)\]) We obtain for the denotation of the string who John told to go: who((et, t))(z, y ~ told(z)(y)(j))(f ~ /(go)) = Q, z ~ ((f ~ f(go))((y ~ told(z)(v)(j))) A O(z)) = Q, z ~ (told(z)(go)(j) A Q(z)) For the further discussion of the analyses within an L (/,\,v) grammar that cover a significant range of data, see the earlier references.
I turn now to the main problem which this paper addresses: is there an automatic procedure able to find these analyses ? 2.1 Cut Elimination for L (/,\,v) We want a procedure to decide whether G ~-s E z, where G is an L (/,\,v) grammar.
As with L(/'\) grammars, this problem reduces to deciding L(/'\'v)~ r if it can be shown both that Cut can be eliminated, and without the loss of any significant semantic diversity.
This has recently been shown (\[Emms and Leiss, forthcoming\]).
I make some remarks on the proof.
The strategy of the proof of Cut elimination for L (/A) starts from the observation that a proof, 7, 122 using Cut must contain at least one use of Cut which dominates no further uses of Cut a 'topmost' use of Cut.
Suppose this use of Cut derives r.
Then one defines two things: a degree of the Cut leading to r, and a transformation taking the proof of r to an alternative proof of r, such that either the transformed proof of r is Cut-free, or it is a proof with 2 or less cuts of lesser degree.
After a finite number of iterations of the transformation, one must have a cut free proof.
In the proof for L (/'\), the degree of a Cut inference is simply the sum of the numbers of connectives in the two premises.
This cannot be the degree for L (/'\'v).
For example, a cases to be considered is where one has a cut of the kind shown in (2).
The natural rewrite is (3) (that T ~ y\[a/Z\] is provable relies on the fact that Z is not free in T and substitution for free variables preserves derivability \[Emms and Leiss, forthcoming\]) (2) T ~ v VR U, v\[~/Z\], V ~ WVL T ~ VZ.y U, VZ.v, V =~ w Cut V,T,V =~ w (3) T ::~ y\[a/Z\] U, y\[a/Z\], V =~.
w .Cut U, T, V =C, w With degree defined by number of connectives, we need that the number of connectives in y\[a/Z\] is strictly less than the number in VZ.y, and that is often false.
The proof goes through instead by taking the degree of a cut to be the sum of sizes of the proofs of its two premises, where the size is the number of nodes in the proof.
3 2.2 Difficulties in deciding L(/,\,v)}-T ::¢, x So the problem reduces to one of L (/'\'v) derivability.
Whether L (/'\'v) derivability is decidable I do not know.
The nearest to an answer to this that the logical literature comes is a result that quantified intuitionistic propositional logic is undecidable \[Gabbay, 1974\].
The difference between L(/,\,v) and logic of this result is the presence of the further connectives (V, A), and the availability of all structural rules.
I will describe below some of the problems that arise when some natural lines of thought towards a decision procedure are pursued.
One might start by considering the logic that is L(/'\)+ (VR).
This can be argued to be decidable in the same fashion as L(/'\): read (VR) backwards as a rewrite, adding another way to build deduction trees.
As for L((/'\) a sequent has only finitely many deduction trees, and provability is equivalent to the existence of a deduction tree with axiom leaves.
~In fact nodes above axiom form sequents are not counted in the size, and the proof relies on changes of bound variable and substitutions not changing the size of L(/'\'Y ) proofs However, when (VL) is added this simple argument will not work: if (VL) is read backwards as a further clausill tile definition of deduction trees, then a leaf containing an antecedent V could be rewritten infinitely many different ways.
A natural move at.
this point is to redefine deduction trees, reading the (VL) rule as an instruction to substitute all unknown.
One hopes then that: (i) the set of so-defined deduction trees for a given sequent, r, is finite (ii) there is some easy to check property, P, of these trees such that the existence of a P-tree in the set would be equivalent to L(/,\,v)~-r.
Now, if we were considering the combination of first-order quantification with the Lambek calculus, this strategy works, but whether it works for n (/'\,v) remains unknown.
I will go through the application of the strategy in the first-order case to highlight why g(/,\,v) does not yield so easily.
The first-order quantification plus the Lambek calculus, I will call L (/'\,v').
It is the endpoint of a certain line of thought concerning agreement phenomena.
One first reanalyses basic categories, such as s and np, as being built up by the application of a predicate to some arguments, giving categories such as np(3rd,sing), s(fin).
It is natural then to consider quantification over the first order positions, such as Vp.
s(fin)\np(p,pl), which could be used when, as in English, the plural forms of a verb are not distinguished according to person.
Now L(/,\,v~) is decidable, which can be shown by adapting an argument that shows that when the contraction rule is dropped from classical predicate logic, it becomes decidable \[Mey, 1992\].
Deduction trees for a sequent, r, of L (/'\'v~) are defined so that the rewrite associated with the (VL) rule substitutes an unknown.
There are then only finitely many deduction trees (the absence of the structural rule of contraction is essential here).
Now, if L(/'\'v')~--r, and r has a complex first order term, one can be sure that this term is present in an axiom, because no rules build complexity in the places in categories where a bound variable can occur.
For this reason, the sodefined deduction trees for r cover all the possible patterns for a proof of r.
Provability is therefore equivalent to the existence of a substitution making one of the deduction trees have axiom leaves, and this can be checked using resolution.
This situation does not wholly carry over to g(/,\,v).
The 'substitute an unknown' rewrite reading of (VL) defines only finitely many deduction trees for a sequent, r.
However, these so-defined deduction trees for r do not cover all the possible palterns for a proof of r: unlike g (/,\'v~), there are rules that build complexity in the places in categories where a bound variable can occur.
So, for example, L(/'\,v)~ no, VX.X/(X\np), (s\np)\np, but none of the deduction trees represents the pattern of the proof.
So to check for the existence of a deduction tree (as above defined) that by a substitution would have ax123 iom leaves is not sufficient to decide derivability.
It seems we must defined the looked for property, P, of deduction trees recursively, so that a tree has P if (1) the leaves by a substitution become axioms, or (2) by hypothesising a connective in one of the unknowns, and extending the tree by rewrites licensed by this connective, one obtains a P-tree.
It would amount to the same thing if the definition of deduction tree was extended (by hypothesising a connective in an unknown), and the looked for property, P, kept simple: a tree whose leaves by a substitution become axioms.
However, the extended definition of deduction tree now allows infinitely many trees for a sequent.
This may seem surprising, but is seen one considers a leaf such as T ==~ X.
One can hypothesis X = Y/Z, extend the deduction tree by the rewrite associated with a slash Right rule, obtaining once again a leaf with a succedent occurrence of an unknown.
By imposing a control strategy which would systematically consider all deduction trees of height h, before deduction trees of height h + 1, one can be sure that any provable sequent would sooner or later be accepted by the decision procedure (because its provability would entail the existence of a deduction tree of a certain finite height).
However, there is no reason to expect the procedure to terminate when working on an underivable sequent.
4 3 A partial decision procedure for L(/,\,v) While there are problems in the way of a general decision procedure for L (/'\'V), I claim a partial decision procedure for L (/'\'v) is possible.
Partial in the sense of covering only a certain class of sequents, but one sufficiently large, I claim, to cover all linguistically relevant cases.
The procedure will be a partial decision procedure for L (/,\,v) via being a partial decision procedure for L(0/'\'v).
To describe the class of sequents that the procedure applies to I need definitions of the 'polarity' of an occurrence of a category.
Let the category polarity of an occurrence of z in a category y (pol(z, y)) be: pol(x, z) = + if z occurs in y, pol(:~,y/z) pol(x, y) = opp(pol(x, z/y)) = pol(x,VZ.y) Here opp(+) = -, opp(-) = +.
The sequent polarity of an occurrence of x in y in a sequent r is the same as the category polarity if y is an antecedent, and otherwise it is opposite.
I use 'polarity' as short for 'sequent polarity'.
An example: (4) sk(V-X.X/(Xknp)) ::~ sk(V+X.X/(X\np)) 4I have found non-terminating consecutively bounded depth first search to happen on the Prolog implementation of the calculus that these paragraphs suggest The decision procedure to be described is applicable to sequents whose negative occurrences of polymorphic categories are unlimited, but whose positive polymorphic categories are drawn from: (5) VX.X/(X\np), VX.X\(X/np), vx.x/x, VX.((cn\cn)/(s\X)/(X/np) vx.((x\x)/x), I will now make three observations concerning proofs in L (L\'v), leading up to the definition of the procedure.
Observation One In the categories in (5) there is exactly one positive and one or two negative occurrence of the bound variable.
This leads to the predictable occurrence of certain sequents.
To help describe these I need to define some more terminology.
An initial labelling of a proof is the assignment of unique integers to some of the categories in some sequent of the proof.
A completed labelling is got from an initial labelling by a certain kind of propagation up the tree: a label is passed up when a labelled category is simply copied upward, and in a (VL) inference the label is distributed to the occurrences of the categories chosen for the variable.
In other inferences where a labelled category is active, the label is not passed up.
For example: (6) sl =~s s=~ sl np=~ np s=~s /L .\L sl/sl, s =~ s up, s\np =~ s VlX.X/X, s =~ s s\np =~ s\np vlx.x/x, s\np s I will say U, ai, V =~ w is 'positive for Vi' if the sequent occurs in a labelled L (/'\'v) proof and the label on ai has been passed from a labelled occurrence of Vi.
Correspondingly, call a sequent T ::~ ai 'negative for Vi'.
Now note that in the above proof, the Vl in the root led to one V + and one V~" branch.
This is no accident: one can predict the existence of such branches in any proof of a sequent with a positive occurrence of ViX.X/X.
To see this, let me first define a notion reflecting how 'embedded' a category is: path(a, a) = O.
Where a occurs in x, path(a, x/y) (/,path(a, x)), path(a,y/z) = (/,path(a,z)), path(a, VZ.x) = ( v, path(a, z)) With the exception of bound variable, if a category occurs with a path (C,p), and a polarity 6, in the conclusion of an inference, then it occurs in the premises of that inference with the same polarity, and with either the same path or with path p.
Also, in leaves of a proof in L (/'\'v), categories only occur with zero path.
Therefore, if we have 124 a proof of a sequent with a positive occurrence of ViX.X/X and with non-zero path, then there must occur higher in the proof, a sequent with V,.X.X/X occurring again positively and this time with with zero-path.
In other words there must occur a node U, ViX.X/X, V =~ w.
Then if there were no (VL) inference in this proof introducing the category ViX.X/X, the category ViX.X/X would be present in the leaves of the proof.
Because the leaves can only feature hasic categories, there must be a (VL) inference, and therefore a node U ~, ai/ai, V ~ =~ w ~.
Reasoning in a similar vein concerning the category ai/ai, we can be sure there must be a (/L) inference, with premises U ~,ai,V"=~w # and T ~=~al.
These are V + and V~sequents.
Provable sequents having a positive occurrence of one of the polymorphic categories from (5), labelled with i, will generate an L~/'\'v) proof such that corresponding to each of the positive and negative occurrences of the bound variable, there are (distinct) V + and V~branches.
Observation Two We just argued that in any proof of a sequent with a positive occurrence of quantified category, there must occur a node at which the quantifier is introduced by a (VL) inference, and that for the categories in (5), V~ sequents must appear above this.
For each of the V~ sequents, the minimum number of steps there can be between the conclusion of the (VL) step and the V~ sequent is the length of the paths to the associated occurrence of the bound variable in the quantified category.
Proofs featuring such minimum intervals between the quantified category and the associated V~ sequents I will call orderly.
One can ask the question whether whenever there is a proof of a sequent whose positive quantitiers are drawn from the list in (5), there is also an (equivalent) orderly proof.
And the answer is that there is.
Proof sketch We want to show that for any category x in (5), for each of the occurrence of a variable in it, that if there is a proof of U, x, V =~ w, then there is a proof in which the steps leading from the lowest occurrence of the relevant V~ sequent to the (VL) inference correspond to the path to the bound variable in x.
Let me define the spine of a category as: sp(x/y) = (/, sp(x)), sp(VZ.x) = (V, sp(x)), sp(x) = O, where z is basic.
We will show first for categories such that sp(x) = (V, slash), and sp(z) = (slashl, slash2), that when there is a proof such that the left inferences for the first two elements of the spine are separated by n steps there must be an equivalent proof where they are separated by n 1 steps.
One considers all the possibilities for the last intervening step, 1, and shows that the step associated with the first element of the spine could have been done before l, thus lowering by 1 the number of steps intervening between the first two elements of the spine.
There is not the space to show all the cases.
(7), (S) and (9, (10) are representative examples for sp(w) = (V, sp(x)).
Note that in (9) and (10) there are side-conditions to the (VR) inferences.
Satisfaction of these for (9) entails satisfaction for (10).
(11), (12) and (13),(14) show representative examples for sp(w) = (slash1, slash2).
In (14), X' is some variable chosen to be not free in U, x/y/z, T, V and w.
The provability of the upper premise U, x/y, V w\[X'/X\] follows from that of U, z/y, V ~ w by substitution for the variable X throughout.
5 As
to the equivalence of the proofs, one can confirm that in the term-associated versions, the same term is paired with the succedent category in each case.
(7) U, a, V2 =~ w x'/y', V1 =*, b /L U, a/b, x'/y', Va, V~ =~ w "¥L U, a/b, VZ.x/y, V1, V2 :=~w (8) E/v', v~ =~ b .VL U, a, V2 =~ w V Z.
x / y, V1 =~ b "/L U, a/b, VZ.x/y, V1, V2 =~ w (9) U, x'/y', V ~ z VR U, z'/y', V :0 VY.z .VL U, YX.z/y, V ~ VY.z (10) U, s'/y', V =~ z -¥L U, VX.z/y, V =~ z VR U, VX.z/y, V =~ VY.z (11) U, a, V =~ w x/y, T2 =~ b .\]L U, a/b, x/y, T2, V ~ w T1 :* z /L U, a/b, x/y/z, T1, T2, V =~ w (12) z/y, T2 ~ b T1 =~ z /L U, a, V m, w x/V/z, T1, T2 ~ b /L U, a/b, x/y/z, T1, T~, V =*, w (13) U, x/y, V ~ w VR V, x/y, Y ~ VYw\[Y/X\] T =~ z ./i U, z/y/z, T, V ~ VYw\[Y/X\] U, z/y, Y =~ w\[X'/Z\] T =~ z ./L U, x/y/z, T, V ~ w\[X'lX\] 'VR U, x/y/z, T, V ~ VYw\[Y/X\] (14) 5Here the 'full' version of (VR) is being used, incorporating a change of bound variable.
See earlier footnote.
125 This is enough to show orderly proofs for VX.X/X and VX.(X\X)/X.
For VX.X/(X\np) and VX.((cn\cn)/(s\X)/(X/np)) we must further show that if there is a proof of T =~ x/y whose last step is not a (/R) inference introducing x/y, then there is an equivalent proof whose last step is a (JR) inference introducing ~./y.
One can show this by showing if there is a proof whose last two steps use (/R) followed by some rule *, then there is an equivalent proof reversing that order.
(15) and (16) illustrate this.
(15) U, a, V, y ~ x /R U,a,V ~x/y T~b /n U, a/b, T, V ~ z/y (16) U, a, V, y =~ x T =~ b /L U, a, T, V, y ~ U, a/b, T, V =~ x/y/R So much by way of a sketch of a proof.
I will put the fact that orderly proofs exist to the following use.
For sequents whose positive quantifiers are drawn from the list in (5), one can be sure that if they have proofs at all, they have a proofs which instantiate quantifiers 'one at a time'.
One at time in the sense that once a there is a (VL) inference, one can suppose there will be no more (VL) on the branches leading to the first occurrences of a V~ sequents.
Observation Three Bearing in mind Observation One, the question whether a given choice, hi, for the value of the quantified variable is a good one will come to depend, sooner or later, on the derivability, of a certain set of V/6 sequents, containing one V~ sequent and one or two V~sequents.
In relation to this consider the following: Fact 1 (Unknown elimination) (i) and (ii) are equivalent (i) There is an x such that L(/,\,v)\[-U,x,V ~ w, Ti ~ z ....., T, ~ z (it) L(/'\'v)~-U, Ti, V =¢, w, ..., U, T,, V =:~ w The proof of this, from left to right uses Cut and Cut-Elimination.
For example, from L(/,\,v)~-U, x, V =¢.
w, L(/,\,v)~-Ti =¢, x, we deduce L(/'\'V)+ Cut ~-U, Ti, V ~ w.
Therefore by Cut elimination, L(I,\,v)~U, T1, V ~ w.
For the right to left direction, let me say that (w\U)/V is a shorthand for (w\ui ...\us) /v,, .../vi.
We choose the x to be (w\U)/Y.
Clearly for this x, L(I,\,v)~-U,x,V ~ w.
Also each of the claims L(/,\,v)~-T/ =~ x, follows from the assumed U, 7~,V~w, simply by sufficiently many slash Right inferences.
On the basis of these observations, I suggest the following decision procedure: 6 Definition 1 (Decision procedure) Where A, r vary over possibly empty sequences of sequents, let a rewrite procedure 7~ be defined as follows 1.
A, z =t, x, r .,~ A, r, where x is atomic 2.
A, T :=~ w, r .,., A, O, r, if T "=~ w follows from 0 by some rule of L(/'\'v) other than O/L) 3.
A, U, VZ.z, V =~ w, r ~ A, z\[x/Z\], V =~ w, r, where X is an unknown, and there are no other unknowns in A, U, VZ.z, V ::~ w, r 4.
A, U,X,V =~ w, Tx =~ X ....., T, ~X, r ..~ A U, T1, V =¢, w, ..., U, Tn, V ~ w, r A sequent T ~ w is accepted iff the sequence consisting of just this sequence can be rewritten to the empty sequence by 7¢.
The fourth clause slightly oversimplifies what I intend in the two respects that (i) the rewrite can apply when the U, X, V =¢, w, T1 =¢, X, ..., T, =¢, X occur dispersed in any order through the sequence, and (it) it can only apply if the unknown X does not occur in sequents other than those mentioned.
Note because of clause 3, there will only ever be one unknown in the state of the procedure.
This corresponds to Observation Two above.
I will show that this procedure is terminating and correct when applied to sequents whose positive quantifiers are drawn from (5).
By correctness of the procedure, I mean that the procedure accepts riff L(/,\,V)\]--r.
The implication left to right I will call soundness, and from right to left completeness.
There is a term associated version of this decision procedure, rewriting a pair consisting of a set of equations, and a sequence of term-associated sequents.
On the basis of the discussion earlier, for the most part the the reader should be able to easily imagine what embellishments are required to the clauses of the rewrite.
I will just give the full version of the Clause 4 rewrite.
The input will be: Equations:E Sequence: A, U : ~7,_.
X:@I, V : ~' =t, w : @2, Ti : t~ :~ X:~l, ..., Tn : tn ::~ X:q/n, r The output will be: Equations:E plus ¢2 = (\]~I(~-~)(U), II/1 -)tV~'tA~tI#i, ..., ~, = ~u~" Sequence: A, U : ~, T1: 4, V : ~ =~ w : @\], ..., U:un, Tn:~,V:~ =¢, w : ~, r 3.1 Termination If there are any rewrites possible for a sequence there at most finitely many.
So we require that no rewrite series can be infinitely long.
Call the sequents featuring an unknown a linked set.
At any one time nSince writing this paper, I have discovered that the above observation concerning unknown elimination have been made before \[Moortgat, 1988\], \[Benthem, 1990\].
This will be further discussed at the end of the paper 126 there is at most one linked set.
Let the degree, d, of a sequence be the total number of connectives.
All rewrites on a sequence that has no linked set lower the degree.
So rewriting can only go on finitely long before it stops or a linked set is introduced.
A linked set is introduced by a clause 3 rewrite, introducing an unknown into some particular sequent.
Call this the input sequent.
While the sequence contains a linked set, either the degree of the whole sequence goes down, and the sequence remains one containing a linked set (clause 1, clause 2), or the sequence becomes one no longer containing a linked set (clause 4).
So a rewrite can only go on finitely long before it either stops, or has a phase where a linked set is introduced and then eliminated.
Call the sequents which result from the elimination of the unknown in a clause 4 rewrite, the oulpul sequents.
Now considering any such phase of unknown introduction followed by elimination, one can say that the count of positive quantifiers in the input sequent must be strictly greater than the count of positive quantifiers in any of the outputs.
This, taken together with the fact that the maximum count of positive quantifiers is never increased outside of such phases, means that there can only by finitely many such phases in a rewrite.
3.2 Soundness
We show that if the procedure accepts a sequence of n sequents (n > 1), then there is substitution for the unknowns such that there are n proofs of the n substituted for sequents.
This subsumes soundness, which is where n = 1 and there are no unknowns.
I shall use sub(A) to refer to the sequence of sequents got from A by some substitution for the unknowns in A, and L(/,\,v)~-A for the claim that there are proofs of each of the sequents in A The proof is by induction on the length of the shortest accepting rewrite.
When the shortest accepting rewrite is of length 1, the sequence must consist simply of an axiom, and so there is a proof.
Now suppose the statement is true for all sequences whose shortest accepting rewrite is less than 1.
Then for sequences whose shortest accepting rewrite is of length l, we consider case-wise what the first rewrite might be.
• clause 2 rewrite, for example: A, U, z/y, T, V ~ w, F .,.* A, U,x, V =~.
w, T ::~ y, F.
A, U,x, V ~ w, T ::~ y, r must have a shortest accepting rewrite of length < l, so by induction there is a substitution such that L(/,\,v)~-sub(A), sub(U,x,V =~ w), sub(T ::V y), sub(r).
From this it follows that L(/,\,V)Fsub(A), sub(U,z/y,T, V ~ ~), sub(r).
The other possibilities for clause 2 rewrites work in a similar way • clause 3 rewrite: A, U, VZ.x,V=~w, F ~.~ A, U,x\[X/Z\], V =~ w, A.
By induction there is a substitution such that L(l'\'v)~-sub(A), sub(U,.x\[X/Z\], Y ::V w, sub(A).
Let sub' be the substitution that differs from sub simply by substituting nothing for X.
sub'(VZ.x) -VZ(sub'(x)), and sub(x\[X/Z\]) = subt(x)\[sub(X)/Z\].
It follows that L(/,\,v)~-sub'(~), sub'(U, VZ.~, V ~ ~), sub'(F) * clause 4 rewrite.
A, U,X,V::~w, T1 ::~X, ..., Tn ~ X, r ..~ A U, T1, V =v w, ..., U, Tn, V =V w r.
By induction: L(/,\,v)~-sub(A), sub(U, T1, V =~ w,..., U, T,, V :, w), sub(r).
Let sub' be the substitution that differs from sub simply by substituting for X, sub(w\U/V).
Clearly L(/,\,v)~ sub'(U,X,V=~w).
Also for each T~, it follows from L(/,\,v)~-sub(U, Ti, V :=0 w) that L(/,\'v)~-sub'(Ti =~ X).
Hence L(/,\,v)~-subl(A), sub'(U, X, V =~ w), sub'(T1 =~ X), ..., sub'(T, ::~ X), sub'(r) \[\] 3.3 Completeness I will now show completeness for sequents whose positive polymorphic categories are drawn from (5).
By a frontier, f, in a proof, I will mean either the leaves of that proof or the leaves of a subtree having the same root.
Given a frontier f in a proof p, which has some completed labelling, the procedure will be said to be in a state s that corresponds to f, if the state and the frontier are identical except that (i) s may have some axioms deleted as compared with f, and (ii) the occurrences of labelled, non-quantified ai in f, are transformed to occurrences of some unknown in s.
Given a state s, I will say that a frontier, f, is accessible if there is a state corresponding to f that the procedure may reach from s.
I assume the procedure is complete for unknownfree sequents whose positive quantifier count is zero.
7 Now
suppose the procedure is complete for unknownfree sequents whose positive quantifier count is less than some particular n, and consider a sequent r, of positive quantifier count n, with some proof, p, and one of the form remarked upon in Observation Two.
There will be (VL) inferences in this proof, amongst which is a set lower than any others.
Take the conclusion of one such (VL) inference, U, VX.y, V ==~ w and from all other branches pick a point not above a (VL) inference.
This set of points forms a frontier, f, which is accessible if the procedure starts at r.
Call the corresponding state s.
The sequents in the state other than U, VX.y, V =~z w are unknown-free, have a positive quantifier count of less than n, and have a proof, and so by induction the procedure is complete for them.
So there is a possible later state s I which consists solely of the sequent U, VX.y, V ~ w.
We now focus on the subproof of p that is rooted in U, VX.y, V =~ w.
Consider VX.y as labelled with i, and labelling to have been propagated up the tree.
I want to define a certain accessible frontier, if, in this tree.
There are a certain finite number of branches ending in U, VX.y, V ::~ w.
A certain subset of those 7I am of course assuming that all these positive quantified categories are drawn from the list in (5) 127 branches lead to V~ sequents, and without any intervening (VL) inferences.
Select for the frontier f' tile lowest occurrences for the V~ sequents.
From the other branches simply select a set of nodes, P, which is not preceded by a (VL).
This frontier is accessible, and the corresponding state is: U, Xi, V =2,, w, T1 z=~ Xi, ..., Tn ~ Xi.
By a clause 4 rewrite this leads to: U, T1, V =~ w, ..., U, T,, V ~ w.
This state is unknown free, each of the sequents has positive quantifier count less than n, and each has a proof.
So by induction, the procedure is complete for each of the sequents, and the state may be rewritten to O" \[\] 4 Implementation We can with respect to the term-associated version of the decision procedure ask whether it is semanti.
cally comprehensive: whether the procedure assigns, up to logical equivalence, exactly the same terms to a sequent as are assigned to it by the declarative definition of an L(/,\'v) grammar.
Some but not all parts of what is necessary for a proof of this are established that Cut elimination for L (/'\'v) preserves readings, that restriction to orderly proofs loses no readings.
However, for the moment, the claim rests ultimately on empirical evidence, drawn from the prolog implementation that I will now describe.
I will describe the implementation as additions/alterations to the earlier mentioned Laln.
First, it was noted in Observation Two, that one can insist in proof search that Slash right rules are used as soon as their application become possible: this early use of Slash right rules is the first modification of Lain.
For the sake of the discussion, assume it is done by adding to non Slash right rules a check on the absence of a slash in the succedent.
Second, a conditional for (VL) is added: seq(\[U,pol(X,Y):Terral,V\],W:Terra2):groundseqC\[U,pol(X,Y):Tez~l,V\], W:Term2), substituteCXl,X,Y,Yl), ~ Y1 is Y\[XI/X\] mark(Y1,Y2), seq(\[U,Y2:Terml(Ty),V\],W:Term2), cattotype(X1,Ty).
Note, polymorphic categories appear as terms such as pol(x,x/x).
The code is in a simplified form, pretending that \[U, X, V\] matches any list that is the appending together of the lists U, fX\] and V, where in reality there are further clauses taking care of this.
The conditional basically substitutes an unknown for a quantified variable.
Prior to the substitution there is a check, groundseq, that the categories in the goal do not already feature some syntactic unknown.
Subsequent to substitution, the mark relation leads to the replacement of the positive occurrence of the unknown Xl with (Xl,a).
Third, a goal featuring a zero-path occurrence of (Xl, a) :Term matches no standard sequent rule, because of the marking, matching instead an 'argument stacking' conditional: seqC\[U:\[~,CX,a) :F,V:~ ~\],W:Tena) :x = (w\u)/v, Tez~ = FC~)Cr~) Fourth, sequents featuring the marked version of the unknown are dealt with before sequents featuring the unmarked (negative) instances of the unknown, by ordering the major premise before the minor in the conditionals for the Slash Left rules.
To illustrate I will 'trace' the behaviour of the program on the goal given as 1 below (tv stands for (s\np)/np 1.
seq(\[np:f,tv:g,polCx,x\(x/np)):h\],s:T) 2.
seq(\[np:f,tv:g,(Xi,a)\(Xl/np):h(Ty)\], s:T) 3.
seq(\[np:f,(Xl,a):h(Ty)(T1)\],s:T) 4.
Xl = sknp, T : h(Ty)(T1)(f) 5.
seq(\[(s\np)/np:g\],s\np/np:T1) 6.
TI = )~x ~y g(x)(y) 7.
cattotype(s\np,Ty) 8.
Ty = (e,t) 9.
T = h(Ce,t))(Ix ~y gxy)(f) 1 matches against the (VL) clause.
The check that there are no syntactic unknowns around is successful, and after substitution and marking, we reach the subgoal shown as 2, which introduces the new unknowns Xl and Ty.
2 matches against the (\L) clause, the first subgoal of which is the major premise, shown as 3, with the new unknown T1 (if we could pick the minor premise, we would have non-termination).
3 matches only the 'argument stacking' conditional, giving a solution for Xl and solving T in terms of Ty and T1, as shown in 4.
The second subgoal of 2 is then considered, under the current bindings, which is 5.
5 will solve via a combination of slash Left and slash Right rules, giving the solution for T1 shown in 6.
2 is now satisfied, and the final subgoal of 1 is considered under the current bindings, which is 7.
7 solves with the solution for Ty shown in 8.
1 is now satisfied, and the solution for T is shown in 9 (recall in 4, T was expressed in terms of Ty and T1).
Space precludes giving a formal argument that this Prolog implementation and the foregoing decision procedure correspond, in the sense that they succeed and fail on the same sequents, and assign the same terms.
By way of indication of the behaviour of the implementation, and in particular its semantic comprehensiveness, I give below some examples of what the implementation does by way of assigning readings.
In all but the last two cases the task is to reduce to s.
For the last two it is to reduce to cn.
128 (17) a.
every man walks (I) b.
every man loves a woman (2) C.
John believes Mary thinks every man walks (3) d.
every man a woman 2 flowers (0) e.
every man loves a woman 2 flowers (0) f.
every man gave a woman 2 flowers (6) g.
(omdat) John gek en Mary dom is (1) h.
man who John told to go (1) i.
man who John told Mary to go (0) 5 Concluding remarks To pick up on an earlier footnote, I have discovered since writing this paper that Benthem and Moortgat have shown decidable, by using what I have referred to as Unknown Elimination, the system which is L(/'\) with an added rule of 'Boolean Cut': U,x,V ~ w TI ~ x T2 ~ x -Bool.Cut U, T1,J,T2,V =~ w The question arises then of the relation between their work and what has been proposed in this paper.
At the very least, I hope to have shown that there is lurking in this Unknown Elimination technique, an approach not only to coordination, but also to quantifier scope ambiguity and non-peripheral extraction.
The main difference between the decision procedure for L (/'\'v) and that for L(/,\)+ Bool.Cut is that the Unknown Elimination technique is put to work on sequents which do not arise from special purpose Cut rules, but simply by the elimination of categorial connectives from certainkinds of categories containing unknowns.
This introduces some intricacies into the proof of completeness, which the observation concerning orderly proofs was used to deal with.
As to the scope of the decision procedure, this ought to have a more general specification than that which has been given here, though I have not yet found it.
A plausible seeming idea is that there should be one positive and several negative occurrences of a bound variable.
However, this includes a category such as VX.s/(X/X), and a proof featuring this category is not guaranteed to produce separate V ~ sequents.
A direction for future research would be to investigate the possibility of combining this approach to quantification, coordination and extraction with non-categorial accounts of other aspects of a language.
The idea would be to use such a noncategorial grammar as an extended axiom base.
If this turned out to be feasible then we would have an attractively portable account of quantification, coordination and extraction.
References \[Benthem, 1990\] Johan van Benthem.
Categorial Grammar meets unification.
In Unification formalisms: syntax, semantics and implementation, J.Wedekind et al.(eds.).
\[Emms, 1989\] Martin Emms.
Polymorphic Quantitiers.
In Proceedings of the Seventh Amsterdam Colloquium, pages 139-163, Torenvliet, M.
S. L.
(ed.), Institute for Language, Logic and Information, Amsterdam, December 1989.
\[Emms, 1991\] Martin Emms.
Polymorphic Quantitiers.
In Studies in Categoriai Grammar Barry, G.
and Morrill, G.
(eds)., pages 65-112, Volume 5 of Working Papers in Cognitive Science, 1991, Edinburgh, Centre for Cognitive Science.
\[Emms, 1992\] Martin Emms.
Logical Ambiguity.
PhD Thesis, Centre of Cognitive Science, Edinburgh.
\[Emms and Leiss, forthcoming\] Martin Emms and Hans Leiss.
Cut Elimination for Polymorphic Lambek Calculus.
CIS Technical Report, forthcoming.
\[Gabbay, 1974\] Dov Gabbay.
Semantical Investigations in Heyting's Intuitionistic Logic Dordrecht: Reidel.
\[Girard, 1972\] :I.
Y. Girard.
Interpretation Fonctionelle et Elimination des Coupres de L'Arithmetique d'Order Superieur.
PhD Thesis.
\[Hendriks, 1989\] Herman Hendriks.
Cut Elimination and Semantics in Lambek Calculus Manuscript available from University of Amsterdam.
To appear in his PhD thesis 'Studied Flexibility'.
\[Lambek, 1958\] Joachim Lambek.
The mathematics of sentence structure.
American Mathematical Monthly, 65:154-170, 1958.
\[Mey, 1992\] Daniel Mey.
Investigations on a Calculus Without Contractions.
PhD Thesis, Swiss Federal Institute of Technology, Zurich.
\[Moortgat, 1988\] Michael Moortgat.
Categorial Investigations: Logical and Linguistic Aspects of the Lambek Calculus.
Dordrecht: Forts Publications.
\[Moortgat, 1989\] Michael Moortgat.
Unambiguous proof representations for the Lambek Calculus.
In Proceedings of the Seventh Amsterdam Colloquium, pages 389-401, Torenvliet, M.
S. L.
(ed.), Institute for Language, Logic and Information, Amsterdam, December 1989.
\[Reynolds, 1974\] :I.C Reynolds.
Towards a theory of type structure.
In Colloquium sur la programmation, 1974, pages 408-423. 129

