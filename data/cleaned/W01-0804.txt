Logical Form Equivalence: the Case of Referring Expressions Generation Kees van Deemter ITRI University of Brighton Brighton BN2 4GJ United Kingdom Kees.van.Deemter@itri.brighton.ac.uk Magn´us M.
Halld´orsson Computer Science Dept.
University of Iceland, Taeknigardur, 107 Reykjavik, Iceland and Iceland Genomics Corp., Reykjavik mmh@hi.is Abstract We examine the principle of coextensivity which underlies current algorithms for the generation of referring expressions, and investigate to what extent the principle allows these algorithms to be generalized.
The discussion focusses on the generation of complex Boolean descriptions and sentence aggregation.
1 Logic
in GRE A key question regarding the foundations of Natural Language Generation (NLG) is the problem of logical form equivalence (Appelt 1987).
The problem goes as follows.
NLG systems take semantic expressions as input, usually formulated in some logical language.
These expressions are governed by rules determining which of them count as ‘equivalent’.
If two expressions are equivalent then, ideally, the NLG program should verbalize them in the same ways.
(Being equivalent, the generator would not be warranted in distinguishing between the two).
The question is: what is the proper relation of equivalence?
Appelt argued that classical logical equivalence (i.e., having the same truth conditions) is not a good candidate.
For example, a0a2a1 a3 is logically equivalent with a4 a3a5a1 a4 a0, yet – so the argument goes – an NLG system should word the two formulas differently.
Shieber (1993) suggested that some more sophisticated notion of equivalence is needed, which would count fewer semantic expressions as equivalent.1 In the present paper, a different response to the problem is explored, which keeps the notion of equivalence classical and prevents the generator from distinguishing between inputs that are logically equivalent (i.e., inputs that have the same truth conditions).
Pragmatic constraints determine which of all the logically equivalent semantic expressions is put into words by the NLG program.
Whereas this programme, which might be called ‘logic-oriented’ generation, would constitute a fairly radical departure from current practice if applied to all of NLG (Krahmer & van Deemter (forthcoming); Power 2000 for related work), the main aim of the present paper is modest: to show that logic-oriented generation is standard practice in connection with the generation of referring expressions (GRE).
More specifically, we show the semantics of current GRE algorithms to be guided by a surprisingly simple principle of coextensivity, while their pragmatics is guided by Gricean Brevity.
Our game plan is as follows.
In section 2, we illustrate the collaboration between Brevity and co-extensivity, focussing on ‘simple’ referring expressions, which intersect atomic properties (e.g., ‘dog’ and ‘black’).
Section 3 proceeds by showing how other algorithms use the principle to legitimize the creation of more elaborate structures involving, for example, complex Boolean combinations (e.g., the union of some properties, each of which is the intersection of some atomic prop1See also van Deemter (1990) where, on identical grounds, a variant of Carnap-style intensional isomorphism was proposed as an alternative notion of equivalence.
erties). This part of the paper will borrow from van Deemter (2001), which focusses on computational aspects of GRE.
Section 4 asks how the principle of co-extensivity may be generalized beyond GRE and questions its validity.
2 Intersective
reference to sets of domain objects The Knowledge Base (KB) forming the input to the generator will often designate objects using the jargon of computerized databases, which is not always meaningful for the reader/hearer.
This is true, for example, for an artificial name (i.e., a database key) like ‘a0a2a1a4a3a6a5a8a7a10a9a12a11a14a13a16a15 ’ when a person’s proper name is not uniquely distinguishing; it is also true for objects (e.g., furniture, trees, atomic particles) for which no proper names are in common usage.
In all such cases, the NLG program has to ‘invent’ a description that enables the hearer to identify the target object.
The program transforms the original semantic structure in the KB into some other structure.
Let us examine simple references first.
Assume that the information used for interpreting a description is stored in a KB representing what properties are true of each given object.
In addition to these properties, whose extensions are shared between speaker and hearer, there are other properties, which are being conveyed from speaker to hearer.
For example, the speaker may say ‘The white poodle is pregnant’, to convey the new information that the referent of ‘the white poodle’ is pregnant.
GRE ‘sees’ the first, shared KB only.
We will restrict attention to the problem of determining the semantic content of a description, leaving linguistic realization aside.
(Cf. Stone and Webber 1998, Krahmer and Theune 1999, which interleave linguistic realization and generation).
Accordingly, ‘Generation of Referring Expressions’ (GRE) will refer specifically to content determination.
We will call a GRE algorithm complete if it is successful whenever an individuating description exists.
Most GRE algorithms are limited to individual target objects (for an exception, Stone 2000), but we will present ones that refer to sets of objects (Van Deemter 2000); reference to an individual a17 will equal reference to the singleton set a18a19a17a21a20. 2.1 The Incremental Algorithm Dale and Reiter (1995) proposed an algorithm that takes a shared KB as its input and delivers a set of properties which jointly identify the target.
Descriptions produced by the algorithm fullfill the criterion of co-extensivity.
According to this principle, a description is semantically correct if it has the target as its referent (i.e., its extension).
The authors observed that a semantically correct description can still be unnatural, but that naturalness is not always easy to achieve.
In particular, the problem of finding a (‘Full Brevity’) description that contains the minimum number of properties is computationally intractable, and human speakers often produce non-minimal descriptions.
Accordingly, they proposed an algorithm that approximates Full Brevity, while being of only linear complexity.
The algorithm produces a finite set a22 of properties a23a25a24a19a26a28a27a29a27a29a27a29a26a30a23a8a31 such that the intersection of their denotations a32a29a32a23 a24a34a33a29a33a36a35 a27a29a27a29a27 a35 a32a29a32a23 a31a37a33a29a33 equals the target set a38, causing a22 to be a ‘distinguishing description’ of a38 . The properties in a22 are selected one by one, and there is no backtracking, which is why the algorithm is called Incremental.
As a result, some of the properties in a22 may be logically superfluous.
For simplicity, we will focus here on properties, without separating them into Attributes and Values (see also Reiter and Dale 2000, section 5.4.5).
Accordingly, reflecting the fact that not all properties are equally ‘preferred’, they are ordered linearly in a list IP, with more preferred ones preceding less preferred ones.
We also simplify by not taking the special treatment of head nouns into account.
Suppose a38 is the target set, and a39 is the set of elements from which a38 is to be selected.2 The algorithm iterates through IP; for each property, it checks whether it would rule out at least one member of a39 that has not already been ruled out; if so, the property is added to a22 . Members that are ruled out are removed from a39 . The process of expanding a22 and contracting a39 continues until a39a41a40a41a38 ; if and when this condition is met, a22 is a distinguishing set of properties.
2We have chosen a formulation in which a42 is a superset of a43, rather than a ‘contrast set’, from whose elements those of a43 must be distinguished (Dale and Reiter 1995).
The difference is purely presentational.
a0a2a1a3a5a4a7a6a8a0 is initialized to the empty set a9 For eacha10a12a11a14a13 IP do If a43a16a15a18a17a19a17a10a20a11a22a21a19a21a24a23 a42a26a25a15a27a17a19a17a10a12a11a28a21a29a21 a6a10a12a11 removes distractors from a42 but keeps all elements of a43a24a9 Then do a0a30a1a3a27a0a32a31a33a6 a10a12a11a34a9 a6 Property a10a12a11 is added to a0 a9 a42 a1a3 a42a30a35a36a17a29a17a10 a11a21a19a21 a6 All elements outside a17a19a17a10 a11a21a29a21 are removed from a42a37a9 If a42 a3 a43 then Returna0a38a6 Successa9 Return Failure a6 All properties in IP have been tested, yet a42a18a25a3 a43a39a9 This algorithm, D&RPlur, constructs better and better approximations of the target set a38 . Assuming (cf.
Dale and Reiter 1995) that the tests in the body of the loop take some constant amount of time, the worst-case running time is in the order of a5a8a40 (i.e., a41a43a42 a5a8a40a45a44 ) where a5a46a40 is the total number of properties.
3 Reference
using Boolean descriptions Based on co-extensivity, the algorithms discussed construct an intersective Boolean expression (i.e., an expression of the form a23 a24 a35 a27a29a27a29a27 a35 a23 a31, where a23 a24a19a26a28a27a29a27a29a26a30a23 a31 are atomic) that has the target set as its extension.
But, intersection is not the only operation on sets.
Consider a KB whose domain is a set of dogs (a47 a26a49a48a12a26a51a50a6a26a51a52 a26 a7 ) and whose only Attributes are TYPE and COLOUR: TYPE: dog a18a53a47 a26a49a48a12a26a51a50a12a26a51a52 a26 a7 a20, poodle a18a53a47 a26a49a48a10a20 COLOUR: black a18a53a47 a26a49a48a12a26a51a50a12a20, white a18a53a52 a26 a7 a20 In this situation, D&Ra54a56a55a29a57a59a58 does not allow us to individuate any of the dogs.
In fact, however, the KB should enable one to refer to dog a50, since it is the only black dog that is not a poodle: a18a53a50a12a20 a40a60a48a62a61a63a47a20a50a65a64 a35 a0 a3 a3 a52a66a61 a7 A similar gap exists where disjunctions might be used.
For example, D&Ra54a56a55a19a57a53a58 does not make the set of dogs that are either white or poodles referable, whereas it is referable in English, e.g., ‘The white dogs and the poodles’.
Presently, we will investigate how GRE can take negation and disjunction into account.
Section 3.1 will ask how GRE algorithms can achieve Full Boolean Completeness; section 3.2, which follows Van Deemter (2001), adds Brevity as a requirement.
Boolean descriptions do the same thing that intersective descriptions do, except in a more dramatic way: they ‘create’ even more structure.
As a result, the problem of optimizing these structures with respect to constraints such as Brevity becomes harder as well.
As a first step, we show how one can tell which targets are identifiable given a set of properties and set intersection.
We calculate, for each element a52 in the domain, the ‘Satellite set’ of a52, that is, the intersection of the extensions of all the properties that are true ofa52 . Taking all extensions from our example, a38a67a47a66a68 a7 a61a63a61a34a69a70a68 a7a10a9 a42a63a47 a44 a40 a52 a3a45a71 a35 a0 a3a6a3 a52a72a61 a7 a35 a48a73a61a63a47a72a50a65a64 a40 a18a53a47 a26a49a48a10a20 a38a67a47a66a68 a7 a61a63a61a34a69a70a68 a7a10a9 a42a74a48 a44 a40 a52 a3a45a71 a35 a0 a3a6a3 a52a72a61 a7 a35 a48a73a61a63a47a72a50a65a64 a40 a18a53a47 a26a49a48a10a20 a38a67a47a66a68 a7 a61a63a61a34a69a70a68 a7a10a9 a42a63a50 a44 a40 a52 a3a45a71 a35 a48a73a61a63a47a20a50a75a64a2a40a41a18a53a47 a26a49a48a12a26a51a50a12a20 a38a67a47a66a68 a7 a61a63a61a34a69a70a68 a7a10a9 a42a63a52 a44 a40 a52 a3a45a71 a35a77a76a79a78 a69a70a68 a7 a40 a18a53a52 a26 a7 a20 a38a67a47a66a68 a7 a61a63a61a34a69a70a68 a7a10a9 a42 a7a45a44 a40 a52 a3a45a71 a35a77a76a79a78 a69a70a68 a7 a40 a18a53a52 a26 a7 a20 If two objects occur in the same Satellite set then no intersective description can separate them: any description true of one must be true of the other.
It follows, for example, that no object in the domain is uniquely identifiable, since none of them occurs in a Satellite set that is a singleton.
3.1 Boolean
descriptions (i): generate and simplify Boolean completeness is fairly easy to achieve until further constraints are added.
Suppose the task is to construct a description of a target set a38, given a set IP of atomic properties, without any further constraints.
We will discuss an algorithm that starts by calculating a generalized type of Satellite sets, based on all atomic properties and their negations.
Construction of Satellite sets: IPa31a81a80a83a82a79a84a40 IP a85 a18 a23a87a86a67a84a14a23a8a86a89a88 IP a20 For each a52a90a88 a38 do a38a92a91a79a84a40 a18a53a93a94a84a66a93a94a88 IPa31a81a80a83a82a95a84a96a52a77a88 a32a29a32a93 a33a29a33 a20 a38a67a47a72a68 a7 a61a63a61a97a69a98a68 a7a12a9 a42a63a52 a44 a40a100a99a102a101a46a103a105a104a59a106a66a42a34a32a29a32a93 a33a29a33 a44 First, the algorithm adds to IP the properties whose extensions are the complements of those in IP.
Then it calculates, for each element a52 in a38, a38a67a47a72a68 a7 a61a34a61a34a69a70a68 a7a10a9 a42a63a52 a44 by lining up all the properties in IPa31 a80a98a82 that are true of a52, then taking the intersection of their extensions.
Satellite sets may be exploited for the construction of descriptions by forming the union of a number of expressions, each of which is the intersection of the elements of a38a56a91 (for some a52a90a88 a38 ).
Description By Satellite sets (DBS): Descriptiona84a40 a18a6a38a56a91a95a84a96a52a77a88 a38 a20 Meaninga84a40 a0 a91 a103a105a104a46a42 a38a67a47a72a68 a7 a61a63a61a97a69a98a68 a7a12a9 a42a63a52 a44a44 If Meaning = a38 then Return Description else Fail (Note that Description is returned instead of Meaning, since the latter is just the set a38 ).
Descriptionis a set of sets of sets of domain objects.
As is made explicit in Meaning, this thirdorder set is interpreted as a union of intersections.
A Description is successful if it evaluates to the target set a38 ; otherwise the algorithm returns Fail.
If Fail is returned, no Boolean description of a38 is possible: Full Boolean Completeness: For any set a43, a43 is obtainable by a sequence of boolean operations on the properties in IP if and only if a0 a106a2a1a4a3a6a5 a43a8a7a4a9a11a10a2a12a13a12a15a14a16a9a17a10a19a18 a5a21a20a23a22a11a22 equals a43 . Proof: The implication from right to left is obvious.
For the reverse direction, suppose a43 a25a3 a0 a106a2a1a4a3a6a5 a43a8a7a4a9a11a10a2a12a13a12a15a14a16a9a17a10a19a18 a5a21a20a23a22a11a22 . Then for some a10a14a13 a43, Satellitesa5 a10 a22 contains an element a10a2a24 that is not in a43 . But a10a26a25a11a10 a24 a13 Satellites a5 a10 a22 implies that every set in IP must either contain both of a10 and a10a2a24, or neither.
It follows that a43, which contains only one of a10a26a25a27a10 a24, cannot be obtained by a combination of Boolean operations on the sets in IP.
DBS is computationally cheap: it has a worstcase running time of a41a43a42 a5 a27 a0 a44, where a5 is the number of objects in a38, and a0 the number of atomic properties.
Rather than searching among all the possible unions of some large set of sets, a set a38 a40 a18 a9 a24a19a26a28a27a29a27a29a26 a9 a31 a20 is described as the union of a5 Satellites sets, each of which equals the intersection of those (at most a28 a5 ) sets in IPa31a81a80a83a82 that contain a9 a86 . Descriptions can make use of the Satellite sets computed for earlier descriptions, causing a further reduction of time.
Satellites sets can even be calculated off-line, for all the elements in the domain, before the need for specific referring expressions has arisen.3 Unfortunately, the descriptions produced by DBS tend to be far from brief: a38a30a29 a40 a18a53a52 a3a45a71 a26a49a48a73a61a34a47a20a50a65a64 a26 a0 a3 a3 a52a66a61 a7 a26 a76 a78 a69a70a68 a7 a20 . a38a67a47a66a68 a7 a61a63a61a34a69a70a68 a7a10a9 a42a63a50 a44 a40 a18a53a50a12a20 a38a92a91 a40 a18a53a52 a3a45a71 a26 a76a79a78 a69a70a68 a7 a26 a0 a3a6a3 a52a72a61 a7 a26 a48a62a61a63a47a20a50a65a64 a20 . a38a67a47a66a68 a7 a61a63a61a34a69a70a68 a7a10a9 a42a63a52 a44 a40 a18a53a52 a26 a7 a20 a38a92a80 a40 a18a53a52 a3a45a71 a26 a76 a78 a69a70a68 a7 a26 a0 a3 a3 a52a66a61 a7 a26 a48a73a61a63a47a72a50a65a64 a20 . a38a67a47a66a68 a7 a61a63a61a34a69a70a68 a7a10a9 a42 a7a45a44 a40 a18a53a52 a26 a7 a20 To describe the target set a38 a40 a18a53a50a12a26a51a52 a26 a7 a20, for example, the algorithm generates the Description a18a6a38a30a29 a26 a38a56a91 a26 a38a92a80a28a20 . Consequently, the boolean expression generated is a42a63a52 a3a45a71 a35 a48a73a61a63a47a20a50a75a64 a35 a0 a3 a3 a52a66a61 a7 a35 a76a79a78 a69a70a68 a7 a44 a85 a42a63a52 a3a45a71 a35a77a76a79a78 a69a70a68 a7 a35 a0 a3 a3 a52a66a61 a7 a35 a48a62a61a63a47a20a50a65a64 a44 a85 a42a63a52 a3a45a71 a35a77a76a79a78 a69a70a68 a7 a35 a0 a3 a3 a52a66a61 a7 a35 a48a62a61a63a47a20a50a65a64 a44 . But of course, a much shorter description,a0 a3 a3 a52a66a61 a7, would have sufficed.
What are the prospects for simplifying the output of DBS?
Unfortunately, perfect simplification (i.e., Full Brevity) is incompatible with computational tractibility.
Suppose brevity of descriptions is defined as follows: a52 a24 is less brief than a52a32a31 if either a52 a24 contains only atomic properties while a52a8a31 contains non-atomic properties as well, or a52 a24 contains more Boolean operators than a52 a31 . Then the intractability of Full Brevity for intersections of atomic properties logically implies that of the new algorithm: Proof: Suppose an algorithm, BOOL, produced a maximally brief Boolean description whenever one exists.
Then whenever a target set a43 can be described as an intersection of atomic properties, BOOL(a43 ) would be a maximally brief intersection of atomic properties, and this is inconsistent with the intractability of Full Brevity for intersections of atomic properties.
3Compare Bateman (1999), where a KB is compiled into a format that brings out the commonalities between objects before the content of a referring expression is determined.
This negative result gives rise to the question whether Full Brevity may be approximated, perhaps in the spirit of Reiter (1990)’s ‘Local Brevity’ algorithm which takes a given intersective description and tests whether any set of properties in it may be replaced by one other property.
Unfortunately, however, simplification is much harder in the Boolean setting.
Suppose, for example, one wanted to use the Quine-McCluskey algorithm (McCluskey 1965), known from its applications to electronic circuits, to reduce the number of Boolean operators in the description.
This would go only a small part of the way, since Quine-McCluskey assumes logical independence of all the properties involved.
Arbitrarily complex information about the extensions of properties can affect the simplification task, and this reintroduces the spectre of computationally intractability.4 Moreover, the ‘generate and simplify’ approach has other disadvantages in addition.
In particular, the division into two phases, the first of which generates an unwieldy description while the second simplifies it, makes it psychologically unrealistic, at least as a model for speaking.
Also, unlike the Incremental algorithm, it treats all properties alike, regardless of their degree of preferedness.
For these reasons, it is worthwhile to look for an alternative approach, which takes the Incremental algorithm as its point of departure.
This does not mean that DBS is useless: we suggest that it is used for determining whether a Boolean description exists; if not, the program returns Fail; if a Boolean description is possible, the computationally more expensive algorithm of the following section is called.
3.2 Boolean
descriptions (ii): extending the Incremental algorithm In this section, we will explore how the Incremental algorithm may be generalized to take all Boolean combinations into account.
Given that the Incremental algorithm deals with intersections 4For example, the automatic simplificator at http://logik.phl.univie.ac.at/chris/qmouk.html.O5 can only reduce our description to a20 a0a2a1 a35 a3 a0a4a0 a20 a12a13a10 if it ‘knows’ that being black, in this KB, is tantamount to not being white.
To reduce even further, the program needs to know that all elements in the domain are dogs.
In more complex cases, equalities between complex intersections and/or unions can be relevant.
between sets, Full Boolean Completeness can be achieved by the addition of set difference.
Set difference may be added to D&RPlur as follows.
First we add negations to the list of atomic properties (much like the earlier DBS algorithm).
Then D&RPlur runs a number of times: first, in phase 1, the algorithm is performed using all positive and negative literals; if this algorithm ends before a39 a40 a38, phase 2 is entered in which further distractors are removed from a39 using negations of intersections of two literals, and so on, until either a39 a40 a38 (Success) or all combinations have been tried (Failure).
Observe that the negation of an intersection comes down to set union, because of De Morgan’s Law: a23a25a24 a35 a27a29a27a29a27 a35 a23 a31 a40 a23 a24a20a85 a27a29a27a29a27a83a85 a23 a31 . Thus, phase 2 of the algorithm deals with disjunctions of length 2, phase 3 deals with disjunctions of length 3, etcetera.
A schematic presentation will be useful, in which a23a6a5a8a7a10a9 stands for any positive or negative literal.
The length of a property will equal the number of literals occurring in it.
We will say that a D&R phase uses a set of properties a11 if it loops through the properties in a11 (i.e., a11 takes the place of IP in the original D&RPlur).
D&Ra12a8a13a14a13 a55a80a40 a31 : 1.
Perform a D&R phase using all properties of the form a23 a5a8a7a10a9 ; if this phase is successful then stop, otherwise go to phase (2).
2. Based on the Values of a22 and a39 coming out of phase (1), perform a D&R phase using all properties of the form a23 a5a8a7a10a9 a35 a23 a5a8a7a10a9 ; if this phase is successful then stop, otherwise go to phase (3).
3. Based on the Values of a22 and a39 coming out of phase (2), perform a D&R phase using all properties of the form a23a15a5a8a7a10a9 a35 a23a6a5a8a7a10a9 a35 a23a6a5a8a7a10a9 ; if this phase is successful then stop, otherwise go to phase (4).
Etcetera. One can require without loss of generality that no property, considered at any phase, may have different occurrences of the same atom.5 Since, therefore, at phase a5, there is room for properties of length a5, the maximal number of phases equals the total number of atomic properties in the language.
Note that D&Ra12a8a13a14a13 a55a80a40 a31 is incremental in two different ways: within a phase, and from one phase to the next.
The latter guarantees that shorter disjunctions are favoured over longer ones.
Once a property has been selected, it will not be abandoned even if properties selected during later phases make it superfluous.
As a result, one may generate descriptions like a76 a78 a69a70a68 a7 a35 a42a50a75a47a72a68 a35 a52 a3a45a71 a44 (i.e., ‘white (cats and dogs)’) when a50a73a47a72a68 a35 a52 a3a45a71 (i.e., ‘cats and dogs’) would have sufficed.
The empirical correctness of this type of incrementality is debatable, but repairs can be made if needed.6 Unfortunately, however, the algorithm is not tractable as it stands.
To estimate its running time as a function of the number of properties (a5 a40 ) in the KB and the number of properties used in the description (a5 a55), note that the maximal number of properties to be considered equals a31 a0 a1 a86a3a2 a24 a28 a4 a5 a40 a69a6a5 a40 a31 a0 a1 a86a3a2 a24 a28 a5 a40a8a7 a69 a7 a42 a5 a40a10a9 a69 a44 a7 (The factor of a28 derives from inspecting both each atom and its negation).
If a5 a55a12a11a13a11 a5 a40 then this is in the order of a5 a31 a0a40 .7 To avoid intractability, the algorithm can be pruned.
No matter where this is done, the result is polynomial.
By cutting off after phase (1), for example, we generate negations of atomic properties only, producing such descriptions as ‘the black dog that is not a poodle’, while disregarding more complex descriptions.
As a result, Boolean completeness is lost, but only for references to non-singleton sets.8 The number of properties to be considered 5For example, it is useless to consider the property a10a15a14a12a35a102a10a17a16a24a35 a10a15a14, which must be true of any element in the domain, or the property a10 a14 a35 a10 a16 a35 a10 a14, which is equivalent to the earlier-considered propertya10a18a14 a35 a10a19a16 . 6E.g., phases might run separately before running in combination: first phase 1, then 2, 1&2, 3, 1&3, 2&3, 1&2&3, etc.
(Suggested by Richard Power.) 7Compare an analogous argument in Dale and Reiter (1995, section 3.1.1). 8If a10a15a14 a5a3a20 a31a22a21 a22 a35a33a10a19a16 individuates the individual a23 then eithera10 a14 a35 a20 a35 a10 a16 ora10 a14 a35 a21 a35a102a10 a16 does.
Where singletons are concerned, set union does not add descriptive power.
by this simpler algorithm equals a42 a5 a40 a44 a31a25a24 a28 a5 a40a26a9a28a27 . If one wanted to produce more complex descriptions like a76a79a78 a69a70a68 a7 a35 a52 a3a45a71 a35 a0 a3a6a3 a52a72a61 a7 (‘the white dogs and the poodles’), the algorithm might be cut off one phase later, leading to a worst-case running time of a41a2a42 a5a30a29a40 a44 . 4 Discussion Hybrid algorithms, which make use of elements of both algorithms, are possible.
In particular, the idea of incrementality can be injected into the generate and simplify algorithm of section 3.1, firstly, at the level of the construction of Satellite sets (i.e., by letting a38a8a91 take into account only those properties from IPa31 a80a83a82 that are necessary for singling out a52 ) and, secondly, where the union of the a38a89a47a66a68 a7 a61a63a61a34a69a70a68 a7a10a9 is formed in DBS (i.e., by taking only those a38a67a47a72a68 a7 a61a34a61a34a69a70a68 a7a10a9 into account that change the resulting Meaning).
Instead of offering any details on this, we choose to discuss a more general problem relating to the problem of Logical Form Equivalence that was noted in section 1.
GRE algorithms exploit a principle of coextensivity for determining what are semantically correct ways of referring to an entity.
Thus, consistent with the idea of logic-oriented generation, the structure of the description is not prejudged by the syntactic form of the input to the generator (i.e., by the fact that the input contains an individual constant rather than a description).
As a result, GRE can ‘create’ substantial amounts of new semantic structure containing, for example, any number of Boolean operators.
In section 1, it was suggested that the processes of structure transformation used in GRE might have wider applicability.
The present section questions the validity of coextensivity as a general principle, first for GRE (section 4.1), then for sentence aggregation (section 4.2). 4.1 Descriptions in intensional contexts The principle of co-extensivity is not valid in intensional contexts.
For example, consider (a) John knows that [the red button] is dangerous (b) John knows that [the rocket launching button] is dangerous.
(a) and (b) have different truth conditions even if speaker and hearer share the information that the red button is the rocket launching button.
In other words, the two descriptions are not interchangeable, even if reader and hearer know them to be coextensive; what would be necessary is for John to know that they are coextensive.
Extending current GRE algorithms to the generation of referring expressions in intensional contexts is likely to be a difficult enterprise.
Failiure of substitutivity in intensional contexts is, of course, a well-known problem, for which various solutions are available on the theoretical market (e.g., Montague 1973, Barwise and Perry 1983).
But one has to wonder whether coextensivity is ever really sufficient.
Consider extensional truncations of (a) and (b), such as may be generated from an input I(1) (where the semantic predicate ‘dangerous’ is abbreviated as a0 and a47 is a constant referring to the button): I(1) a0 a42a63a47 a44 (aa1 ) [The red button] is dangerous (ba1 ) [The rocket launching button] is dangerous Suppose (a) and (b) are semantically interchangeable (e.g., when said to someone who knows the colours and functions of all objects in the domain), so a choice between them can only be motivated by an appeal to pragmatic principles.
Even then, it is difficult to accept that the same choice must be made regardless whether the input to the generator is I(1), I(2) or I(3): (Here a17a105a61a42a3a2 a44 says that a2 is for launching rockets; a4 is the Russellian description operator.) I(2) a32a28a42a5a4a6a2 a44 a42 a17 a7 a52a24a42a3a2 a44a8a7 a48a10a9a24a68a83a68 a3a6a5 a42a3a2 a44a44 a33 a84 a0 a42a3a2 a44 I(3) a32a28a42a5a4a6a2 a44 a42 a17a105a61a42a3a2 a44a8a7 a48a10a9a24a68a83a68 a3a6a5 a42a3a2 a44a44 a33 a84 a0 a42a3a2 a44 . Co-extensivity, after all, does not allow the generator to distinguish between I(1), I(2) and I(3), because these three have the same extension!
Perhaps a weakened version of co-extensivity is needed which allows the generator to add new structure (e.g., when the input is I(1)), but not to destroy existing structure (e.g., when the input is I(2) or I(3)).
It is, however, unclear what the theoretical justification for such a limitation of coextensivity might be.
Note that these problems become more dramatic as GRE is able to ‘invent’ more structure (e.g., elaborate Boolean structure, as discussed in section 3).
Crucially, we have to assume that, in an ideal generator, there are many other pragmatic constraints than Brevity.
One description can be chosen over another, for example, because it fullfills some additional communicative goal (Dale and Reiter 1995, section 2.4; also Stone and Webber 1998).
Depending on the communicative goal, for example, (b) might be chosen over (a) because the properties that identify the button also explain why it is dangerous.
Brevity will then have to be interpreted as ‘Brevity provided all the other constraints are fullfilled’.
4.2 Logic
in sentence aggregation GRE algorithms are sometimes presented as if the principles underlying them were unrelated to those underlying other components of an NLG system.9 This is especially true for the logicbased structure transformations on which this paper has focused.
In what follows, however, we will suggest that analogous transformations motivate some of the key operations in sentence aggregation (Reiter and Dale 2000, p.133-144).
To exemplify, (and limiting the discussion to distributive readings only) the choice between the (a) and (b) variants of (1)-(3) involves a decision as to whether information is expressed in one or more sentences: 1a.
John is eating; Mary is eating; Carlos is eating.
1b. John, Mary and Carlos are eating.
2a. John is eating; John is drinking; John is taking a rest 2b.
John is eating and drinking and taking a rest.
3a. If John is eating then Mary is eating; If Bill is eating then Mary is eating.
3b. If either John or Bill is eating then Mary is eating.
Writing a11a33a47a72a68a13a12 a42 a38 a44 for a14a15a2 a88 a38 a42a6a11a14a47a66a68a65a42a3a2 a44a44 (Kamp and Reyle 1993), the linguistic equivalence of (1a) and (1b) rests on the logical equivalence 9But see Bateman (2000), where GRE and aggregation are linked.
1a1 . a42a6a11a14a47a66a68a65a42a0 a44a8a7 a11a33a47a72a68a75a42a2a1 a44a8a7 a11a14a47a66a68a65a42a63a50 a44a44a4a3 a11a14a47a66a68a13a12 a42 a18 a0 a26a5a1 a26a51a50a12a20 a44 Analogous to uses of Brevity in GRE, a preference for (1b) over (1a) might be motivated by a preference for a semantic structure with fewer logical operations.
Examples (2)-(3) are not dissimilar to what we see in (1).
For example, the following logical equivalences support the linguistic equivalence of (2a)/(2b) and (3a)/(3b): 2a1 . a42a7a6 a47 a7a9a8 a47 a7a11a10 a42a63a47 a44a44a12a3 a42a14a13 a2a5a84a15a6 a2 a7a9a8 a2 a7a11a10 a2 a44 a42a63a47 a44 3a1 . a42a42a0 a24 a1 a3 a44a8a7 a42a0 a31 a1 a3 a44a44a16a3 a42a42 a0 a24a16a17 a0 a31 a44 a1 a3 a44 In (a28 a1 ), three properties, a6 a26 a8 and a10, are aggregated into a13 a2a27a84a18a6 a2 a7a9a8 a2 a7a19a10 a2 (i.e., to have each of the three properties a6 a26 a8 and a10 ).
In (a15 a1 ), two antecedents a0 a24 and a0 a31 are aggregated into a0 a24a20a17 a0 a31 . 10 As before, a generator might prefer the (b) versions because they are structurally simpler than the logically equivalent (a) versions.
In sentence aggregation, however, co-extensivity is not enough.
For example, we expect ‘Eat(j)’ to be worded differently from ‘Eat(m)’, even if both propositions are true and consequently have the same extension.
Unlike GRE, therefore, aggregation requires at least logical equivalence.11 5 Acknowledgment Thanks are due to Emiel Krahmer for discussion and comments.
References Appelt 1987.
D.E. Appelt.
Bidirectional Grammars and the Design of Natural Language Generation systems.
In Theoretical Issues in Natural Language Processing-3, p.185-191.
New Mexico State University, Las Cruces.
Barwise and Perry 1983.
J. Barwise and J.
Perry. Situations and Attitudes.
MIT Press.
Bateman 1999.
J.A. Bateman.
Using Aggregation for Selecting Content when Generating Referring Expressions.
In Procs.
ACL-99, Univ.
Maryland. 10Note the disjunction, which would be difficult to get if the transformation was performed at a syntactic level.
11In some (e.g., epistemic) contexts, even logical equivalence is not enough.
This mirrors the problems with coextensivity that were noted in connection with GRE.
Dale 1992.
R. Dale.
Generating Referring Expressions: Constructing Descriptions in a Domain of Objects and Processes.
MIT Press, Cambridge.
Dale and Reiter 1995.
R. Dale and E.
Reiter. Computational Interpretations of the Gricean Maximes in the Generation of Referring Expressions.
Cognitive Science 18: 233-263.
Grice 1975.
P. Grice.
Logic and Conversation.
In P.
Cole and J.
Morgan (Eds.), “Syntax and Semantics: Vol 3, Speech Acts”: 43-58.
New York, Academic Press.
Kamp and Reyle 1993.
From Discourse to Logic.
Kluwer Academic Publishers, Dordrecht.
Krahmer and Theune 1999.
E. Krahmer and M.
Theune. Generating Descriptions in Context.
In R.
Kibble and K.
van Deemter (Eds.), Procs.
of ws.
Generation of Nominal Expressions, ESSLLI’99.
McCluskey 1965.
McCluskey, Jr., E.J.
Introduction to the Theory of Switching.
New York.
McGraw-Hill. Montague 1973.
R. Montague.
The Proper treatment of Quantification in Ordinary English.
In R.H.Thomason (ed.) Formal Philosophy.
Yale University Press, New Haven.
Power 2000.
R.J.D. Power.
Planning texts by constraint satisfaction.
Procs of the 18th Int.
Conf. on Computational Linguistics (COLING-2000), Saarbruecken, pp.
642-648. Reiter 1990.
E. Reiter.
The Computational Complexity of Avoiding Conversational Implicatures.
In Proc.
ACL-1990, Pittsburgh.
Reiter and Dale 2000.
E. Reiter and R.
Dale. Building Natural language Generation Systems.
Cambridge University Press, Cambridge, UK.
Shieber 1993.
S. Shieber.
The Problem of Logical-Form Equivalence.
Squib in Computational Linguistics 19, 1.
Stone 2000.
M. Stone.
On Identifying Sets.
In Procs.
of INLG-2000, Mitzpe Ramon.
Stone and Webber 1998.
M. Stone and B.
Webber. Textual Economy through Close Coupling of Syntax and Semantics.
In Procs.
of INLG-1998, p.178-187. van Deemter 1990.
Structured Meanings in Computational Linguistics.
In Procs.
of COLING-1990, Helsinki.
van Deemter 2000.
K. van Deemter.
Generating Vague Descriptions.
In Procs.
of INLG-2000, Mitzpe Ramon.
van Deemter 2001.
Generating Referring Expressions: Beyond the Incremental Algorithm.
In Procs.
of Int.
Workshop on Computational Semantics (IWCS-4), Tilburg .

