A Dutch to SQL database interface using C4cnc, e lized Quantifier Theory \])irk Spcelmml \[I\] (\]ccri; Adriaens \[1'2\] \[1\] Universily of l,cuvcn (Jcnl;er \[or Comput~tional l,inguisi;ics, Blijdc-Inkomststra.~t 21, 3000 l,cuven, Belgium \[2\] Sicme:ns-Nixdorf Software Centre Lib.ge, Rue des lJ'orics 2, 4020 Lib.ge, Belgium Abstract This paper presents the treatment, of quantitication as it was imI)lemented in a prototyl)c of a natural language relational database interface for l)utch 1.
It is shown how the theoretical 'generalized (tuantifier' apl);tratlts introduced in formM semantics by Barwise and (\]oot)er can be I, uned to irrq)lementational feasi" ( bility.
(,ompm ~d to the t, raditional tl'(~atl'flellt of (luan tilication, tile alternative l)rcs('nted here offers gre;tl;er ext)ressive l)ower, great,re' similarity to natural language and, as ~t consequoxmo., the possibility o\[' a more straighl,forward tral,slation from natural language to tbrmal repres('.ntation.
1 INTRODUCTION
In the prototyl)e at hand, as in many database inter faces, the natural languag(', input is translated go a conventional formal query language, vviz.,qQL, the most widely used and supported of these languages.
The resulting SQL queries can then be 1)asscd to an already existing SQL interpreter.
The translation i)roccdui:e fi'om Dutch to SQI, is spill, up in two (:OrlSCcutive trl~tior sl,eps, using a logic-based itllierrrlediate sel/la.nLic represellta£ion called GonerM Sem~mtic lepresentation (GSH).
2. The functionality of' the whole database interface, including the SQI, interpreter, was seen as a straight, forward implementation of the fornial semantic Montague-style (Montague,197:l) mechamsm of indirect interpretat;ion of natural language (see Fig.
1). T I NI, --b.-C~Sl-~ 1)13 NL i.....
+ (}~{It ..... -q~ SQI, --~ I)B l!'igure 1: Major processing steps in the I)B interface 'Grafting' tbrmal semantic pro(:essing steps upon ~tn NI, datal)ase interface architecture has 1)een \[)r(>l)~1 \[u this i>aper the actual iinl)lelnentation is not in focus (see Sl)eelman, 1992).
2WiLhln a frmneworl¢ of machine I,r;msl;tti(m, we c;m say 1 llal, (-ISIt, is a kind of logic-based intcrlingua.
gated and (succesflllly) worked out betbre in a some whal, comparable project carried out at the university of l,',ssex (see 1)e Pmeck, Fox, Lowden, Ttlrner gz Walls, 1991).
The main concern in that project was to clearly separate domain (-database) dependent semantic intbrmation t?om domain independent semantic information.
In the project presented he.re a similar but more general ol/jective was to maximize the separation of the N LI ) data and filnctionality of the system fi:om its purely database oriented data and fimctionality, GSR being the interface structure.
13ntch queslion I I 1 .....
I 1 .1.
NI, d&ta ~ 1, (If4l generat,,r I I ................................... t.
............ n n C~SR expre~aion iT)rl -:*B ~s~ s2 gzK ............................. t .............
I)llSII. query 1 .................................. t ...........
SQL query Figure 2: General architecture of the program 'File main topic of this paper, treated in section 3, is the application of 'generalized quantitier theory' in GSR.
llaving become classical in mathematical and some theoretical linguistic studies on quantification (SeC resp.
Mostowski, 1!)57 and Barwise,~z Cooper, 1981), tile theory is now beginning to be appreciated in A\[ (and NI,P) for its richness and flexibility.
Probably the best illustration of this upcoming interc'st is the incorporation of 'generalized quantifiers' in the popular (kmccI)tuat Graph knowledge represenl;ation for-realism (see e.g.
Sowa, 1991).
A somewhat differently 7029 oriented AI-application also using 'generalized quantitiers' can be found in (Kaan, Kas & Puhland, 1990).
These applications concentrate on the expressive and inferential power of 'generalized quantifier theory' respectively.
The program presented here additionally illustrates how the use of (a variant of) the theory reduces the complexity of implementing {;he translation from natural to formal and artificial language.
2 GSR: GENERAL OUTLINE The question what GSR should look like was to a l~rge extent tackled in a very pragmatical way.
As far as the linguistic module of the program is concerned, the following criteria were formulated.
GSR had to be a formal representation (i) with sufficient expressive power so theft every possibly useful query can be formulated in it in a not too complex fashion, (ii) that is relatively easy to reach computationally, starting off from natural language.
A general observation is that, considering the kind of NL sentences one can expect as input to the system, GSR, inevitably had to differ from logical formalisms such as the ones used in formal semantics (focussing on propositions).
In view of the general decision to work with intermediate, semantic expressions the denotation of which is the answer to the NL questions, the basic types of complete expressions listed in Pig.
3 were found useful.
In this figure 9~ stands for an arbitrary proposition in some logical language L.
The e.xtension of L created by introducing these new types will be called L '.
(i) propositions (format: ¢p), to be used when people ask yes-or-no questions (ii) set expressions (format: {a~, \[ ~o}), to be used when people ask non-numerical identity questions (iii) mathematical expressions (formFtt: #({~" \] go})), to be used when people ask for nmnerieal information Figure 3: GSR: types of expressions 3 FROM DUTCH TO GSR 3.1 ~ and V: problems The traditional.way of coping with quantification in NL database interfaces is by using _~ and V, the classical first order predicate logic (PL) instrmnents (see e.g.
Warren & Pereira, 1982).
This approach, however, does not meet the criteria set out above.
To illustrate this, we basically rely on two observations Barwise &.
Cooper (1981) made to show a fundamental difference in the natures of NL and PL.
Their observations will be 'transposed' to the computational application at hand.
The first observation is illustrated in figure 4, which contains some Dutch questions attd their most natural PL' counterparts.
Whereas the Dutch sentences have the same syntactic structure, their PL' counterparts have different formats.
These and many other examples suggests that there is no trivially compositionM way of translating NL expressions to their nearest PL' equivalents.
The problem is thai; the quantiticational information, which in NL has a fixed location, is spread over the PL' expression in a seemingly arbitrary way.
It may be concluded that criterium (ii) for a good GSR is violated.
1 Zijn
alle werknemers gehuwd ? 'Are all employees married'? 2 Zijn bcidc werknemers gehuwd?
'Are both employees married'?
~.~-ff~((,~ ¢ ~2)A Vy(ert~plo~dec(y ) ~ ((y = Xl)V (y : 0C2)))A rnarried(:q ) A mar,'ied(x2)) ) 3 Zijn precies drie werknemers gehuwd?
'Are exactly three employees married'?
(:/"1 # '~2) A (a31 ¢ "r:'3) A (:';2 ~;~ gJ3) A .... ployee(x I ) a employee(z" 2 ) A errzployce(~: 3 ) ^Vy(( ......
"icd(y) A employee(y)) ((y : Xl) V (y : "2) V (y = Xg))A .....
"ried(eo" l ) A ....... ied(x2 ) A ......
"ried( a; 3 ) ) ) ) 4 Zijn rncer dan de helft van de werkrlerners gehuwd7 'Are more than half of the employees married'?
Figure 4: Translation of quantification from Dutch to PL' A second, more serious reason f'or the inadequacy of E and V is that some forms of Nil, quantification (:art only be expressed in a very complex way (e.g.
Fig. 4, examples 2 and 3) or simply cannot be expressed at all (e.g.
Fig. 4, example 4).
llere criterium (i) is not satisfied.
A third problem, mentioned in Kaan, Kas & Puhland (1990), is that in practice, e.g. in implementations, one is tempted to make rough translations, and to neglect nuances or strong conversational implicalures in natural language, when one is limited to 3 and V.
So, for instance, in Warren & Pereira (1982) %', 'some' and 'the' all are simply interpreted as ~.
3.2 L(GQ)': a solution There are many ways to try atnl get around the shortcomings of the traditional approach.
To score better on criterium (i), i.e. to increase expressive power, one could consider the introduction of nnmbers in the logical formalism.
Only, one can imagine that, if made in an ad hoc way, this extension could result in a hybrid formalism (with respect to quantification) showing an even greater syntactical mismatch with NL (decreasing the score on criterium ii).
A solution for these probleins was first explored by Montague (1973), and later thoroughly worked out by Barwise & Cooper (1981)in a formalism called L(GQ).
In contrast to traditionM Pfi, which only has 3 and V, the language of generalized qnantifiers L(GQ) specilies no limitation of the number of primitives to express quantification.
All kinds of del, erminers ('.an be used.
The translation of the examples of Vig.
4 to L(GQ)' is given in Fig.
5. Some special notational conventions Barwise & Cooper introduced, are left ont.
Fur1030 thermore ~t relal, ion~fl perspective (see Zw;u'ts, 1983) is llsed.
2 :1 4 Zijn alle werknemers gehuwd ?,u({~ I .... vlov~,(,:)), {* I,,,,.,.i~d(x)}) Zijn be|de werknemcrs gehuwd? th~_~({,, I ~,,~vtow4:,:)}, {~ I .....
.,,i~a(x)}) gijn precies drie werknemers gehuwd? e:t: act ly Zl ({a: I emptoyee(,:)), {a: I mar,'ied(.v)} ) -~Zijn meet dan de helft wm de werknemers gehnwd? rrzm'e_than_~.
2 tit ({:,: I ..... .1o.,,4.:)}, {.,: I .......,'~-,z(20)D _ I?igure 5: Tr;mslation o\[ ql~m21;ifical,ion from Dutch t.o I,((\]q)' The.
denotation of I,(GQ)' determiners is de.fined ~l; a meta--h',vel, Some (,xamples are given in (1) Co (/1).
12, these examples I stands for m~ inl, erpreA, al;ion funcl;ion mNq)ing ~m expression on its de.notation.
"r,...
(it (x(v) \ *(x)) = ~) b) ~(,11(~, x)) :: i,,,,~,~,~ (oth,,,'wi~;(0 I(tl ......
(q~,X)) = UndefiTze.d (if #(l(V~)) 7':,z) ~(,m(v,, x)) (,,th(,,.,,,i,~) (P') *(~:.,,(,~.ttu_,,(~o, x)) = "r,..~ (if #(v n x) =,*) • False (atherwise) (3) t(.,o,.,~.~ ........... th(e, x)):: "~',.,,, (it #(/(w) r~ X(x)) > #(t(w))/,,) (d) l,'alsc (ot, herwise) In Fig.
5 the sl;ructural similarity of the NI, expressions is |'eflected in that of the I,(GQ)' expressions.
l;urthermore., all N l, e.xamples (;&II\[le expressed almost equally easily in \[,(QQ)'.
By consequence, the formalism does not \[brce peol)le tel Ioe satisfied wil,h rough l;r~msl~l,ions.
In shorl;, 1;t1(; problems o\[' l, radil, ional logical quant, ifi(;ation are overcome.
3.3 L(GQ)': complications Unfortnnately, there are two reasons for not, consider-.
ing I,(GQ)' an ideal sohll, ion.
The first probhml actually is not typic~d of I,(GQ), lml, of l;he fact that B~rwise & COOl/er take over i;he Mont~Govian way of coping with I)ossible ambiguiW due to phenomena of quantilier scope.
In these cases one reading is gener;*ted in ~t straighl,forwa,rd way by H~rwise &, COOlmr.
To allow for altern~ttive red,dings, they introduce extra machinery (called t,\]2o 'qumll, itieat;ion rule').
'l'he l~ttl, er iFleella, lliSlil~ howevel; coiivelli(:ll~; \[1!o211 it l,heoretic?fl point of view, is rather imph~me~ntation-.
unfriendly. It Ol)eral;es ou coml)lete sl, ructural descriptions (=non-t;rivial trees), and generat,es comph'l,e strucl, urM descril/tions.
Allowing for such ;~ rule drastically changes the l)rolih~ of I, hc pm:ser thai; is needed.
The second problem is (,h~l, il, is undesirable for GS It, being mt interface \[;mgm~ge with ;~ non NI,P me(hilt, to court,in the set of (NL instlircd ) det, erminers l;hal, I,(GQ)' contains.
It wonld prol)~d)ly be I)el.ter it' GSt had fewer primilJves, prererably of a l,ype not com.
plei;ely uncust, oma,ry in traditiomd I)I}MSs.
3.4 GSR: an L(GQ)' derivative As a soluti(/n for these problems I,(GQ)' gets two new neighbours in the 1,ransh~tion process, as shown in Fig.
6. NI, ---ikStI.I --~,-b(G-q)'---I~ (\]SIt I"igure 6: Major processing steps in the, N I,P subsys.\[,(Jill In order to avoid l,he N)pli(:~Ltion of the 'qu~mlJtication rule', th(; choice has been to first generate, an expression that is neul;ral wil, h resl)ect, l;o l, he SeOlle of its quantifie.rs (SR.1), and then solve the scope I)rOt> lem in a second step, hereby generating m2 I,(GQ)' ex~ press|on.
The 1,rick of first ge.ne.rating a scope-neula'M expression is not new.
I,'or instance, it, is used in the l,OQUl system (see Gailly, l~.ibb('.ns & Binot, 1990).
The originality lies ral, her in the eflbrt to respect well-l'ormedne.ss iut, he scope-neutral expre.ssions. hdbrn,ally speaking, SILl is a llre.dieate-logic;fl for-realism in which the arguments of the llredicates ~Lre inte.rnally structure.d as l;hl~ N \[, arguments of verbs.
The most imt)ort~mt (:onsequence is that del;erminers are local,ed within the predi(:~fl;e-~rguments, q'o give an example, 'Werk('n alle werknemers a~m l,wee projekten'?
(l)o all employees work on two projects)? wouhl be represent;ed ;ts (5).
For idenl;il;y and cm:dinMil,y ques t.ions l, he formats in gig.
3 ;~re rn~(le SUl)ertluous by the pseudo .(M;ermin(:rs Wll and CARl).
For insl,ance, |;he quest,|e22 'Uelke werktlem('.rs werkell aan t,wee pro jekten'?
(Which e.mph}yees work on two projects)? is translated to (6).
..... q:(all({a" I .... ploy,.'e(x)}), 2({~: I proj~:ct(x)})) (5) ...... k(W//({~: I .... ployee(,v)}), 2({:c I p,'ojeet(x)})) (Ci) The l, ranslation of NL l,o SI1 is a sl, raightA'orward eoint)ositionM process, compar~tbh'~ t,() the I}arwisc ()oopcr processing of readings for which no 'quantification rule' is ne.eded.
The algorithm lbr going fi'om SRI 1,o L(GQ)' is given in l?ig.
7. If an S11 expression contains a pseudo-determiner W\]I or CAll.l), the schema in Fig.
7 is adapl;ed as fol lows.
In the first step the arguments with reM determiners are replaced by w~rb~bles vl up to v~,, ~md the cial w~riable v0.
l!'urther, |;he result ~o of the norm;fl secolld sl,(}l/ is IAil'l|ed into ;t se|, expression or ~t numer~ i~l,:xt,,:,~.~.io.
({,,,, I & A ~},l,: #({~,~ I,v,, A ~})) 'rhe t, hird step, which is ~o-inl, ernal, remains unchanged.
The essent;iM part in Fig.
7 is l;he procedure that d(' te.rmines th(; possi/)le SCOlle-configur~tions.
In l;he progl'a, lrl only one, I;he most I)robad)le scope-conligurat,ion is genexai;e(l.
The algorithm st~d, es that <,he e~rlier some quantifier occurs in I;he N l, e.xpression, the larger its s(:ol)e should be in the I,(GQ)' expression.
In t, he 1031 P(D 1 (S 1 ), 02(S 2 ) .....
D n(Sn )) t Every argument Di(,~i) is replaced by a new, unique variable vi (i E {1,.
.... }) t ...p(~,v2,...,v,O... t An independent procedure is run to determine tim probable or possible scope of the determiners.
The determiners are wrapped around the initial proposition according to this scope.
Formally the scope-determining procedure generates for every probable or possible reading a permutation f of {1,,...,n}.
t 01(1)(...Dj(.2)(...Dj(,)(..
P(Vl,V2,...,v,~)...)...))... t The remaining lacunes are filled up by adding, as shown, to every determiner 0i its original domain-set Si, and the variable vi that was introduced before to replace l)i(Si) (i C {1 .......
}) t D t(1)(sj(t),.{vf(t) I Ds(2)(sf(2), {vL()?
I ;q;, 01(n)(Sl(n),{Vl(n ) l~tVl,~2,''',v")1)'''l)1) Figure 7: Schema for translation fl:om SR.1 to L(GQ)' NL fragment that was tested extensively with the program, this procedure proved to be amazingly accurate (see Specimen, 1992, 85 98).
The fllture goal, however, is that instead of on('.
most probable reading a list of all possible readings, tagged with a degree of probability, is generated.
Since the procedure is a separate module, any extension or alteration of cat, be made without affecting the rest of the program.
What remains to be overcome, is the fact that introducing a large set of determiners in GSH.
would burden the interpreters used it, the database subsystem with an extra, NLP-type recognition tank.
This problem is solved by giving L(GQ)' a righthand neigbonr (see Fi X.
6 in which the determiners are replaced by what was originally the recta-level definition of their semantics (see (1)-(4)).
In the resulting I,(GQ)' derivative, called GSR, the numl)er of primitives (set, set intersection, set difference, set cardmality, )... is drastically reduced.
Fnrthermore, the new primitives are much closer to, and even at the heart of, the procedural and semantic building blocks of traditional computer science in general, and of relational DBMSs in particnlar.
An example of the complete procedure, going from SILl to L(GQ)' to (\]SP~, is given in (7) up to (9).
'\['he question is 'Zijn alle werknemers gehuwd'?
(Are all employees married?).
all({:q l employee(:q)}, {xl lmarried(x,))) (8) 4 FROM GSR TO SQL As the NLP subsystem, the database subsystem is hilly implemented.
However, we shall restrict ourselves to a very brief sketch of its functionality here.
As can be seen in Fig.
2, a GSH, expression is first translated to a formalism called I)BSIL This was clone for reasons of modularity, primarily for facilitating the extension of the system to dill?rent target languages.
DBSR, which stands for DataBase specitic Semantic Representation, is a declarative relational database query language that is both close to GSR and easily translatable to any of the commercialized \]{.I)BMS query languages.
Apart from the treatment of quantification the formalism is very sffnilar to relational eah:nlt, s.
The major effort in the step fron, (\]S\[{ to I)BSR lies in adapting GSl-terminology to concrete names of tabels and columns of a database.
This is done using a Dl3-1exicon, which can be seer, as an augmented l~,t-mode\] of a data/)ase.
The last step, from I)BSR to SQL, is extremely straightforward.
Sets and cardinality expressions are translated l,o (sub)qneries.
Relations between sets or cardinality expressions are.
translated to conditions for (sub)queries.
For completeness, an example of the database subsystem ontlmt is given.
For the last example of the foregoing section a I)BSI expression and an SQI, query are giver, in (10) and (11)respectively.
YES contains only 'Yes'.
{:el I .... ployee(':l)} \ {':1 I a"l .rr'a?'7"i('d = w\],J} = ~ (10) SFLECq ? * FtOM YES WIIl';ll, l'3 NOT EXISTS ( SI'~I,I'~C'F Xl.* FII.OM t!'MPI,OYI'~E X1 WI,I'~RE NO'I' (X1.MAII.I(\[I'~D = 'q")) (11) 5 IMPLEMENTATION The system is written in Common Lisp (according ;o the' de facto standard Steele,90) and generates star> dard SQL queries (ISO).
It has prow'd to be a perfectly portable product.
Originally written on a Macintosi SE/30, it has afterwards been tested on several Symbelies, Macintosh and PC platforms.
The major modules of the linguistic component are a 'letter tree' tool for efficient communication with the lexicon, a transition network based morphological analysis tool, and an augmented chart parser for syntactic and semantic analysis.
6 CONCLUSION
In some subfields of formal semantics the traditional logical apparatus for quantification, i.e. the use of and V., is being abandoned in favor of 'generalized quantifiers', because the latter are both ch)ser to natural language and richer in expressive power.
In this text it has been shown how this theory can he put to use in a natnral languagc database interface, an other field ht which ~ and V had become traditional.
Some modifications had to be made in order to l'onder the theoretical 'generalized quantifier' approach 7032 more implementation-friendly.
The major moditicaI;ions were \[,he inl;roduction of a sepal:al;e module to replace the 'quanl;ilication rule', and the shift, from rnet;a-lew'J I;o logical representation of some settheoretical primitfives.
References \[1\] Ba,:wisc, J.
& (;ooper, IL (1981).
'(;<;neralizcd Quanl, ilicrs and Nal,nral Language'.
Linguistics and Philosophy 4, 159-219.
\[2\] (?odd, E.I ~.
(1!)70). 'A Data Sublanguagc Founded on l, he Rdal;ional Calculus'.
AUM 5'IUI,'IDI,27 ' Workshop on l)ala Description, Access and Control, November 1971.
\[3\] l)c II.o<!ck, A.N., Fox, (L,1., 1,owden, I/.
(UI'., Tur-nor, II..
& Walls, I/.H,.
(1991). 'A Natural Language Sysl.ern Based on Formal Semantics'.
Proceedings of lhe lnlernalional CoT@fence on (/urrcnt l.s.rues in Compulalional Linguistics.
268-281. \[4\] Gailly, P.J., l,ibbens, 1).
& Binot,,I .L.
(199(/). 'l,a <tuanl, ilieation en Traitcment du Language Naturel'.
\[5\] IS()'1'(797/8C21/W(;3 and ANSI X3H2 (1987).
ISO 9075 Dalabasc Language SQL.
\[s\] Ka~,~, E., Kas, MM.,~: Puht~,,d, ll..
(l~J!t0). 'f,;,'.n procedure veer l'ed()llel'(Hl l\[lel, kw~l, llt()rell'.
TABU I\]ullelin veer T<tahvete~z.schap 2(\] (4).
205 221.
\[7\] Montague, H,.
(I.9TI). 'Tho l'rop<;r Treatment of quantiiication in Or<linary l!nglish', llintikka J., Moravcsik J.
& Suppes P.
(otis). Approache.s lo Natur'al Language.
I)ordrcch\[; : H,eidel.
221-.242. \[8\] Mostowski, A.
(1957). 'On a (\]eneralization of Qnantitiers'.
1,'~tnd.
Math. 44, 12-36.
\[9\] Sowa, J.F.
(19!)1). 'Towards the Expressive Power o\[ Natm:al Language'.
J.F. Sowa (ed.), I'ri'nciples of Scmanlic Net'work,~.
San Marco, (laliibrnia : Morgan Kaufinann.
157 189.
\[10\] Spcelman, 1).
(1992). l,;cn prototype voor ecn da¢abase-interfacc in Lisp.
Vc'rtaling van Ncder'landse w'agen naar SQL-queries, (?omlmtationa\[ 1,inguisti<'s Thesis, University of \],euven (in l)utch).
\[11\] Steel<:', C;.L.
(1992). Common Li,sl, : 7'he Lang'u<l<le.
Second Edition.
Digital Press : Be<tford MA.
\[12\] Warren, I).ll.
& P<~reira, F.C.N.
(1982). 'An Eflicicnl, Easily Adapl;al>le System for Interpreting N~tl,ural Language Qu<;ries'.
American Journal of Comlrulalional Linguistics 8.
110:\] 19.
\[13\] Zwarts, F.
(1983). 'Determiners: a relational perspective'.
'\['er Meulen ((ed).,q'ludies in Modellheorelic Semantics.
I,'oris : I)ordrechl;.
37-62. 1033

