Proceedings of the 2008 Conference on Empirical Methods in Natural Language Processing, pages 725–734,
Honolulu, October 2008. c©2008 Association for Computational Linguistics
Lattice-based Minimum Error Rate Training
for Statistical Machine Translation
Wolfgang Macherey Franz Josef Och Ignacio Thayer Jakob Uszkoreit
Google Inc.
1600 Amphitheatre Parkway
Mountain View, CA 94043, USA
{wmach,och,thayer,uszkoreit}@google.com
Abstract
Minimum Error Rate Training (MERT) is an
effective means to estimate the feature func-
tion weights of a linear model such that an
automated evaluation criterion for measuring
system performance can directly be optimized
in training. To accomplish this, the training
procedure determines for each feature func-
tion its exact error surface on a given set of
candidate translations. The feature function
weights are then adjusted by traversing the
error surface combined over all sentences and
picking those values for which the resulting
error count reaches a minimum. Typically,
candidates in MERT are represented as N-
best lists which contain the N most probable
translation hypotheses produced by a decoder.
In this paper, we present a novel algorithm that
allows for efficiently constructing and repre-
senting the exact error surface of all trans-
lations that are encoded in a phrase lattice.
Compared to N-best MERT, the number of
candidate translations thus taken into account
increases by several orders of magnitudes.
The proposed method is used to train the
feature function weights of a phrase-based
statistical machine translation system. Experi-
ments conducted on the NIST 2008 translation
tasks show significant runtime improvements
and moderate BLEU score gains over N-best
MERT.
1 Introduction
Many statistical methods in natural language pro-
cessing aim at minimizing the probability of sen-
tence errors. In practice, however, system quality
is often measured based on error metrics that assign
non-uniform costs to classification errors and thus
go far beyond counting the number of wrong de-
cisions. Examples are the mean average precision
for ranked retrieval, the F-measure for parsing, and
the BLEU score for statistical machine transla-
tion (SMT). A class of training criteria that provides
a tighter connection between the decision rule and
the final error metric is known as Minimum Error
Rate Training (MERT) and has been suggested for
SMT in (Och, 2003).
MERT aims at estimating the model parameters
such that the decision under the zero-one loss func-
tion maximizes some end-to-end performance mea-
sure on a development corpus. In combination with
log-linear models, the training procedure allows for
a direct optimization of the unsmoothed error count.
The criterion can be derived from Bayes’ decision
rule as follows: Let f AG f1,...,fJ denote a source
sentence (’French’) which is to be translated into a
target sentence (’English’) e AG e1,...,eI. Under
the zero-one loss function, the translation which
maximizes the a posteriori probability is chosen:
ˆe
AG argmaxe AWPrD4eDGfD5
B4 (1)
Since the true posterior distribution is unknown,
PrD4eDGfD5 is modeled via a log-linear translation model
which combines some feature functions hmD4e,fD5
with feature function weights λm, m AG 1,...,M:
PrD4eDGfD5 AG pλM
1
D4eDGfD5
AG
expAGEWMm
AG1 λmhmD4e,fD5
AO
EW
eBD exp
AG
EWM
mAG1 λmhmD4eBD,fD5
AO
(2)
The feature function weights are the parameters of
the model, and the objective of the MERT criterion
is to find a parameter set λM1 that minimizes the error
count on a representative set of training sentences.
More precisely, let fS1 denote the source sentences
of a training corpus with given reference translations
725
rS1 , and let Cs AG D8es,1,...,es,KD9 denote a set of K
candidate translations. Assuming that the corpus-
based error count for some translations eS1 is addi-
tively decomposable into the error counts of the indi-
vidual sentences, i.e., ED4rS1 ,eS1D5 AG EWSs
AG1 ED4rs,esD5,the MERT criterion is given as:
ˆλM1
AG argmin
λM1
AZ S
F4
sAG1
EA0rs,ˆeD4fs;λM1 D5A8
B7
(3)
AG argmin
λM1
AZ S
F4
sAG1
K
F4
kAG1
ED4rs,es,kD5δA0ˆeD4fs;λM1 D5,es,kA8
B7
with
ˆe
D4fs;λM1 D5 AG argmaxe
AZ M
F4
mAG1
λmhmD4e,fsD5
B7
(4)
In (Och, 2003), it was shown that linear models can
effectively be trained under the MERT criterion us-
ing a special line optimization algorithm. This line
optimization determines for each feature function
hm and sentence fs the exact error surface on a set
of candidate translations Cs. The feature function
weights are then adjusted by traversing the error
surface combined over all sentences in the training
corpus and moving the weights to a point where the
resulting error reaches a minimum.
Candidate translations in MERT are typically rep-
resented as N-best lists which contain the N most
probable translation hypotheses. A downside of this
approach is, however, that N-best lists can only
capture a very small fraction of the search space.
As a consequence, the line optimization algorithm
needs to repeatedly translate the development corpus
and enlarge the candidate repositories with newly
found hypotheses in order to avoid overfitting on Cs
and preventing the optimization procedure from
stopping in a poor local optimum.
In this paper, we present a novel algorithm that
allows for efficiently constructing and representing
the unsmoothed error surface for all translations
that are encoded in a phrase lattice. The number
of candidate translations thus taken into account
increases by several orders of magnitudes compared
to N-best MERT. Lattice MERT is shown to yield
significantly faster convergence rates while it ex-
plores a much larger space of candidate translations
which is exponential in the lattice size. Despite
this vast search space, we show that the suggested
algorithm is always efficient in both running time
and memory.
The remainder of this paper is organized as fol-
lows. Section 2 briefly reviews N-best MERT and
introduces some basic concepts that are used in
order to develop the line optimization algorithm for
phrase lattices in Section 3. Section 4 presents an
upper bound on the complexity of the unsmoothed
error surface for the translation hypotheses repre-
sented in a phrase lattice. This upper bound is
used to prove the space and runtime efficiency of
the suggested algorithm. Section 5 lists some best
practices for MERT. Section 6 discusses related
work. Section 7 reports on experiments conducted
on the NIST 2008 translation tasks. The paper
concludes with a summary in Section 8.
2 Minimum
Error Rate Training on
N-best Lists
The goal of MERT is to find a weights set that
minimizes the unsmoothed error count on a rep-
resentative training corpus (cf. Eq. (3)). This
can be accomplished through a sequence of line
minimizations along some vector directions D8dM1 D9.
Starting from an initial point λM1 , computing the
most probable sentence hypothesis out of a set of K
candidate translations Cs AG D8e1,...,eKD9 along the
line λM1 A0 γ A4 dM1 results in the following optimiza-
tion problem (Och, 2003):
ˆe
D4fs;γD5 AG argmax
eC8Cs
AX
D4λ
M
1 A0
γ A4 d
M
1 D5
C2
A4 hM1 D4e,fsD5
B5
AG argmax
eC8Cs
AY
F4
m
λmhmD4e,fsD5
D0D3D3D3D3D3D3D3D3D1D3D3D3D3D3D3D3D3D2
AGaD4e,fsD5
A0 γA4
F4
m
dmhmD4e,fsD5
D0D3D3D3D3D3D3D3D3D1D3D3D3D3D3D3D3D3D2
AGbD4e,fsD5
B6
AG argmax
eC8Cs
AWa
D4e,fsD5 A0 γ A4 bD4e,fsD5
D0D3D3D3D3D3D3D3D3D3D3D3D1D3D3D3D3D3D3D3D3D3D3D3D2
D4A6D5
B4 (5)
Hence, the total score D4A6D5 for any candidate trans-
lation corresponds to a line in the plane with γ as
the independent variable. For any particular choice
of γ, the decoder seeks that translation which yields
the largest score and therefore corresponds to the
topmost line segment.
Overall, the candidate repository Cs defines K
lines where each line may be divided into at most
K line segments due to possible intersections with
the other K A1 1 lines. The sequence of the topmost
line segments constitute the upper envelope which
is the pointwise maximum over all lines induced by
Cs. The upper envelope is a convex hull and can
be inscribed with a convex polygon whose edges
are the segments of a piecewise linear function in γ
(Papineni, 1999; Och, 2003):
EnvD4fD5 AG max
eC8C
AWa
D4e,fD5 A0 γ A4 bD4e,fD5 : γ C8 RB4 (6)
726
Score
γ
Error
count
γ
0
0
e1
e2
e5
e6
e8
e1e
2
e3
e4
e5e6e
7
e8
Figure 1: The upper envelope (bold, red curve) for a set
of lines is the convex hull which consists of the topmost
line segments. Each line corresponds to a candidate
translation and is thus related to a certain error count.
Envelopes can efficiently be computed with Algorithm 1.
The importance of the upper envelope is that it pro-
vides a compact encoding of all possible outcomes
that a rescoring of Cs may yield if the parameter
set λM1 is moved along the chosen direction. Once
the upper envelope has been determined, we can
project its constituent line segments onto the error
counts of the corresponding candidate translations
(cf. Figure 1). This projection is independent of
how the envelope is generated and can therefore be
applied to any set of line segments1.
An effective means to compute the upper enve-
lope is a sweep line algorithm which is often used in
computational geometry to determine the intersec-
tion points of a sequence of lines or line segments
(Bentley and Ottmann, 1979). The idea is to shift
(“sweep”) a vertical ray from A1BK to A0BK over the
plane while keeping track of those points where two
or more lines intersect. Since the upper envelope
is fully specified by the topmost line segments, it
suffices to store the following components for each
line object ℓ: the x-intercept ℓ.x with the left-
adjacent line, the slope ℓ.m, and the y-intercept ℓ.y;
a fourth component, ℓ.t, is used to store the candi-
date translation. Algorithm 1 shows the pseudo code
for a sweep line algorithm which reduces an input
array a[0..K-1] consisting of the K line objects
of the candidate repository Cs to its upper envelope.
By construction, the upper envelope consists of at
most K line segments. The endpoints of each line
1 For
lattice MERT, it will therefore suffice to find an
efficient way to compute the upper envelope over all translations
that are encoded in a phrase graph.
Algorithm 1 SweepLine
input: array a[0..K-1] containing lines
output: upper envelope of a
sort(a:m);
j = 0; K = size(a);
for (i = 0; i < K; ++i) {
ℓ = a[i];
ℓ.x = -BK;
if (0 < j) {
if (a[j-1].m == ℓ.m) {
if (ℓ.y <= a[j-1].y) continue;
--j;
}
while (0 < j) {
ℓ.x = (ℓ.y a[j-1].y)/
(a[j-1].m ℓ.m);
if (a[j-1].x < ℓ.x) break;
--j;
}
if (0 == j) ℓ.x = -BK;
a[j++] = ℓ;
} else a[j++] = ℓ;
}
a.resize(j);
return a;
segment define the interval boundaries at which the
decision made by the decoder will change. Hence,
as γ increases from A1BK to A0BK, we will see that
the most probable translation hypothesis will change
whenever γ passes an intersection point.
Let γfs1 EG γfs2 EG...EG γfsNs denote the sequence of
interval boundaries and let ∆Efs1 ,∆Efs2 ,...,∆EfsNs
denote the corresponding sequence of changes in the
error count where ∆Efsn is the amount by which the
error count will change if γ is moved from a point in
D6γfsn
A11,γfsn D5 to a point in D6γfsn ,γ
fs
nA01D5. Both sequencestogether provide an exhaustive representation of the
unsmoothed error surface for the sentence fs along
the line λM1 A0 γ A4 dM1 . The error surface for the
whole training corpus is obtained by merging the
interval boundaries (and their corresponding error
counts) over all sentences in the training corpus.
The optimal γ can then be found by traversing the
merged error surface and choosing a point from the
interval where the total error reaches its minimum.
After the parameter update, ˆλM1 AG λM1 A0γoptA4dM1 ,
the decoder may find new translation hypotheses
which are merged into the candidate repositories if
they are ranked among the top N candidates. The
relation K AG N holds therefore only in the first
iteration. From the second iteration on, K is usually
larger than N. The sequence of line optimizations
and decodings is repeated until (1) the candidate
repositories remain unchanged and (2) γopt AG 0.
727
3 Minimum
Error Rate Training on
Lattices
In this section, the algorithm for computing the
upper envelope on N-best lists is extended to phrase
lattices. For a description on how to generate
lattices, see (Ueffing et al., 2002).
Formally, a phrase lattice for a source sentence f
is defined as a connected, directed acyclic graph
Gf AG D4Vf,EfD5 with vertice set Vf, unique source and
sink nodes s,t C8 Vf, and a set of arcs Ef DK Vf A2Vf.
Each arc is labeled with a phrase ϕij AG ei1,...,eij
and the (local) feature function values hM1 D4ϕij,fD5.
A path π AG D4v0,ε0,v1,ε1,...,εn
A11,vnD5 in Gf (with
εi C8 Ef and vi,vi
A01 C8 Vf as the tail and head of
εi, 0 EK i EG n) defines a partial translation epi of f
which is the concatenation of all phrases along this
path. The corresponding feature function values are
obtained by summing over the arc-specific feature
function values:
π : ADv
0
ϕ0,1
G5G5G5G5G5G5FT
hM1 D4ϕ0,1,fD5
ADv
1
ϕ1,2
G5G5G5G5G5G5FT
hM1 D4ϕ1,2,fD5
A4A4A4
ϕn
A11,n
G5G5G5G5G5G5G5G5FT
hM1 D4ϕn
A11,n,fD5
ADv
n
epi AG ©
i,j :v
iFTvjC8pi
ϕij AG ϕ0,1 A5 ...A5ϕn
A11,n
hM1 D4epi,fD5 AG
F4
i,j :v
iFTvjC8pi
hM1 D4ϕij,fD5
In the following, we use the notation inD4vD5 and outD4vD5
to refer to the set of incoming and outgoing arcs for
a node v C8 Vf. Similarly, headD4εD5 and tailD4εD5 denote
the head and tail of ε C8 Ef.
To develop the algorithm for computing the up-
per envelope of all translation hypotheses that are
encoded in a phrase lattice, we first consider a node
v C8 Vf with some incoming and outgoing arcs:
v
vBDε
Each path that starts at the source node s and ends in
v defines a partial translation hypothesis which can
be represented as a line (cf. Eq. (5)). We now assume
that the upper envelope for these partial translation
hypotheses is known. The lines that constitute this
envelope shall be denoted by f1,...,fN. Next we
consider continuations of these partial translation
candidates by following one of the outgoing arcs
Algorithm 2 Lattice Envelope
input: a phrase lattice Gf AG D4Vf,EfD5
output: upper envelope of Gf
a = C0;
L = C0;
TopSort(Gf);
for v = s to t do {
a = SweepLine( E4
εC8inD4vD5
L[ε]);
foreach (ε C8 inD4vD5)
L.delete(ε);
foreach (ε C8 outD4vD5) {
L[ε] = a;
for (i = 0; i < a.size(); ++i) {
L[ε][i].m = a[i].m + EWm dmhmD4ε, fD5;
L[ε][i].y = a[i].y + EWm λmhmD4ε, fD5;
L[ε][i].p = a[i].pA5ϕv,head
D4εD5
;
}
}
}
return a;
ε C8 outD4vD5. Each such arc defines another line
denoted by gD4εD5. If we add the slope and y-intercept
of gD4εD5 to each line in the set D8f1,...,fND9, then the
upper envelope will be constituted by segments of
f1 A0 gD4εD5,...,fN A0 gD4εD5. This operation neither
changes the number of line segments nor their rela-
tive order in the envelope, and therefore it preserves
the structure of the convex hull. As a consequence,
we can propagate the resulting envelope over an
outgoing arc ε to a successor node vBD AG headD4εD5.
Other incoming arcs for vBD may be associated with
different upper envelopes, and all that remains is
to merge these envelopes into a single combined
envelope. This is, however, easy to accomplish
since the combined envelope is simply the convex
hull of the union over the line sets which constitute
the individual envelopes. Thus, by merging the
arrays that store the line segments for the incoming
arcs and applying Algorithm 1 to the resulting array
we obtain the combined upper envelope for all
partial translation candidates that are associated with
paths starting at the source node s and ending in
vBD. The correctness of this procedure is based on
the following two observations:
(1) A single translation hypothesis cannot consti-
tute multiple line segments of the same envelope.
This is because translations associated with different
line segments are path-disjoint.
(2) Once a partial translation has been discarded
from an envelope because its associated line ˜f is
completely covered by the topmost line segments
of the convex hull, there is no path continuation
that could bring back ˜f into the upper envelope
728
again. Proof: Suppose that such a continuation
exists, then this continuation can be represented as
a line g, and since ˜f has been discarded from the
envelope, the path associated with g must also be a
valid continuation for the line segments f1,...,fN
that constitute the envelope. Thus it follows that
maxD4f1 A0 g,...,fN A0 gD5 AG maxD4f1,...,fND5 A0 g EG
˜f
A0 g for some γ C8 R. This, however, is in contra-
diction with the premise that ˜f EG maxD4f1,...,fND5
for all γ C8 R.
To keep track of the phrase expansions when
propagating an envelope over an outgoing arc ε C8
tailD4vD5, the phrase label ϕv,head
D4εD5
has to be appended
from the right to all partial translation hypotheses in
the envelope. The complete algorithm then works
as follows: First, all nodes in the phrase lattice
are sorted in topological order. Starting with the
source node, we combine for each node v the upper
envelopes that are associated with v’s incoming arcs
by merging their respective line arrays and reducing
the merged array into a combined upper envelope
using Algorithm 1. The combined envelope is then
propagated over the outgoing arcs by associating
each ε C8 outD4vD5 with a copy of the combined
envelope. This copy is modified by adding the
parameters (slope and y-intercept) of the line gD4εD5
to the envelope’s constituent line segments. The
envelopes of the incoming arcs are no longer needed
and can be deleted in order to release memory. The
envelope computed at the sink node is by construc-
tion the convex hull over all translation hypotheses
represented in the lattice, and it compactly encodes
those candidates which maximize the decision rule
Eq. (1) for any point along the line λM1 A0 γ A4 dM1 .
Algorithm 2 shows the pseudo code. Note that
the component ℓ.x does not change and therefore
requires no update.
It remains to verify that the suggested algorithm
is efficient in both running time and memory. For
this purpose, we first analyze the complexity of
Algorithm 1 and derive from it the running time of
Algorithm 2.
After sorting, each line object in Algorithm 1 is
visited at most three times. The first time is when
it is picked by the outer loop. The second time is
when it either gets discarded or when it terminates
the inner loop. Whenever a line object is visited
for the third time, it is irrevocably removed from
the envelope. The runtime complexity is therefore
dominated by the initial sorting and amounts to
OD4K logKD5
Topological sort on a phrase lattice G AG D4V,ED5
can be performed in time ΘD4DGVDG A0 DGEDGD5. As will be
shown in Section 4, the size of the upper envelope
for G can never exceed the size of the arc set E. The
same holds for any subgraph G
D6s,vD7
of G which is
induced by the paths that connect the source node
s with v C8 V. Since the envelopes propagated from
the source to the sink node can only increase linearly
in the number of previously processed arcs, the total
running time amounts to a worst case complexity of
OD4DGVDGA4 DGEDGlogDGEDGD5.
4 Upper
Bound for Size of Envelopes
The memory efficiency of the suggested algorithm
results from the following theorem which provides
a novel upper bound for the number of cost mini-
mizing paths in a directed acyclic graph with arc-
specific affine cost functions. The bound is not only
meaningful for proving the space efficiency of lattice
MERT, but it also provides deeper insight into the
structure and complexity of the unsmoothed error
surface induced by log-linear models. Since we are
examining a special class of shortest paths problems,
we will invert the sign of each local feature function
value in order to turn the feature scores into cor-
responding costs. Hence, the objective of finding
the best translation hypotheses in a phrase lattice
becomes the problem of finding all cost-minimizing
paths in a graph with affine cost functions.
Theorem: Let G AG D4V,ED5 be a connected directed
acyclic graph with vertex set V, unique source and
sink nodes s,t C8 V, and an arc set E DK V A2 V in
which each arc ε C8 E is associated with an affine
cost function cεD4γD5 AG aε A4 γ A0 bε, aε,bε C8 R.
Counting ties only once, the cardinality of the union
over the sets of all cost-minimizing paths for all
γ C8 R is then upper-bounded by DGEDG:
A7
A7
A7
EK
γC8R
AWπ : π
AG πD4G;γD5 is a cost-minimizing
path in G given γB4
A7
A7
A7
EK DGEDG (7)
Proof: The proposition holds for the empty graph
as well as for the case that V AG D8s,tD9 with all
arcs ε C8 E joining the source and sink node. Let
G therefore be a larger graph. Then we perform
an s-t cut and split G into two subgraphs G1 (left
subgraph) and G2 (right subgraph). Arcs spanning
the section boundary are duplicated (with the costs
of the copied arcs in G2 being set to zero) and
connected with a newly added head or tail node:
G: G G1 2c1
c3
c2
c4
c1
c3
c4
c2
0: :
729
The zero-cost arcs in G2 that emerged from the
duplication process are contracted, which can be
done without loss of generality because zero-cost
arcs do not affect the total costs of paths in the
lattice. The contraction essentially amounts to a
removal of arcs and is required in order to ensure
that the sum of edges in both subgraphs does not
exceed the number of edges in G. All nodes in
G1 with out-degree zero are then combined into a
single sink node t1. Similarly, nodes in G2 whose
in-degree is zero are combined into a single source
node s2. Let N1 and N2 denote the number of
arcs in G1 and G2, respectively. By construction,
N1 A0 N2 AG DGEDG. Both subgraphs are smaller
than G and thus, due to the induction hypothesis,
their lower envelopes consist of at most N1 and N2
line segments, respectively. We further notice that
either envelope is a convex hull whose constituent
line segments inscribe a convex polygon, in the
following denoted by P1 and P2. Now, we combine
both subgraphs into a single graph GBD by merging
the sink node t1 in G1 with the source node s2
in G2. The merged node is an articulation point
whose removal would disconnect both subgraphs,
and hence, all paths in GBD that start at the source
node s and stop in the sink node t lead through this
articulation point. The graph GBD has at least as many
cost minimizing paths as G, although these paths
as well as their associated costs might be different
from those in G. The additivity of the cost function
and the articulation point allow us to split the costs
for any path from s to t into two portions: the first
portion can be attributed to G1 and must be a line
inside P1; the remainder can be attributed to G2
and must therefore be a line inside P2. Hence, the
total costs for any path in GBD can be bounded by
the convex hull of the superposition of P1 and P2.
This convex hull is again a convex polygon which
consists of at most N1 A0 N2 edges, and therefore,
the number of cost minimizing paths in GBD (and thus
also in G) is upper bounded by N1 A0 N2. D0
Corollary: The upper envelope for a phrase lattice
Gf AG D4Vf,EfD5 consists of at most DGEfDG line segments.
This bound can even be refined and one obtains
(proof omitted) DGEDGA1DGVDGA02. Both bounds are tight.
This result may seem somewhat surprising as it
states that, independent of the choice of the direction
along which the line optimization is performed, the
structure of the error surface is far less complex
than one might expect based on the huge number
of alternative translation candidates that are rep-
resented in the lattice and thus contribute to the
error surface. In fact, this result is a consequence
of using a log-linear model which constrains how
costs (or scores, respectively) can evolve due to
hypothesis expansion. If instead quadratic cost
functions were used, the size of the envelopes could
not be limited in the same way. The above theorem
does not, however, provide any additional guidance
that would help to choose more promising directions
in the line optimization algorithm to find better local
optima. To alleviate this problem, the following
section lists some best practices that we found to be
useful in the context of MERT.
5 Practical
Aspects
This section addresses some techniques that we
found to be beneficial in order to improve the
performance of MERT.
(1) Random Starting Points: To prevent the line
optimization algorithm from stopping in a poor local
optimum, MERT explores additional starting points
that are randomly chosen by sampling the parameter
space.
(2) Constrained Optimization: This technique
allows for limiting the range of some or all feature
function weights by defining weights restrictions.
The weight restriction for a feature function hm is
specified as an interval Rm AG D6lm,rmD7, lm,rm C8
RCHD8A1BK,A0BKD9 which defines the admissible region
from which the feature function weight λm can be
chosen. If the line optimization is performed under
the presence of weights restrictions, γ needs to be
chosen such that the following constraint holds:
lM1 EK λM1 A0 γ A4 dM1 EK rM1 (8)
(3) Weight Priors: Weight priors give a small (pos-
itive or negative) boost ω on the objective function
if the new weight is chosen such that it matches a
certain target value λA6m:
γopt AG argminγ
AX
F4
s
EA0rs,ˆeD4fs;γD5
A8
A0
F4
m
δD4λm A0 γ A4 dm,λA6mD5 A4 ω
B5
(9)
A zero-weights prior (λA6m AG 0) provides a means of
doing feature selection since the weight of a feature
function which is not discriminative will be set to
zero. An initial-weights prior (λA6m AG λm) can
be used to confine changes in the parameter update
with the consequence that the new parameter may
be closer to the initial weights set. Initial weights
priors are useful in cases where the starting weights
already yield a decent baseline.
730
(4) Interval Merging: The interval D6γfsi ,γfsi
A01D5 ofa translation hypothesis can be merged with the
interval D6γfsi
A11,γ
fs
i D5 of its left-adjacent translationhypothesis if the corresponding change in the error
count ∆Efsi AG 0. The resulting interval D6γfsi
A11,γ
fs
iA01D5has a larger range, and the choice of γ
opt may be
more reliable.
(5) Random Directions: If the directions chosen in
the line optimization algorithm are the coordinate
axes of the M-dimensional parameter space, each
iteration will result in the update of a single feature
function only. While this update scheme provides
a ranking of the feature functions according to their
discriminative power (each iteration picks the fea-
ture function for which changing the corresponding
weight yields the highest gain), it does not take
possible correlations between the feature functions
into account. As a consequence, the optimization
procedure may stop in a poor local optimum. On
the other hand, it is difficult to compute a direction
that decorrelates two or more correlated feature
functions. This problem can be alleviated by ex-
ploring a large number of random directions which
update many feature weights simultaneously. The
random directions are chosen as the lines which
connect some randomly distributed points on the
surface of an M-dimensional hypersphere with the
hypersphere’s center. The center of the hypersphere
is defined as the initial parameter set.
6 Related
Work
As suggested in (Och, 2003), an alternative method
for the optimization of the unsmoothed error count is
Powell’s algorithm combined with a grid-based line
optimization (Press et al., 2007, p. 509). In (Zens
et al., 2007), the MERT criterion is optimized on
N-best lists using the Downhill Simplex algorithm
(Press et al., 2007, p. 503). The optimization proce-
dure allows for optimizing other objective function
as, e.g., the expected BLEU score. A weakness
of the Downhill Simplex algorithm is, however, its
decreasing robustness for optimization problems in
more than 10 dimensions. A different approach
to minimize the expected BLEU score is suggested
in (Smith and Eisner, 2006) who use deterministic
annealing to gradually turn the objective function
from a convex entropy surface into the more com-
plex risk surface. A large variety of different search
strategies for MERT are investigated in (Cer et al.,
2008), which provides many fruitful insights into
the optimization process. In (Duh and Kirchhoff,
2008), MERT is used to boost the BLEU score on
Table 1: Corpus statistics for three text translation sets:
Arabic-to-English (aren), Chinese-to-English (zhen),
and English-to-Chinese (enzh). Development and test
data are compiled from evaluation data used in past
NIST Machine Translation Evaluations.
data set collection # of sentences
aren zhen enzh
dev1 nist02 1043 878 –
dev2 nist04 1353 1788 –
blind nist08 1360 1357 1859
N-best re-ranking tasks. The incorporation of a
large number of sparse feature functions is described
in (Watanabe et al., 2007). The paper investigates a
perceptron-like online large-margin training for sta-
tistical machine translation. The described approach
is reported to yield significant improvements on top
of a baseline system which employs a small number
of feature functions whose weights are optimized
under the MERT criterion. A study which is comple-
mentary to the upper bound on the size of envelopes
derived in Section 4 is provided in (Elizalde and
Woods, 2006) which shows that the number of
inference functions of any graphical model as, for
instance, Bayesian networks and Markov random
fields is polynomial in the size of the model if the
number of parameters is fixed.
7 Experiments
Experiments were conducted on the NIST 2008
translation tasks under the conditions of the con-
strained data track for the language pairs Arabic-
to-English (aren), English-to-Chinese (enzh), and
Chinese-to-English (zhen). The development cor-
pora were compiled from test data used in the
2002 and 2004 NIST evaluations. Each corpus set
provides 4 reference translations per source sen-
tence. Table 1 summarizes some corpus statistics.
Table 2: BLEU score results on the NIST-08 test set
obtained after 25 iterations using N-best MERT or 5
iterations using lattice MERT, respectively.
dev1+dev2 blind
task loss N-best lattice N-best lattice
aren MBR 56.6 57.4 42.9 43.9
0-1 56.7 57.4 42.8 43.7
enzh MBR 39.7 39.6 36.5 38.8
0-1 40.4 40.5 35.1 37.6
zhen MBR 39.5 39.7 27.5 28.2
0-1 39.6 39.6 27.0 27.6
731
 35.5
 36
 36.5
 37
 37.5
 38
 38.5
 39
 39.5
 40
 0  5  10  15  20  25
BLEU[%]
iteration
lattice MERT
N-best MERT
 5
 15
 25
 35
 45
 0  5  10  15  20  25
Figure 2: BLEU scores for N-best MERT and lattice
MERT after each decoding step on the zhen-dev1 corpus.
The grey shaded subfigure shows the complete graph
including the bottom part for N-best MERT.
Translation results were evaluated using the mixed-
case BLEU score metric in the implementation as
suggested by (Papineni et al., 2001).
Translation results were produced with a state-of-
the-art phrase-based SMT system which uses EM-
trained word alignment models (IBM1, HMM) and
a 5-gram language model built from the Web-1T
collection2. Translation hypotheses produced on the
blind test data were reranked using the Minimum-
Bayes Risk (MBR) decision rule (Kumar and Byrne,
2004; Tromble et al., 2008). Each system uses a log-
linear combination of 20 to 30 feature functions.
In a first experiment, we investigated the conver-
gence speed of lattice MERT and N-best MERT.
2http://www.ldc.upenn.edu, catalog entry: LDC2006T13
 35.6
 35.8
 36
 36.2
 36.4
 36.6
 36.8
 37
-15 -10 -5  0  5  10  15
BLEU[%]
γ
lattice
50-best
 36.28
 36.3
 36.32
 36.34
-0.2 -0.1  0  0.1  0.2
 35
 35.5
 36
 36.5
 37
-40 -20  0  20  40
Figure 3: Error surface of the phrase penalty feature after
the first iteration on the zhen-dev1 corpus.
 0  1  2  3  4  5
 35.5
 36
 36.5
 37
 37.5
 38
 38.5
 39
 39.5
 40
BLEU[%]
iteration
lattice MERT: 1000 directions
1 direction
Figure 4: BLEU scores on the zhen-dev1 corpus for
lattice MERT with additional directions.
Figure 2 shows the evolution of the BLEU score
in the course of the iteration index on the zhen-
dev1 corpus for either method. In each iteration,
the training procedure translates the development
corpus using the most recent weights set and merges
the top ranked candidate translations (either repre-
sented as phrase lattices or N-best lists) into the
candidate repositories before the line optimization
is performed. For N-best MERT, we used N AG 50
which yielded the best results. In contrast to lattice
MERT, N-best MERT optimizes all dimensions in
each iteration and, in addition, it also explores a
large number of random starting points before it
re-decodes and expands the hypothesis set. As is
typical for N-best MERT, the first iteration causes
a dramatic performance loss caused by overadapting
the candidate repositories, which amounts to more
than 27.3 BLEU points. Although this performance
loss is recouped after the 5th iteration, the initial
decline makes the line optimization under N-best
MERT more fragile since the optimum found at the
end of the training procedure is affected by the initial
performance drop rather than by the choice of the
initial start weights. Lattice MERT on the other hand
results in a significantly faster convergence speed
and reaches its optimum already in the 5th iteration.
For lattice MERT, we used a graph density of 40
arcs per phrase which corresponds to an N-best size
of more than two octillion D42 A4 1027D5 entries. This
huge number of alternative candidate translations
makes updating the weights under lattice MERT
more reliable and robust and, compared to N-best
MERT, it becomes less likely that the same feature
weight needs to be picked again and adjusted in
subsequent iterations. Figure 4 shows the evolution
of the BLEU score on the zhen-dev1 corpus using
732
Table 3: BLEU score results on the NIST-08 tests set
obtained after 5 iterations using lattice MERT with
different numbers of random directions in addition to the
optimization along the coordinate axes.
# random dev1+dev2 blind
task directions 0-1 MBR 0-1 MBR
aren – 57.4 57.4 43.7 43.9
1000 57.6 57.7 43.9 44.5
zhen – 39.6 39.7 27.6 28.2
500 39.5 39.9 27.9 28.3
lattice MERT with 5 weights updates per iteration.
The performance drop in iteration 1 is also attributed
to overfitting the candidate repository. The decline
of less than 0.5% in terms of BLEU is, however,
almost negligible compared to the performance drop
of more than 27% in case of N-best MERT. The
vast number of alternative translation hypotheses
represented in a lattice also increases the number
of phase transitions in the error surface, and thus
prevents MERT from selecting a low performing
feature weights set at early stages in the optimization
procedure. This is illustrated in Figure 3, where
lattice MERT and N-best MERT find different op-
tima for the weight of the phrase penalty feature
function after the first iteration. Table 2 shows the
BLEU score results on the NIST 2008 blind test
using the combined dev1+dev2 corpus as training
data. While only the aren task shows improvements
on the development data, lattice MERT provides
consistent gains over N-best MERT on all three
blind test sets. The reduced performance for N-best
MERT is a consequence of the performance drop in
the first iteration which causes the final weights to
be far off from the initial parameter set. This can
impair the ability of N-best MERT to generalize to
unseen data if the initial weights are already capable
of producing a decent baseline. Lattice MERT on
the other hand can produce weights sets which are
closer to the initial weights and thus more likely to
retain the ability to generalize to unseen data. It
could therefore be worthwhile to investigate whether
a more elaborated version of an initial-weights prior
allows for alleviating this effect in case of N-
best MERT. Table 3 shows the effect of optimizing
the feature function weights along some randomly
chosen directions in addition to the coordinate axes.
The different local optima found on the development
set by using random directions result in additional
gains on the blind test sets and range from 0.1% to
0.6% absolute in terms of BLEU.
8 Summary
We presented a novel algorithm that allows for
efficiently constructing and representing the un-
smoothed error surface over all sentence hypotheses
that are represented in a phrase lattice. The proposed
algorithm was used to train the feature function
weights of a log-linear model for a statistical ma-
chine translation system under the Minimum Error
Rate Training (MERT) criterion. Lattice MERT was
shown analytically and experimentally to be supe-
rior over N-best MERT, resulting in significantly
faster convergence speed and a reduced number of
decoding steps. While the approach was used to
optimize the model parameters of a single machine
translation system, there are many other applications
in which this framework can be useful, too. One
possible usecase is the computation of consensus
translations from the outputs of multiple machine
translation systems where this framework allows us
to estimate the system prior weights directly on con-
fusion networks (Rosti et al., 2007; Macherey and
Och, 2007). It is also straightforward to extend the
suggested method to hypergraphs and forests as they
are used, e.g., in hierarchical and syntax-augmented
systems (Chiang, 2005; Zollmann and Venugopal,
2006). Our future work will therefore focus on how
much system combination and syntax-augmented
machine translation can benefit from lattice MERT
and to what extent feature function weights can
robustly be estimated using the suggested method.
References
J. L. Bentley and T. A. Ottmann. 1979. Algorithms for
reporting and counting geometric intersections. IEEE
Trans. on Computers, C-28(9):643–647.
D. Cer, D. Jurafsky, and C. D. Manning. 2008. Regular-
ization and Search for Minimum Error Rate Training.
In Proceedings of the Third Workshop on Statistical
Machine Translation, 46th Annual Meeting of the
Association of Computational Linguistics: Human
Language Technologies (ACL-2008 HLT), pages 26–
34, Columbus, OH, USA, June.
D. Chiang. 2005. A Hierarchical Phrase-based Model
for Statistical Machine Translation. In ACL-2005,
pages 263–270, Ann Arbor, MI, USA, June.
K. Duh and K. Kirchhoff. 2008. Beyond Log-Linear
Models: Boosted Minimum Error Rate Training for
N-best Re-ranking. In Proceedings of the Third
Workshop on Statistical Machine Translation, 46th
Annual Meeting of the Association of Computational
Linguistics: Human Language Technologies (ACL-
2008 HLT), pages 37–40, Columbus, OH, USA, June.
733
S. Elizalde and K. Woods. 2006. Bounds on the Number
of Inference Functions of a Graphical Model, October.
arXiv:math/0610233v1.
S. Kumar and W. Byrne. 2004. Minimum Bayes-
Risk Decoding for Statistical Machine Translation.
In Proc. HLT-NAACL, pages 196–176, Boston, MA,
USA, May.
W. Macherey and F. J. Och. 2007. An Empirical Study
on Computing Consensus Translations from Multiple
Machine Translation Systems. In Conference on
Empirical Methods in Natural Language Processing
(EMNLP), pages 986–995, Prague, Czech Republic,
June.
F. J. Och. 2003. Minimum Error Rate Training in Statis-
tical Machine Translation. In 41st Annual Meeting of
the Association for Computational Linguistics (ACL),
pages 160–167, Sapporo, Japan, July.
K. Papineni, S. Roukos, T. Ward, and W. Zhu.
2001. BLEU: a Method for Automatic Evaluation
of Machine Translation. Technical Report RC22176
(W0109-022), IBM Research Division, Thomas J.
Watson Research Center, Yorktown Heights, NY,
USA.
K. A. Papineni. 1999. Discriminative training via
linear programming. In IEEE Int. Conf. on Acoustics,
Speech, and Signal Processing, volume 2, pages 561–
564, Phoenix, AZ, March.
W. H. Press, S. A. Teukolsky, W. T. Vetterling, and B. P.
Flannery. 2007. Numerical Recipes: The Art of
Scientific Computing. Cambridge University Press,
Cambridge, UK, third edition.
A. V. Rosti, N. F. Ayan, B. Xiang, S. Matsoukas,
R. Schwartz, and B. Dorr. 2007. Combining outputs
from multiple machine translation systems. In Human
Language Technologies 2007: The Conference of
the North American Chapter of the Association for
Computational Linguistics; Proceedings of the Main
Conference, pages 228–235, Rochester, New York,
April. Association for Computational Linguistics.
D. A. Smith and J. Eisner. 2006. Minimum Risk
Annealing for Training Log-linear Models. In 21st
International Conference on Computational Linguis-
tics and 44th Annual Meeting of the Association for
Computational Linguistics (Coling/ACL-2006), pages
787–794, Sydney, Australia, July.
R. Tromble, S. Kumar, F. J. Och, and W. Macherey. 2008.
Lattice minimum bayes-risk decoding for statistical
machine translation. In Conference on Empirical
Methods in Natural Language Processing (EMNLP),
page 10, Waikiki, Honolulu, Hawaii, USA, October.
N. Ueffing, F. J. Och, and H. Ney. 2002. Generation
of word graphs in statistical machine translation. In
Proceedings of the 2002 Conference on Empirical
Methods in Natural Language Processing, pages 156–
163, Philadelphia, PE, July.
T. Watanabe, J. Suzuki, H. Tsukada, and H. Isozaki.
2007. Online large-margin training for statistical
machine translation. In Proceedings of the 2007 Joint
Conference on Empirical Methods in Natural Lan-
guage Processing and Computational Natural Lan-
guage Learning (EMNLP-CoNLL), pages 764–773,
Prague, Czech Republic.
R. Zens, S. Hasan, and H. Ney. 2007. A Systematic
Comparison of Training Criteria for Statistical Ma-
chine Translation. In Proceedings of the 2007 Con-
ference on Empirical Methods in Natural Language
Processing, Prague, Czech Republic, June. Associa-
tion for Computational Linguistics.
A. Zollmann and A. Venugopal. 2006. Syntax aug-
mented machine translation via chart parsing. In
NAACL ’06: Proceedings of the 2006 Conference
of the North American Chapter of the Association
for Computational Linguistics on Human Language
Technology, pages 138–141, New York, NY, June.
Association for Computational Linguistics.
734

