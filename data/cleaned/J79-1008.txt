American Joual of Cornputat ienal Linguistics STRING TRANSFORMATIDNS IN THE REQU~T SYSTEM Warren J.
Plath IBM Thomas J.
-Watson Research Center Yorktown Heights Microfiche 8 copyrrght 1974 by the ~ssociation for Computatianal Linguistics ABSTRACT The REQUEST System is an experimental natural language query system based on r.
large transfo~ational grammar of English.
In the original implementation of the system the process of computing the underlying sLructures of input queries involved a sequence of three steps: (1) preprocessing (including dictionary lookup), (2) surface phrase structure parsing, and (3) transformational parsing.
This scheme has since been modified to permit transformational operations not only on the full trees available after completion of surface parsing, but also on the strings of lexical trees which are the output of the preprocessing phase.
Transformational rules of this latter type which are invoded prior to surface parsing, are kno~n as string transformations.
Since they must be defined in the absence of such structural markers as the location of clause boundaries, string transformations aye necessarily relatively local in scope.
Despite this inherent limitation, they have so far proved to be an extremely useful and surprisingly versatile addition to the REQUEST System.
Applications to date have included homograph resolution, analysis of classifier constructions, idiom handling, and the suppression of large numbers of unwanted surface parses.
While by no means a panacea for transformational parsing, the use of string transformations in REQUEST has permitted relatively rapid and painless extension crf the English subset in a number of important areas without corresponding adverse impact on the size of the lexicon, the complexity of.the surface grammar, and the number of surface parses produced.
TA-BLE OF CONTENTS Page 1.
Introdnction 2.
REQUEST System Organlzatlon 3.
Motivation Tor the Introduction of String Transformations 3.1 Some Re levant De sign Principles 3.
2 Early
Experience with the Parser 3.3 Problems of Growth of Coverage 4 The Use of String Transformations in the RFQUEST System 4.
1 Classifier
C onstruci~u~ls 4, 2 Stranded Prepositions 4, 3 Horhograph Resolution 4.
4 Idiom
Proces sing 4.
5 Experiments
in Limited Conjunction Processing 5.
Summary and Conclusions Appendix: Listing of String Transformations References String Transformations in the REQUEST System 1.
IINTRODUC TION The REQUEST (Restricted English Que~tion-answering) Systeln [I, L] is an experimental natural language query system which is being.
developed at the IBM Thomas J, Watson.
Research Center.
The system includes a large transformational grammar, a transformational parser, and a Knuthstyle semantic interpreter.
The grammar and its associated lexicon are broadly oriented towards question-answering on periodic numerical data, they also include material specific to natural English interaction with collections of business statistics, as exemplified by the Fortune 500 The long-range objective of the work on REQUEST is to determine the extent to which mathine -unde rdstandable subsets of English can be developed to provide non-programmers with a convenient and powerful tool for accessing information in formatted data bases without having to 'Learn a formal query language.
In the interest of facilitating effective "under standing" on the part of the system, the semantic scope of the English subset we are currently dealing with is largely restricted to the world of business statistics.
Within that narrow domain of discourse, however, we are attempting to cover a relatively broad fange of syntactic and lexical alternatives, in the hope of permitting future users to employ their normal patterns of written expression -without major adjustment.
The current REQUEST grammar covers a variety of basic English constrtittions in some depth, including whand yes -no questions, relative clauses and clausal negation It is now being extended into such areas as comparison, conjunction and quantification which, while complex, appear to be of central lrnportance in providing a sen~antically powerful subset of English.
2. REQUES 1 System organization The REQUEST System consists of a set of programs written in LlSF 1.
5 together with an associated set of data files containing the Lexicon, grammar, semantic interpretation rules and data base.
The system Tuns interactively on a System/370 Model 158 under VM/370 in 768k bytes of virtual core.
As can be observed from Figure 1, the system cmtain~ two major components, one transformational, the other interpretive.
The transformational component, which serves to analyze input strings and con$pute their underlying structures, consists of two main parts: a preprocessor and a parser.
The interprctive conlponent also Jr -v has two major subcomponents: (i) a semantic interpreter, which translates each underlying structure inta a logical form, i.
e., a forl-nal expre ssion specifying the configuration of executable functions required to access the data base and compute the answer to the corresponding question 9,: * and (ii) a retrieval component which contains the various data-accessing testing, and output formatting functions needed ta evaluate the logical form and conlplete the question-answering proce s; s.
Looking at the tr&nsformational component in somewhat greater detail, the tole of the preprocessor is to partition the input string into words * Implen~entation of the scn~antic interpreter, which operates according to a scheme originally proposed by D.
E. Knuth [3], is due to S.
R. Petrick [l, 4.
51, who has also devised the specific semantic interpretation rules employed in REQUEST.
>:c z: F.
J. Darr~erau is responsible for the design and implementation of the current retrieval component.
I TRANSFOR I,**ON*L I COMPONENT I I INTERPRETIVE I COMPONENT I Input Word L String 1 h * PREPROGESSOR L Executable \ -.-..-.
Code \ (Logical Fdrm) Y, RCTRIEVAL 1 d I I-J Output Figurc 1 Overall System Organization and punctuation marks and then look up each segment in the lexicon, yield ing a preprocessed string of lexica 1 trees which serves as input to the parser.
Multi-word strings that function as Lexical units are identified by a "longest match" lookup in a special phrase lexicon; whl le the lexical trees corresponding to arabic numerals (which may variously represent ca rdinals, ordinals, or year names) are supplied algorithmically rather than by matching against the lexicon.
In cases where there are gaps in the preprocessede string, due to the presence in the input of misspellings, unknown words, ambiguous pronoun references, and the like, the prepro cessor prompts the user to supply the required information.
* Operation of the transformational parser proceeds in three stages: (1 ) The preprocessed string is successively analyzed with respect to thc structural description of each rule in a linearly ordered list of string transformations.
Each successful match against a string transformation leads to modification of one or more of the trees in the preprocessed string through application of the operations specified in the structural change of the rule in question -operations which are drawn from precisely the * The original design and implementation of the parser are due to Petrick 161.
The version currently being used in REQUEST is the result of significant revisions and extensions by M.
Pivovonsky, who (vzith the aid of E.
0. Lippmann) has also been chicfly responsible for implementing the preprocessor.
same inventory of elementary transformatiops that the system makes available for the processing of' full trees by conventional cyclic and postcyc lic transformations, namely: deletion, replacement of a tree by a llst of trees.
Chomsky adjunction, feature insertion, and feature deletion.
(A more detailed account of the nature of string transformations and the motivation fa^ their use in a transformational parser will be presented in the remaining sections of the paper.
) (2) Upon completi~n of the string transformation phase, the resulting transformed preprocessed string--still in the form of a list of trees -is passed to a context-free parser in order to compute the surface structure(s) of the sentence.
(Although one major effect of the employment of string transformations has been a substantial reduction in the number of unwanted surface parses, cases still occur with some frequency where more than one surface parse is produced.
) (3) Finally, the transformational parser processes each surface structure in turn, attempting to map it step by step into a corresponding underlying structure according to the rules of a transformational grammar.
In this process transformational inverses are applied in an order precisely, opposite to that in which their "forward" counterparts would b? invoked ili sentence genenation: inverses of the postcycliC transforma'tions are applied first, starting with the "latest" and ending with the J'earliest"; then the inverses bf the cyclic transforn~ations are applied (also in last-to-first order) working down the tree from the main clause to those that arc most deeply embedded.
To help cnsurc validity of its final output, the parser checks each intermediate output produced by successfsl application of an inverse tdansformation to determine whether or not its constituent structure conforIms fully with the set of branching patterns that can be generated by the current grammar in underlying or intermediate structures.
At the end of each inverse cycle, a similar check is performed to determine whether all structure above the next (lower) level of embedded S s is consistent with the inventory of allowable underlying structure patterns alone.
Failure of either test results in immediate abandonment of the current analysis path.
(A6 described in 121, other.
more stiingcnt teqsts involving the application of corresponding forward transformations can optionally be invoked in orde r to provide a more definitive validation of inverse transf~rnlational derivations.
3. Motivation for the Introduction of String Transfornlations Within the series of major processing steps described in the preceding section, the application of string transfor~nations occurs at a point midway between preprocessing (including lexical lookup) and surface phrase struc ture parsing.
Taken in sequence, these three steps have the cumulative effect of shifting the locus of analysis opexations from the dolnain of word strings to that of full sentence trees, where conventional transfor~mations (and their inverses) can meaningfully be invoked.
Unlike the balance of the transformational parsing process, these three preliminary steps do not seem to bear a, direct correspondence to familiar generative operations.
Nevertheless, their combined effect is to produce the tree or trees which exist at that stage of the "farward" generation where the last postcyclic transformation has applied.
Accordingly, it seems reasonable to view them initially as constituting a kind of "bootstrap" whose function is to set the stage for '-'true1' transformational parsing.
Prior to the introduction of string transformations in the REQUEST System, the entire burden of the "bootstrap''role just outli'ned necessarily fell on the preprocessor and the surface parser.
lMoreover, as will be esplained below, certain basic principles concerning the nature of the system's transformational component -relating to the range of inputs to be accepted and the criteria for satisfactory outputs -had the effect of ensuring that the burden would be a large one.
The full dimensions of the situation began to emerge orice extensive testing of the first sizeable trans formational grammar was underway.
There followed a series of corrective actions, the last and most far-reaching of which was the introduction of string transfornlations.
3. 1 Some Relevant Design Principles In the early design phases of what subsequently became the REQUEST System's transformational grammar, it was decided to adopt a level of underlying structure considerably more abstract than the deep structhre of Chomsky's Aspects [7] a level which, somewhat in the spirit of generative semantics 18.
91, would go a long way towards direct representation of the meanings of sentences.
Eschewing irrelevant details, the essentials of the representation adopted (which bears certain strong resem blances to the predicate calculus) are as follows: Each underlying structure tree represents a proposition (category Sl ) consisting of an underlying predicate (V) and its associated arguments (NP's) inbthat order.
Argument slots are filled either by embedded propositiolls (conlplcnlent Sl'2) or by nominal expressions (MM's ).
A nominal expression direcily donlinates either a NOUN, or a NO14 and an S1 (the relative clause construction).
Each NOUN dominates an INDEX node which is specified as a constant (t CONST) in the case of proper nouns and as a variable (CONST) other wise.
The INDEXes and the terminal nodes they dominate play an inlpor .I.
1tant role in the grammar, including the representation of coreference One major impact which this view of underlying structure had on what the "bootstrap" had to accomplish involved the connection of pepositional phrases to the balance of the surface structure tree.
In underlying structure, the noun phrase corresponding to each surface prepositional phrase would appear as a sp~cific argument in a specific proposition, follawing.
the application of the gcnerativc tra11sfor1natior.l.s svl~osc inverses the parser would cm~ploy, thc resulting prepositional phrase rvould in 1110st cases still be explicitly linked to the clause or clausal remnant derived from that underlying proposition.
Thus, in order to make possible a correct inverse transfermational derivation, the surface parser would have to make all snch linkages explicit.
This requirement represented a significant depar ture from earlier practice in a number of phrase structure parsing systems, notably those employing predictive analysis 10 1 1 1, where the problen~ of connecting prepositional phrases to the correct level of structure was simply ducked by making an arbitrary linkage to the nearest available * Much of the early work on the grammar, in particular the svstem of variables and constant.^, reflects surrrrestions bv Paul Postal.
candidate, therehy avoiding what would inevitably have been a large increase in the nurrlber of unwanted analyses.
(A similar approach has recc~ltly been fbllo\-ved in tl~c ATN parser of Woods Lunar Sciences Naturaf Languagc Information System [I 21, but there the semantic interpreter is made to pick up the slack.
) A second design principle which had a major impact on the ~tlechanisms for computing surface structures from input strings was the alfeady-mentioned goal of providing broad coverage of syntactic alternatives to promote ease of use.
(As should be fairly obvious, expansion of grammatical coverage -even in a restricted domain of discourse -ill general entails not only an incrcase in the size and complexity of lexicon and surface grammar but alsg an increase in the potential for lexical and syntactic ambiguity.
) Two classes of syntactic alternatives whose coverage at the surface syntax level led to specific problems.ultimate1y resolved by the use of string transfornlations were strahded prepositions and clas'sifier constructions.
In both cases the problems stemmed from the introduction of new posslbilitieb for incorrectly connecting a preposition or prepositional phrase to the balance of the surface structure.
Stranded prepositions occur with some f~equency in wh-questions and relative c1auscs.in English often yielding results whose naturalnes s compares favorably with that of thc correspontling non-stra~lcied versions, as in (1 ) (3) below.
Becausc ~f these circumstances, we felt obfiged tu provide far such coxlstructions (1) a.
Whatcompanies didXYZ selloilto? b.
To what companies did XY Z.
sell oil?
[2) a..
What was the city which ABC's headquarters was located in in 1 969? b.
What was the.
city in which ABC's headquarters .was locakd in 19697 (3) a.
What company was Mr.
Jones the president & in 1972 b.
? Of what company was Mr: Jones the president in 19727 even in early versions of our grammar.
The case for including classifier constructions, in which proper nouns are optionally accompanied by a cornman noun designating their semantic class [cf.
*e (a) versi'ons of (4)(7)), did not seem quite as c~mpelling as that for stranded prepositions, since (4) a.
the City of Sheboygan b.
Sheboygan State '(5) a.
the Co-mmonwe'8lth of Massachusetl b.
Massachusetts Company 6 a.
(the) Tentacle Corporation b.
Tentacle (7) a.
the yeay (of) 1965 b.
1965 the versions with classifieas have a formal, slightly pedantic quality that is absent from their classifier-less counterparts.
Nevertheless, there appeared to be no reasonable grounds (such as obscurity, doubtful grammaticality, and the like) for excluding them from the subset.
A third factor affe.cting the performance of the "bootstrap" was the conscious decision to try to get along initially with a shrfac.e parser which would be maximally simple with respect to both its computat-ional mechanism and its surface phrase structure grammar.
In particular, this rneant empiuyment of a context-free parser without eith.er the complications or the benefits af sensitivity to syntactic and semantic Zeatures [I 1, 131.
The hope was that any additional surface parses which resulted from this approach would be effectively filtered out during tfansformational parsing by the various well-formedness checks on inverse derivations discussed at the end of Section 2.
3. 2 Early Experience with the Parser Starting in late 1971, tests began on an inverse transfornlat~onal grammar whose generative counterpart had been developed with the aid of Joyce Friedman's transformational grammar tester [14] . In the interest of debugging the system with as few .unnecessary con~plications as possible, the initial examples were "spoon fed" to the parser using a minimal lexicon and surface grammar.
While revealing no critical problems with the bootstrap, these first trial runs indicated that incorrect surface structures were indeed produced along with the correct ones and tended to give rise to analysis paths which continued for some time before being aborted by well-fornledness tests.
Sentences with ambiguous verb forms were a case in point.
Thus, in the question "What companies are computers made by?
'I the surface parser produced two almost identical structures -the first with "made" taken asea finite verb in the past tense, the second with it taken (correctly) as a past participle.
T.he first analysis initiated a lengthy inverse derivation that was terminated as ill-formed only after the entire postsycle and the first inverse cycle had been traversed, meaning that nearly as much time was spent in pursuing this incorrect path as was required to follow the correct one.
In this and a number of similar cases, however, it was observed that ill-formedness of the surface structure could have readily been detected at 02 near the outset of the transformational parsing process by performing testg employing the pattern-matchin power of transformational rules.
This observation led to the introduction of so-called blocking rules in the transformational grammar, rules which proved to be quite effective in detecting and filtering out ill-formed structures such as the incompatible auxiliarylfinite verb combination in the example just considered, I11 the spring of 1972, the surface grammar was greatly expanded in an attempt ta cover the full range of structures that could be produced by thk set of transformational rules then in use.
At that point, the mmbined effect of the various design decisions affecting surface structures and surface parsing became immediately and painfully evident in the form of a combinatorial explosion: The brief and apparently innocuous question (8) (8) "Is the headquarters of XY% in Buffalo?
I' produced no less than 19 surface parses, a figure which soared to 147 when a third prepositional phrase was introduced by replacing "Buffalo" with the classifier construction "the city of Buffalo" Although a blocking rule for detecting spurious stranded prepositions rather quickly killed off 16 of the 19 analyses in the former case, thereby reduoing the analysis problem to tractable size, the system was unable to cope with the latter situation at all, due to problenls of storage overflow.
Thoughts of what would inevitably happen if we added yet another prep ositional phrase (as in "Was the headquarters of XYZ in the city of Buffalo in 1971?
") made it clear that killing off unwanted surface parses after the fact by means of blocking rules was not enough, measures would have to be adopted which would prevent formation of most such ai~alyses in the first place.
Two corrective steps were taken almost immediatey: (a) coverage of classifier constructions was temporarily dropped, and (b) it was decided to explore whaf could be clone towards eli'n~ination of spurious surface parses through selective refinement of category distinctions in the surface grammar.
In the latter area, it was discovered (not surprisingly) that differences in the surface structure distribution of prepositional phrases, genitive noun phrases, anu other types of noun phrases could be effectively exploited to suppress incorrect parses, as could distributional contrasts between proper nouns ahd common nouns, finite verbs and participles, et~.
(In the case of (8) above, 13 of the original 19 parses were ruled out on the ground that proper,nouns cannot take modifiers, while 3 more analyses (plus 4 of the 13 already eliminated) were excluded oq the basis of distribu tional distinctions between prepositioxlal phrases and other noun phrases.
) In~plen~entation of the refinements in the surface grammar required nmerons part-of-spcech code changes in the lexicon and a substantial increase in the number of rules in the surface grammar.
Beyondthis, the central problem was that the transformational grammar defines a specific chss of surface structures -employing only elements from a fixed set of intermediate syn~bols -as the parses which must be found.
Iri order to meet this requirement, the by now considerably expancicri set of intermediate symbols e.mploycd in the surface grammar had to be rnapped onto the smaller set ~o~rt~patiblc with the transformations.
Thus, for example, PP (prepositional phrase) and NPG (genitive noun phrase) nodes in each surface structure would be replaced by NP nodes before transformational parslng began -lortunately an extremely simple and rapid operation.
(In the most re-cent version of REQUEST, the surface grammar employs a total of 32 temporary node names for this purpose; they are subsequently mapped onto a set of only 9 nodes for purposes of transformational parsing.
3.3 Problems
of Growth of Coverage The various measures just described had the effect of stabilizing the incidence of artificial surface structure ambiguities at a tolerably low level for a pecriod of about a year, during which the transfonmational grammar roughly doubled in size from about 35 rules to over 70 as coverage was cxtcndsd to include such structures as numerical quantifiers, time eosnpounds, and various expressions involving rank ahd ordinality.
The principal costs of ambiguity suppression were felt not in the analysis programs, which required only negligible modification for that purpose, but rather in the surface grammar, which grew much larger and more complex to the point where it became rather difficult to work with.
Since a number of additional extensions of grammatical coverage were under active consideration among them the rest~ration of classifier constructions to the subset -it seemed desirable to seek out some nebw approach to ambiguity suppression which? would not further overburden the surface grammar.
The alternatives originally considered were uniformly unattractive.
In he case of the classifier constructions, one could have achieved the immediate objective by simply loading up the phrase lexicon with an entry for each legitimate pairing of a classifier with a proper noun, thereby achieving a mihor gain in grammatical coverage at the price of more than doubling the size of the lexicon.
Another approach would have involved creating phrasal entries only for the classifiers themselves -e.
g., "the city of", the state of", etc.
-leaving it to special ad hoc routinas at the end of the preprocessor first to check the preprocessed string for the presence of immediately following proper nouns of the corresponding semantic class and then to effect the appropriate amalgamations or deletions.
The second altert~ative was quickly rejected as even more distasteful than tEe first, since despite its relatively small initial :ost, it would, if used at all extensively, have mcant abandonment of an otherwise orderly and perspicuous analysis procedbre.
This train of thought, however, eventually led to the idea of modifying the preprocessed string not by ad hoc subroutines requiring accretions to the program, but hy means of locally defined transformational rules employing the same computational apparatus and notational conventions as the existing forward and inverse transformations.
Within a week of its conception, the idea of a string transformation facility became a reality through some minor modifications to the flow of control of the parser.
% Much of the ease of this transition stemmed from the generality of the original properanalysis mechanism, which was designed to accept a list of trees, rather than a single tree, as it3 input.
4. The Use of String Transformations in the REQUEST System >h Because they apply to strings of unconnected lexical trees, rabher than to full surface trees with their representation of the structure of phrases and clauses, string transformations tend to be relatively local in scope, typically being restricted to constructions with contiguous elements.
Despite this inherent limitation, such rules rapidly found a wide variety of uses within the REQUEST System: Classifier constructions were readily identified md transformed into clas sifierle ss counterparts by a handful of string transformations.
Rules were also written for suppressing incorrect stranded prepositions, resolving homography, and translating certain idioms into a form more manageable for the surface parser.
Finally, ex periments were undertaken to explore the possibility of employing string transformations to deal with a limited but potentially useful range of conjunction construations.
A conlmon thread running through several of these apparently diverse applications of string transformations is the application of what would otherwise have been treated as the inverse of a late postcyclic transformation at a point preceding surface structure parsing in order to achieve a *~t Least initially.
Some string transformations currently in use produce what are in effect partial surface structures as output.
In fact, it is quite pos'siblc that an appropriately chosen cyclically ordered set of string transformations could supplant the surface grammar cntirely, however, such a dcvclopment appears unattractive at this time due to efficiency considerations.
simplification of the surface grammar, a reduction in the number of spurious surface parses,.
or both.
(The benefits of such a reordering sten] in large part from the fact that derived constituedr stfucture patterns provided for at the string transformation level need not be dealt with in the surface grammar, thereby reducing its size, its scope, and its potential for producing iocorrect surfqce parses).
In the case of classifier construc tions (section 4.1) and of certain idioms involving notions of rank (Section 4.
4), existing postcyclic transformations were actually replaced by string transformations; while in the case of stranded preposition prevention (Section 4.
2), a string transformation was made to assume much of the load of an existing postcyclic blocking rule, resulting in a highly beneficial elimination of unwanted surface parses in both instances.
In other situations, such as those involving homograph resolution (Section 4.
3 ) and the treatment of the first group of idiom-processing rules discussed in Section 4.
4, a correspondence of string transformations to locally -defined postcyclic tqansformations, while potentially possible, dl4 not actually exist, since no attempt had been made to cover the constructi~ns 133 question prior to the introduction of string transformations.
4. 1 Classifier Constructions The string transformations relating to classifier constructions are exemplified by-the rule "City, State, Year Classifier ", whose statement is displayed in Figure L using a hybricl tree/llst notation in order to enhance legibility.
Like' all transformations in the REQUEST System, thls rule consists of a list with five main sections: header, structural pattern, c-ondition, structural change, and feature change.
The header, which serves to identify the rule and a number of basic attributes governing its applfcation, is in the form of a list comprising the name, type (FORW, INVDIR, INVINIIIR, STRING, or BLOCK), optionality (OB or OP), and mode (ALL, ANY, ONE, NA, or REANALYZE-) of the transformation.
Thus the rule CSYCLSFR is labeled as a string transformation whose execution is obligatory for all matches that may occur in the list of trees being processed.
The structural pattern (possibly qualified by further constraints expressed in the condition section) defines the domain of applicability of the transformation in the fbrm of a list of pattern elements, each specifying a tree or class of trees.
For a match to occur, it must be possible to partition thc input tree (or list of trees) into a list of non-overlapping, adjacent trees each of which matches the corre sponcling pattern element.
Thus, the structural pattern in Figure 2 indicates that the rule CS'YCLSFR requires that the preprocessed string be partitionable into the following six-segme'nt sequence: (1 ) an arbitrary initial segment (possibly null) designated (X . 1 ), (2) an occurrencb of thc definite article THE, (3) a common NOUN (already represented-in our surface structure as dominating Header: (CSYCLSFR STRING OB ALL) Structural Pattern: ((X.
1) (THE.2) NOUN (OF . 5) ((INDEX . 6) (ORX (t CITY + STATE + YEAR))) l' (INDEX . 4) (CITY . 3) (STATE.
3) Condition: (EQUAL ORX (QUOTE {t (NODENAMEOF 3))) ) Structural Chanec Feature Chanee: NIL Figure 2: The St ring Transformation "City, State, Year Classifier " an underlying predicate (V) and a-n INDEX) which happens to be one of the three classifiers CITY, STATE, 02 YEAR, '(4) an occurrence of the preposition OF: (5) an INDEX bearing one of the feature pairs (+ CITY), (t STATE), or (t YEAR) (the absence of a preceding V node here is suffi cient to guarantee that any matching item will necessarily be an INDEX (t CONST )' i, ee., a proper noun); and (6) an arbitrary (pos slbly null) final segment, designated by (X . 7).
The condition adds 'the further stipu$ lation that the value of the variable ORX be compatible with node 3 in the pattern -i.
e., the proper noun must belong to the semantic class designated by the classifier.
The structural change pf a transformational rule may be stated in one of two wayso fI) If the change is relatively simple fas here) it may conveniently be stated in 5he form of two lists of numerals referring to the correspondingly labelled elements of the structural pattern.
The first list identif2es the elements under conslderatior the second list (whic'h must contain the same number of elements as the first) specifies what (if anything) happens to each of them -replacement, deletion, sister adj-unction tk another element, etc.
In the case of CSYCLS~R, the change specified is the * In addition to providing variables ALPHA, BETA, and GAMMA, ~hich range over thc set d feature values {t 1, 8 the notational system of the REQUEST transformational co~nponent includes the variables ORX, OR^ and ORZ, which range over sets of (feature value, feature name) pairs.
deletion of the trees whbse top nodes arc labelled 2, 3 4, and 5 (including by convention, any higher nodes which dominate only deleted nodes).
Thus the effect of the rule is to eliminate all classifiers of the designated type from the preprocessed string: 12) Alfernatively the struttural change may be expressed as a list of elementary operations, drawn from the set REPLACE, DELETE, LCHOMADJ, RCHOMADJ), and their arguments.
This notation is typically employed when fixed trees are inserted (although the first option may still be taken in such cases) and is obligatory whenever a choice is made among alternative structural changes by evaluating one or more conditional exprkssions.
Had this second option been talcen in the case of the present rule, its structural change would have read: ((DE'LETE 2) (DELETE 3) (DELETE 4) (DELETE 5 j).
The fezture change section of each transformation is always expressed as a ligt of elementary operations which are members of the set {INSERT, DELETE}, together with their associated arguments.
Where no feature change is associated with a rule, as is the case for CSYCLSFR, this final sectiorr of the rule statement is specified as NIL, the eppty dst.
(The structural change and condition sections of transformations can similarly be defined as NIL, clenofing that the tree structure remains unchanged and thatthere are-no extra conditions on ao~licability, respectively.
) Two other classifier-deleting string transformations which are very similar to "C<ty, State, Year Classifier" are the rules "Year Cltissifier'l (Y RCLASFR) and "Company Classifier" (COCLASFR) The former de lctes the lesical trees corresponding to the underlined material in examples like ".
. . the year 1968.
. . ", while the latter does the same I thing in examples such as . . . bhe) American Can Company.
. . . Although the underlyidg predicate COMPANY is the only one specified in the struttural pattern of COCLASFR, the rule actually applies to instances where 11 a form of either of the words company" or"'corpoi.ation" has been uwd in the input string, owing to the fact that the lexicon assigns the same underlying predicate to both in recognition of their synonymity "City State Blockff (CSBLOCK) and "City State" (CITYSTATJ are ttyo rules, related to the preceding ones, which illustrate additional aspects of the system.
Both of these rules follow CSYCLSFR in the list of string kransformations.
As indicated by its header information-, (Figure 3(a)), CSBLOCK is a blocking rule (BLOCK), which entails that it is obligatory (OB) and will result in termination of the current analysis path if the structural pattern matches the preprocessed string at least once.
The structural pattern +s identical to that for CSYCLSFR save for the omission of the alternatives relatigg to €he predicat'e YEAR and the feature (t YEAR) Due to the parallelism of the structural patterns and the relative ordering of thc two rules, it is necessarily the case \hat CSB.LOCK -Header: (CSBLOCK BLOCK OB QNE) Stl'uctural Pattern: ((X.
1 (THE.
2) NOUN (OF . 5) ((INDEX . 6) (x.
7)) /\ (ORX (4CITY + STATE))) V (INDEX . 4) Stru~turat Change: NI L Feature Change: NIL Header: (CLTYSTAT STRING OB ALL) Structural Pattern: Condition: NIL ((X . 1 ) ((INDEX . 6)(t CONST Structural Change: 1 (COMMA.
3) (INDEX(+ CONST Feature Change:, ((INSERT 6 ((t CITYSTATE))) ) (b I (X t CITY )) f t STATE)) (w 2) l NIL (w 4) Figure 3: The Rules CSBLOCK and CITYSTAT will apply if and only if the classifier and the following proper noun do not correspond (any corresponding c lassifiers having already been dcleted by CSYCLSFR).
Thus CSBLOCK has the effect of aborting analyses where a proper name known to the system as designating a state has been classified as denoting a city, or vice-versa The rule CITYSTAT does not refer to classifiers as such, but it does deal with a proper noun construction even more important for our particular subset: the precise identification of a specific city by appending the appropriate state name to the city name.
This construction is essential in distinguishing among such cities as Portland, Maine and Portland, Oregon, not to mention the eighteen varieties of Springfield in the con.I.
.I .,' .,E tinental United States The structural pattern of the rule (Figure 3(b)) specifies a domain consisting of a city name ((INDEX . 6) (+ CONST + CITY)) followed by an optional comma, followed by a state name (INDEX (t CONST *** t STATE)), where the actual city name is a single tree (W . 2) and the I Such a situation would always arise in processing such inputs as City "the 1 1 ol Ncw York", effectively resolving the ambiguity of the State 8 proper noun, if the user were not previously asked by the system to resolve it, as is our current practice, ** Cf, rxerence 15.
*:k# The structural variable W is employed in struct\iral patterns in place of the more usual X whenever one wishes to specify the occurrence of precisely one unknown tree.
state name a single tree (W . 4).
As indicated by the structural change, each match results in the replacement of the tree labelled 2 by a list of trees consisting of itself and the tree labelled 4, thereby pairing the state name with the city name by what amounts to right sister adjunction.
The optional.
comma (COMMA 3) and the state name (W . 4) -plus, by the convention cited earlier, the structure dominating r~ -are deleted.
Finally, the feature (t CITYSTATE) is added to the featurg'list of the node (INDEX . 6), where its presence wilL eventually be noted by the semantic interpreter as rewiring a match on both elements of a (cityname, statename) pair in the data base.
As far as the transformational corriponent is concerned, the net effect of the rulg is,.to make "city, state" constructions pass through both fhe surface parser and the inverse transformatiohs as though they were simple city names, 4.
2 Stranded
Prepositions "Stranded Preposition Prevention" (Figuse 4) is a string transforrnatibn designed to prevent surface structure parses in which non-stranded prepositions are erroneously anaalyzed as stranded ones.
Since most prepasitions, whether stranded or not.
are obligatorily present in surface structures, this rule necessarily reflects an approach very different from the "recognize and delete" strategy employed in the string transformations involving classifiers.
What is done here is to assign new word class codes to those prepositions determined to be non-strandable, and towrite the surface struct'ure rules for the new codes in such a way that they are only allowed to combine with a following noun phrase.
Expressed in ~dinary English, the statement of the rule reads about as follows: "Replace the word class code of each preposition by the cdrresponding code for nonstrandable prepositions except where the preposition immedihtely precedes an auxiliary, a punctuation mark, a verb form, or another ~repn~ition, assign any locative feature associated with the original word class code to the new word class code".
As staicd -and as currently implemented -the rule may well be at once both too weak and too strong, at least in+an absolute sense.
It is probably too weak in that it will fail to label as non-strandable any preposition which immediately precedes a noun phrase beginning with an adjective (VADJ), as, for example; in the sequence "to large companies".
This sort of deficiency is of littLe consequence, however, since the rule will serve its purpose well if it fails to catch an occasional non-strandable preposition, leaving things as ambiguous as before in those cases.
Excessive strength, in the sense of marking some stranded prepsition as non-strandable, is potentially a much more serious flaw, since it precludes obtaining a correct analysis in such instances.
Examples such as (9), where SPRPPREV would fail in just this way by applying Header: (SPRPPREV STRING 033 ALL) Structural Pattern: (PREP . I 'PREPOF Condition: (NOT (ANALYSIS 4 NIL (QUOTE( Structural Chanrre p( (BAUX ) ) ((COMMA 1) ('(DAUX 1) ((PREP')) ((\PUNC T)) ((V)) ((VADJ)) C ( (V'ING 1) ((CONU (2 (COND((ANALYS1S 2 NIL (QUOTE ( ((PREP((+ LOCZ))) ))) ) (REPLACE ( (NSP GI?((+ LOC2))) ) 2)) P (3 (REPLACE (NSPREPOF) 3))) ) I Feature Change: NIL Figure 4: The String Transformation "Stranded Preposition Preventio~ incorrectly, are not particularly difficult to think up..
However, the (9) Was the company XYZ bought ballbearings from a subsidiarv 01 Universal Nut & Bolt? great majority of such examples -including (9) -seem to be irrelevant to the present REQUEST data base.
Thus, while it is clear that our initial rule for stranded preposition prevention does not provide anything approaching a general solution to the problem, it does appear to be working satisfactorily for the moment in eliminating artificial surface ambiguities within a narrow domain of discourse.
4. 3 Homograph Resolution One of the sinlpiest and yet most useful of the 33 strlng transformations inl the current version of REQUEST is the rule "Ordinal Formation" (ORDFORM).
Its function is to match on each string consisting of an arabic numeal immediately followed by any member of the set of English ordinal-forming suffixes {d, nd, rd, st, th) and mark the sequence as an 0-rdinal numeral.
The operation of ORDFORM (Figure 5) is entirely straightforward.
By this poht in the analysis process, all arabicnumerals have already been assigned lexical trees dominated by the node (VADJ (t CARD)) -the combination denoting a cardinal numeral -during the input scanning phase of the preprocessor; while the ordinal-forming suffixes have been assigned .trees dominated by the category ORD during' Header: (ORDFORM STRING OB ALL) Structural Pattern: ((X . 1 ) ((VADJ-.
2) (+ CARD)) (ORD 3) (X . 4)) Condition: NIL Structural Change: ((DELETE 3)) Feature Chtinge: ((DELETE 2 (CARDL) (INSERT 2 ((4ORD))) ) Figure 5: The String Transformation ''Ordinal Formation" the lexical Lookup phase.
ORDFORM simply finds each instance in the preprocessed string where a (VADJ (t CARD)) immediately precedes an ORD, hletes the ORD tree, and changes the feature on the VADJ from (t CARD) to (t O.RD), thereby identifying that item as an ordinal numeral rather than a cardinal.
The approach just described has the advantage of putting an unlimited set of ordinals at the disposal of the user at negligible cost, involving a few very minor additions to the lexicon and none at all to either the surface grammar or the preprocessor.
The alternate of using a postcyclic transformation instead of a string transformation to achieve the same coverage was avoided because it would have imposed the additional requirement that the surface grammar be significantly enlarged through the inclusion of at least three new category symbols (for cardinals, ordinals, and ordinal suffixes) along with a set of context-free rules describing their distribution.
Although identification of ordinal numerals of this type could also have been effected by buildingrthe appropriate tests directly into the preproce*s sor, the Zatte r altcrnatlve would have been much less attractwe than the string transformation approach for at least two reasons: First, it is inhere-ntly pessier to bury suc-11 operations in a special program subroutine than to deal with them as just another transformational rule.
Second, and more important, is the fact that the latter approach makes the system less general and flexible, since material specific to English is directly reflected in the.
structure of the program itself, rather than being confined to the grammar, where it is readily accessible to the liaguist who may wish to modify it -or replaceit by material describing some other natural language.
Another string transformation currently employed to resolve word class homography on the basis of local context is the rule "Cardinal Noun ' (CARDNOUN), which will be discussed only briefly here.
The rule distinguishes instances where a cardinal numeral functions as a proper noun (1 0) from those in which it serves as a nu~nerical quantifier pf a following nominal expression (1 1 ).
It does so by checking the immediatd right-hand cbntext of each (VADJ (+ CARD)) for the presence of (10) Is the number of companies in Chicago greater than 16? (1 1 ) WPat companies employed at least 200, 000 people in 19737 items (such as articles, ausiliarie si punctuation, and verbs ) which are incompatible with the latter possibility, replacing the VADJ structure by a correspondilrg proper noun structure whenever a match occurs.
(CARDNOUN follows ORDFORM in the list of string transformations in order to take advantage of the latter's replacement of certain cardinals by corresponding ordinals.
) 4.
4 Idiorrl
Proces sing By their very definition, idiomatic expressions are items which present problems in grammatical analysis, sernan'tic interpretation, or both.
Although it would be very tempting to exclude all constructions of this sort from the English subset of REQUEST, the currency and naturalness of many idioms is so great that such a prohibition would entail abandonment of our goal of permitting future users to employ their normal patterns of expression.
For idioms such as "make money", (in the.
sense of "be profitable"), where the components are adjacent and the number of paradigmatic variants are few, one possible approach is to deal with the problem by putting appropriate entries in the phrase lexicon.
For example, the entry for "makes money" in our present lexicon treats that combination as aan intransitive verb in the present tense and singular number which dominates the same underlying predicate and has the same selectional features as the adjective "profitable".
Even in such a relatively straightforward case, however, it is not difficult to think of minor extensions, such as the inclusion of negatives ("make no money"), which will at least require another set of pHrasa1 entries.
Moreover, the phrase lexicon approach breaks down con~plctely as soon as one deals with an idiomatic construction :hat includes afl open class as one of its components, producing a situation parallel to that encountered earlier for classifier constructions.
The attempt to provide broad coverage of constructions involving notions of rank and ordinalitty Led to the consideration of a number of comnlon idiomatic j~atterns inc luding arbitrary cardinal or ordinal numer als.
These patterns, three of which are illustrated in (1 2), were eventually dealt with succe s sfully by the development of string trans forma tions designed not-only to cope with ther syntactic peculiarities but to (12) (a) What company nufi?ber 18 in 1972 sales?
(b) What were the 25 1" highest 1 ranking companies with respecbto earnings in 1969 (c) List the top LO companies in 1973 growth rate! set the stage for corfect semantic processing as well.
The nature of these idiom-proces sing transformations is perhaps best illustrated by considering €he rule "Top n" (TOPN), whose statement appears in Figure 6.
The structural pattern of TOPN specities a sequence of elements consisting of an initial arbitrary string of trees (X . 1) followed in order by an occurrence of the definlte article "the" (THE . 2)B the word "topf' (TOP 3), a cardinal numeral ((VAD'J . 4) (+ CARD)), a ndminal expression (NOM . 5), either of the prepositions "in" (IN . 6) or "with respect to".
(WITH RESPECT TO . 6), and a Header: (TOPN STRING OB ALL) Structural pattern: Condition: NIL Structural Change..
(X. 7 1 ((X . 1) (THE . 2) (TOP . 3r ((VADJ . 4) (NOM, 5) (t CARD)) (W.
8) I f (IN.
6) (WITH RESPECT 6.
6) (DELETE 3) (DELETE 4)) (.(REPLACE (5 (VING(+ ADJ (VADJ(+ ADJ PR'E P (VADJ(+ ADJ ) 5) Feature Change: NIL Figlire 6: The Rule !'Topn" it ORD)) + INC)) RANK [NQUOTE 1) THROUGH 8 + ORD)) final arbitrary string of trees (X . 7).
The structudal change includes a replacement and two deletions.
The syntax of a replacement operation is of the form (REPLACE < list of trees > <tree > ) ; its execution results in the replacement of klqe item corresponding to tree by the items corresponding to list of trees.
The replacement operation in TOPN is therefore to be understood as follows: The non~ix~al espFession tree in the input which rnatchcs the pattern element (NOM . 5) is repraced by a list of elements consisting of itself, followed by lexical trees corresponding to (i) the -ing form of I I the verb rank", (ii) the ordinal nunieral "first" (where the (NQUOTE 1 ) notation cayscs the "1" to be interpreted as literal, rather than as .a refrrencc to the pattt\rn clerne~lt ( . 1 I), (iii) the preposition "through", and (iv) the ordinal numeral corresponding to the cardinal which matched ((VADJ . 4) (4CARD)) in the structural pattern.
The two deletion operations remove the lexical trees for the cardinal numeraI and the adjective 'top" from the preprocessed string.
In the case of (IZc), the overall effect of this structural change is to replace the string of lexical trees corresponding to "the top 20 companies" by themstring of trees corresponding to "the companies ranki-ng (1st through 20th".
A subsequent string transformation called "Rank Interval" (RNKINTVI,), operating in a fashion similar to that of "Clty State" cf.
Section 4.
1 ), then transforms the trees corresponding to "1 st through 20th" into a single ordinal numeral free (bearing the feature (; INTERVAL)) which dominates the numerals "'1 'I and "20" As a result of these operations both surface andatransformational parsing of such examples has become completely routine; while their semantic intcrpretafion has required only the addition of a simple mechanism -triggered by the feature (t INTERVAL) --$forbgenerating a de/nse set of integers from its endpoints.
Another group of string transformations involving ran!< are derived from what were originally late ppstcyclic transforlhations.
The three, rules in question -"Eirst Superlative" (FIRSTSUB) "NtV Superlative" (NTHSUPER), and *"Nth Place" (NTHPLACE) -collectively serve to restore the various deletions illustrated in (1 3 ) . railked (thd) fiqst highest -OB (13) > ranked (the) highest ranl.ccd (in) wa sl ( ranked --I was I first second nth (the) * ranked in (the) 9th highest place OP 4 > ranked --was 1 (the nth hignest The prime motivation for shifting these rules from the postcycle to a point preceding surface parsing was that the structure and distribution of the various phrase remnants resulting from the deletions are at best difficult to desdribe within the framework of a context-free phrase struc ture grammar.
Avariety of adhpc mara at us, including specialword class codes for the verb "rank" and for superlative ac ectives, as weell as special phrase names for such sequences as "the t superlatilre" and "ordinal numcfal + superlative", would have to be inttoduced ih order to provide broad coverage witl~out an accompanying ~o~binatorial explosion.
By restoring the deletions before surface parsing, however, such distasteful and complicated measures are entirely avoided, since lexical categories are left unchanged and the surface parser has to do no more than parse an ordinary prepositional phrase in the position following the verb.
4. 5 E~periments in Limited Conjunction Processing -As was mentioned in the introduction to this paper, one of the principal directiohs ih which we are currently seeking to extend the English subset accepted bv the REQUEST System is in the caverage of (coordinate) conjunction constructions.
The fact that the underlying variety and complcxity of these constructions mds to be masked by superficial similarities makes a selective, piecemeal approach to their coverage a generally-dubious move in a system swch as RJjXXJEtST, whose eventual users can hardly be expected to make distinctions that may not be immediately obvious even to a trained linguist.
Despi-te strong reservatiops onthis point, it was decided to employ the string transformation mechanism to deal with an extremely limited range of coniunction constructions on an experimental basis.
The range of constructions chosen was confined to conjoined proper nouns exclusively, subject to the further constraint that all terms of a given conjunction beomembers of the same semantlc class i.
e., for the current data base, either company names, city names, state names or year names.
While undeniably highly limited m scope, this particular inc renlcntal inc rcase in grammatical coverage (if successful) had three distinct merits: (1 ) it app~ared to be compatible with the adjacency constraints of string transformations, .owing to the tendency of proper nouns to take no modifiers, (2) it seemed potentially explainable to a -naive user in simple terms, and (3) it could provide a natural language interface to an existing, but as yet largely unused, capability of the output formatting routines to generate and display tables of value$ containing such information as the earnings of each of a set of companies over a 1erio.d of years.
The approach cmployed in the string transformations for processing :onjoined proper nouns is exemplified by the rule "City.
State, Year, Zompany Conjunction" (CSYCOCNJ ), Whose statement is displayed in Figure 7.
The second and third elements of the structural pattern form a subpattern that is preceded by an astorisk and surrounded by a pair of parentheses.
a his notation identifies the occurrence of a so-called "Kleene star expression", which is interpreted by the transformational parser 3s a pattern clement that is to be matched bv zero or more consecutive occurrences of tree sequences matching con~ponents.
The particular Kleene star expression used here vyill rrlatch a string of aq .I.
lengthv whicy consists entirely of aq alternating seQuence of proper nouns and'commas, provl'ded that all the proper nouns are members of the same * 4: semantic class The pattern elements falowihg the Kleene star expression specify that it must be followed by: ($ another instance of a proper noun of the appropriate class {this will be the initial instance if the null value of the Kleene star expression is the on%y one that matches); Jr 9.
The effcct of the condition, which precludes any match where the lefthand structural variable (X . 1) ends in a sequence of trees satisfying the pattern-of the ~k'enk $'tar expression, is to force a (unique) match of maximum length.
;: * Repeate6baccurrences of ORX in a structural pattern, whether implicit or explicit,, are required to match the same feature, pair.
Header: (CSYCOCNJ STRING OB ALL) Struc tuxal Pattern: (me 1) (* (INDEX (ORX (t CITY + STATE (COMMA 3)) t YEAR +~co))) (INDEX (ORX (t CITY t STATE I t YEAR + GO))) I IAND.
4) (ORR . 5) Condition.
' (COMMA.
3) NIL t ((NOUN 8) (+ SG)) (X . 7)) I EX 9) (ORXI) (NOT (ANALYSIS 1 T (QUOTE (((X))((INDEX (ORX))) ((COMMA))) )) Structural Change: (1234567) (1 0 0 0 0 (2 6) 7) Feature Cha~lgc.
-((CONI) (4 ((INSERT 9 ((t ANDSET))) (INSERT 8 ((-SG))) )) (5 (INSERT 9 ((4ORSET))) 1)) Figure 7: The ~ule "City, State, Year, Company Conjunction" (ii) an optional comma; (iii) all hstance of either of the coordinating conjunctions "and" or "or" I represented internally as ORR, since OR is already used to signal the presence of a disjunctive pattern element to the rule-processing, routine) ; (iv) the final instance of a semantically compatible proper noun, and (v) the usual end variable.
The structural change specifies (1) that the terminal elements of all but the rightmost conjunct (which are collectively associated with the pattern element (W . 2) during the pattern matching phase) are to be sister adjoined to the terminal element of that rightmost conjunct and (2) that the original occurrences of all trees but those corresponding to the end variabbes and the final conjunct are to be deleted.
Conditional on the presence of the conjunction "and" (AND . 4), the feature change adds the feature (+ ANDSET) to the feature list of the surviving INDEX and the feature (SG) to that of the NOUN node immediately above.
(The latter operation automatically re sults in replacement of the original (f SG)).
I£ the conjunction is an "or" (ORR . 5) instead, the feature change merely adds the feature (t ORSET) to the feature list of the INDEX, leaving the number of the NOUN unchanged.
The overall effect of the rule reflects the by now familiar strategy of mapping a structure which would otherwise pose severe problems in surface parsing into a significantly simpler one which will be processed without difficulty by both the surface parser and the transformational parser.
As in the case of CITYSTATE and RNKINTVL, a special featur-e is attached to the node in the output structure that directly dominates two or more terminal symbols as a result of the 5 tructural change of the rule.
In each case, the purpose of the feature is to communicate t~ the semantic interpreter how the elements of the set of terminal symbols are to be treated -as a (city, state) pair, as the endpoints of a dense set of integers, or as the elements of a conjoined set of proper nouns.
The experimental approach to proper naun conjunction just described appeared initially to be a rather effective one.
Examples such as (14) went through the transformational component as sWmoothly as ones like (1 5), (14) How much did GM, Ford, and Chrysler earn in the years from 1967 through 19727 whereupon the interpretive component produced what appeared to be an appropfiate answer -in the case of (14), an earnings table with 18 entries (1 5) How much did Ford earn in 19697 listed by company and by year.
It was not long, however, before consideration of examples such as (16) and (17) revealed that the initial appearance of an.
adequate solution had been highly misleading.
(1 6) Was GM or Ford unprofitable in 19707 (1 7) What were the earnings of the Big Three auto companies lor tne 1 966-1 968 period?
For the former example, at least two readings seem possible: one as a selec,kional question, paraphrased in (18a) (which would preclude a (18) a.
Which auto company was unprofitable in 1970 -GM or Ford7 b.
Was either G.M or Ford unprofitable in 19707 yes ar no answer), the other as a yes-no question (18b), where the conditions for giving a positive answer depend upon the interpretation of the !lor It as inclusive or exclusive.
In the case of (17), there seems to be a series of possible readings, roughly paraphrased .by (19a-d), reflecting ambiguity as to whether what has been requested is earnings information (19) a.
What were the earnings of each of the Big Three auto companies for each of the years 11966-1 968? b.
What were the combined earnings of the Big Three auto companies for each of the years 1966-1 9689 c.
What did the earnings of each of the Blg Three auto companies totak for the 19661968 period? d What did the combined earnings of the Big Three auto companies total for the 19661968 period' (a) presented individually by company and by year, (b) summed over companies hut not over ycars, (c) summed over years but not over companies, or (d) summed over both companies and ycars.
Ambiguities of the types exemplified by (1 6) and (1 7) were found to be quite widespread in the sort of material we are dealing with, occurring in a number of examples such as (14) where their presence was not initially perceived.
Moreover, it was soon rcalizccl that such ambiguities were totally different in character from the types we had previously been most concerned with, since they involved instances of genuine multiple meaning in the language, rather than ambiguities artificially introduced by the inadequacies of a grammatical description or a parsing mechanism.
It was also clear that the underlying structures assigned to these ambiguous examples were seriously deficient, in that they did not indicate the presence of an ambiguous situation, much less what the ambiguous alternatives were.
Further investigation indicdted that the ambiguities encountered were not restricted to conjoined proper nouns, but could also occur in the case of plural noun phrases.
Foraexample, (20) is ambiguous between a reading requesting earnings listed individually by company and a reading (20) What were the 1972 earnings of the companies in Chicago? requesting a combined earnings figure -exactly the same readings which would exist if the phrase "the companies in Chicago" were replaced by the conjoined names of all companies satisfying that description.
Thus, it appearcd that the ambiguities wc wished to undarstand and cope with were related not to conjunction per sc, but to semantic properties of setb and relations on sets.
This view was reinforced by the discovery of syntactically parallel examples with sharply contrasting ambiguity patterns, as in (2 1 ).
While both (2la) and (21b) share a reading where what is desired is a production (employment) figurc for each year in the period, only (21a) has a (21) a.
How Inany cars were produced by Chrysler in the 1969-1972 period? b.
How many people were employed by Chrysler in the 1969-1 972 period? sensible ieading \vvhere the annual figures are to be totalled up arithmetically.
The reason lies in the distinction between quantities like earnings, auto production, and rainfall.
-which are inherently additive and are measured on a cumulative basis -and quantities like employment, assets and temperature, which are measured on an instantaneous pasls .r.
-1. and are not additive over time in a meaningful sense . On the other hand, (Zlb) seems to have two other possible readings (22a) and (22b), reflecting questions abaut the size of a set union and of a set intersection, respectively.
Although neither version of (22) could be answered with JJ *P Although it is meaningful to add them on the way to computing an average over a period of time.
(22) a.
How Inany cliffercnt people were employed by Chrysler in the 1969-1 972 period? b.
How many people wcre employed by Chrysler during the entire 19691972 period? respect to a Fortune-500-type data base, where people are countable but indistinguishable, both are questions which it would be quite reasonable to try to deal with in a data base environment that included personnel files.
At present, we are continuing to work on problems of conjunctionhandling both by pursuing the line qf investigation just touched upon and by studying patterns of disambiguation suggested by such examples as (I$), (19), and (22) . The richness and subtlety of the material we have encountered scarcely'hinted at here is particularly remarkable in the light of the severe limitations placed on the types of conjunction constructions to be considered.
While the use of string transformations has not provided us with a satisfactory solution for even a srnall part of the domain of co~~junction constructions, it has had the hlghly beneficial effect of bringing us face-to-face with a range of significant problems of which we had previously been almost total!y unaware.
5. Summary and Conclusions in the REQUEST System, string transformations are transformatiorial rules of relatively local scope which are applied to strings of lexical trees at ti point midway between lexical lookup and surface phrase structure parsing.
From the 'standpoint of linguistic theory, the status of the string transformation facility is unclear, since it is a component that seems to have no direct generative counterpart.
The fact that a number of existing string transformations are in effect inverses pf late postcyclic transform tions suggests that there may be some value in viewing the facility in terms of such relationships.
However, the rule writer is entirely free to ignore linguistic considcrations of this sort and define any of a wide range of tr'ee manipulations as string transforn~ations.
Accordingly, the string transfdrmation facility can,with some justification, simply be viewed as a convenient mechanism whereby the tree processing powar inherent in grammatical transformations is made available for purposes of implementing a wide variety of parsing heuristic s.
In contrast to the obscurity of its theoretical role, the str'ing transformation facility of REQUEST has had a clear and decidedly favorable impact ozi the practical development of the system.
The facility was originally added in order to provide a more satisfactorv input interface to the transformational parser an interface which would be considerably less vulnerable to the undc sirable side -effects of expand-ing grammatical coverage than one consisting solely of a preprokessor and a surface parser.
More specifically, this innovation was aimed at preventing the proliferation of unwanted surface parses in a way which would be at once less costly and more perspicuous than alternatives requiring extension of the preprocessor or of the surface grammar.
Based on approximately one year's experience in the use of the string transformation facility, it appears to have fulfilled these orizinal objec tives.
During this period, the grammatical coverage of REQlJEST has been significantly expanded, but the lexicon and the surtace, grammar have undergone only very modest growth as a result, and there has been no accompanying upsurge in the number of spurious surface parses.
The strategy of reo-rdering the Inverses of certaln late postcyclic rules within, the parsing system by placing them before, rather than after, the surface structure rules has provea to be effective both in reducing the number of unwanted surface analyses and in simplifying the surface grammar (and hence the structures that it produces).
Moreover, stririg transformations have also shown an unexpected versatility in such areas as idiom processing and homograph re solution.
In contrast to these favorable results, our attempt to employ string transformations in dealing with conjunction constructions -while of great indirect benefit -can hardly be vie-wed as an unqualified success.
What the latter experience has clearly demonstrated is the fact that string transforn~ations are a tool, not a panacea, and cannot be expected to yield satisfactory results in areas where the necessary linguistic groundwork is lacking.
Despite its limitations, we eqect to make continuedheavy use of this tool in our ongoing work on extending the gra~nn~atical coverageof the REQUEST System.
-Appendix: Listing of String Transformations The following is 9 complete computer listing of all 33 string transformations in the REQUEST System grammar as of October 1974.
The fully-parenthesized list notation employed in the computer file has been "pretty printed" i.
e., printed with indentations) in order to make the internal structure of the rules more legible.
Each list is surraunded by a pair of parentheses, with its main components (if any) in general printed starting two spaces to the right of the beginning of their "parent" list.
Thus, for example, the left parenthesis of the pair surrounding each rule is indented two spaces to the right of the left parenthesis that initiates the entire list of rules.
Similarly, with the excepti~ri of the header list (which is indented only one space to make it stand out), the main components of each rule the header, structural pattern, condition, structural cha-nge and feature change are indented two spaces with respect to the rule, and so forth.
In contrast to the two-dimensional graphical representation employed for trees in the figures in Section 4 of the text, trees in the listing are rep resented in a linear, parenthesized notation with the following essential characteristics: 1.
Within a structural pattern, an expression of the form (A B C . . . D ) stands for a tree of the form B, C . . . D themselves may be replaced by parenthesized expressions that stand for subtrees, etc.
As in the figures of Section 4, as sociationv of a feature list with a no& is denoted by enclosing the list in one pair of parentheses and then surrounding the node and the list with a second pair of parentheses, e.
g. (A ( + FEATl 'FEAT2 ) ) . In place of the curly bracket notation used in the figures to denote mutually exclusive sequerrces of trees, the listing employs expressions of the form (OR (list of trees1 ) (list of trees 2) . . . (list of treesn ) ), where the arguments of thei OR stand in one-to-one correspondence with the sequences of trees.
Thus, for example, the expression (OR (((mp . 2) (W.
5))) (((PREPOF.
3) (W :5 )))) in the structural pattern of the rule SPREPREV (p.77) corresponds to the curly bracket expression fiat appears near the top of Figore 4 (p..33 ) . 2.
Within a condJtion, structural change, Or feature change, trees are represented in a fully parenthesized 'dressed" notation which contrasts as follows with the "peeled" notation just described for trees in structural patterns: Each node in a tree always has two pairs of associated parentheses,an inner pair surrounding the node and its feature list (if any) and an outer pair enclosing the node, the feature list, and any subtrees dominated by the node.
Each feature list contains at least two pairs of parentheses -one surrounding the entire ligt, and one for each (feature value, feature name) pair.
Thus in "dressed" notation the "peeled'expressions (A B C . D ) and (A ( + FEATl FEAT 2 ) ) become ((A) ((B)) C((D))) and ((A((+ FEATl) (FEATZ)))) respectively.
((HYPHNRNK STRING OB ALL) ( (X . 1) (THE . 2$ (OR (((VADJ . 3) ++ OROI)) ( (((VADJ . 4) (+ CAR011 (W 10)) (OR ((((VAOJ : 5) (+ EST + POL)) HIGH)) (((VADJ 5 TOP)) ((((VADJ a 5) t+ EST + POL)) HIGH)) (((VADJ 5) TOP)) (HYPHEN . 6) ((VTNG . 7) RANK) ((NOM 8) (NOUN (V COMPANY) INDEX)) tX . 9) 1 NIL ( (COND ( 3 (REPLACE (8 7 3) 8) 1 (4 (REPLACE ( 8 7a ((VADJ ((+ ADJ) (+ OROI)) ((INQUOTE 1))) I (PREP) ((THROUGH))) (VADJ ((+ ADJ) (+ ORO))) 10) 1 8)) (T (REPLACE ( 8 ? ((VADJ ((+ ADJ) (+ 0RQ))b (((NQUOTE 1))) 1 8))) (DELETE 3) (DELETE 4.1 (DELETE 5) (DELETE 61 (DELETE 71 1 NIL ( (NUMBRNCO STRING OB ALL) ( (X.
1) P ('THE. 2 I (NOUN 3) (V NUMBER) INDEX) ((VADJ 4) (+ CARD)) f(-NOM 5 (NOUN (V COMPANY) INDEX)) (X . 6) I NIL ( (REPLA'CE (, 5 ((VING ((+ LOC2) (+ ADJ) (+ ING))) ((C~ANK)) ) 3 4 1 5 1 (DELETE 3) (DELETE 4) 1 NIL 1 --IL--II--------.-----c-LI.------((NUMBERN STRING 00 ALL) .x . 1) \OR ((RAN,K 2)IeI(BE 2))) ((NOMQ 3) (NOUN (V NUMBER) (INDEX 7))) (((VADJ 4) (4 CARD)) (W 8)) (OR ((IN 51) ((WITH,RESPECT,TO .5))1 (X . 6) 1 VIL ( (R'EPLACE ( ((?REP ((+ LOC2))) ((1N)r I ((VADJ t(+ ADJ) (+ ORD))).
€3) ( (NOPI) ((NOUN ((+ SG) (-' HUMAN) (+ PLACE))) ( (V) (PLACE) 1) 7) )) 3 1 (DELETE 4) 1 NIL j -L.yII----I--------...-----------((RNKINTVL STRING 00 ALL) ( (X 1) (OR ( (BETW~EN . 2 ((VADB i+ ORD)) (W . 3)) (AND 4) ((FROM 2) ((VADJ(+ ORD)) (W 3)) (OR ((TO 4)) ((THROUGH 4))) ) ( ((VADJ (+ ORD)) (W 3)) OR ((TO 4)) ((THROUGH 4)) ((HYPHEN . 4)) (((VADJ 7) (+ ORD)) (W 51) (X 6) ) ( NOT (ANALYSIS 1 T ( QUOTE (((XI) ((FROM))) ) 12 3.4 5 6) tl 0, 0 0 (3 5) 6) ((INSERT 7 ((4 IN?'ERVAC~~)) L.HIIII-.+---------~--.L-----..L----( (F~~~STSUP STRING oe ALL) ( cx.
1) (OR ((RANK . 2)) ((BE 2))) (QP ((THE m 3)) NIL) ((VADJ a 4) (+ EST)) (OR ( ( IN . 5') ) ( (.WITH-RESPECT-TO . 5) 1 1 (X rn 6) ) NIL ( (REPLACE ( 2 ( ( PREP ( (+ LOC2 1) ((IN)) 1 1 2 1 (REPLACE ( ((VADJ I(+ A031 (+ ORD))) ( t'INQUOTE 1) 1 1 G ( (NOMI ((NOUN ((+ SG) (HUMAN) (+ PLACE))) ((V) ((PLACE))) ( ( INDEX ( f CONST 1) ((XN)) 1)) 4)) NIL f ---CI-.------p-c..IC---CIIIIIIIIIIICIC-((NTHSUPER STRING 06 ALL) ( (X . 1) (OR ((RAKK a 2)) ((BE 2)) (OR ((THE . $1) NIL) ((VADJ 4) (+ ORn)) (OR (~~VADJ 5) (+ EST))) NIL) (CJR ({IN 6)) ((W-ITH-RESPECT-TO rn 6))' (X a 7) 1 NIL t (REPLACE ( 2 ((PREP ((+ LOC2))) ((IN)) ) 1 2 ) (REPLACE ( ((NOMI ((NOUN f* SG) (HUMAN) (+ PLACE))).
(tV) (PLACE))) ( {P' EX ((CONST))) (XN)) 1 1 6 6 1 NIL 1 ------------------------------((NTHPLACE STRING 00 ALL) ( (X 1) (OR ((RANK 2)) ((BE, 2))) f (PREP * 3) IN) (OR ((THE rn 4)) NI&) ((VADJ . 5) (+ ORD)) 1 OR ((((VAIJ.~ 6) (4 EST)) HIGH)) NIL ((NOM IT NOUN (V PLACE) INDEX)) (OR ((IN 1) ((WITH-RESPECT-TO m 8111 (x'* 9) 1 Q NIL ( (COND ( 6 (REPLACE ( ((PP) 3 ((NPJ ((THE1 ((NOM) ((V) ((ADV (t+ EXTI)) 5) 6 1 7)))) 511 t T (REPLACF ( ((PP) 3 ((NP) ((THE) ( (NOMI ((V) ((ADV ((+ EXTI)) 5) ((V ((+ AD).! 14 POL) (+ EST))J ((HIGH)) ?)I)) 5))) (DELETE 3) (DELETE 4) (D€CETE 6) (DELETE 71 1 NIL 1 ( (YRINTRVL STRING OB ALL 1 ( (X . 1) (OR ( ((PREP 2) BETWEEN) ((INDEX (+ YEAR)) (W * 3)) (AND * 4) ( ((PREP . 2) FROM) ((INDEX (+YEAR)) (W * 3)) (.OR ([TO . 4)) ((THROUGH 4111 1 ( ((INDEX-(+ VEAR)) (W . 3)) (OR ((TO 6)) ( (THROUGH . 4) ) ((HYPHEN rn 4)) ) ) (((.INDEX . 7) (+ YEAR)) (W . 5)) (X . 6) ( NOT (ANALYSIS 1 7 (QUOTE (((XI) (fFROM))) ) 1 ( tCOND ( (AND 2 ( NOT (ANALYSIS 1 T 1 QUOTE ( ((XI) ( (PREP) 1 ((THE)) (OR f ((NOUN ((SG))) ((V) ((YEAR))) IlfNDEX)9 ( ((NOUN ((+ SG))) ((V) ((PERIOD))) ((INDEX)) 1 T ) 1 1 (REPLACE ( ((PREP I (+ LOC2j 1) ((IN)) 1 ) 2)) ( T (DELETE 2) ) (DELETE 3) {DELETE 41 (*REPLACE (3 5) 5) 1 ((INSERT 7 ((+ INTERVAL)))) ) ( (CSYCLSFR STRING OB ALL ) t (X a 1) (THE a 2) ( NOUN (V ( OR CITY . 3)) ((STATE a 31.1 ((YEAR a 31) ) 1 (INDEX . 4) (OF . 5) ((INDEX a 6) (ORX I+ CoITY + STATE + YEAR))) (X a 7) 1 ( EQUAL ORX (QUOTE ( + ( NODENAMEOF 3 ) ) (1234547 (1000069 NIL ------CCICC-I--.I.I---lCIIIIIII--'I1I--1 ((CSBLOCK BLOCK 08 ONE) ( (X.
1) (THE 21 ' ( NOLJN (V (OR ((CITY 3)) ((STATE a 3))) (INPEX rn 4) ) (OF 5) ((INDEX 4) (ORX (+ CITY + STATE)-)) (X . 7) 1 NIL NIL NIL ---.--.-----------------------------((PRDCLSFR STRING OR ALL) (a(X 1) (THE -a 2) (OR 4 ((NOUN, 3) (V PERIOD) INDEX) ((INDFX, 4) (+ INTERVAL)) 1 (((INDEX a 4) (+ INTERVAL)) UNOUN 3) (V PERIOD) INDEX) (X a 5) 1 NIL ((DELETE 2) (DELETE 3)) NIL 1 --------------------------------.---((YRCLASFR STRING 08 ALL) ( (X . 1) (THE 2) ((NOUN 31, (\/YEAR) INDEX) ((INDEX, 4) (+ YEAR)) (X . 5) NIL 1 T 3 4 5) (1 0 0 4 5) NIL -LIIIIIIIIIIII-ICLI-C ((COCLASFR STR1,NG OB ALL) ( cx, 1) (OR ((THE m.
2 NIL) ((INDEX . 3) (+ CO)) ( (NOUN . 4) (V COMPANY) INDEX) (X, 5) (NOT (ANALYSIS 1 NIL (QUOTE (((XI) ((THE))) ) Cl 2 3 4 5) (1 0 3 0 5) NIL rr--I-.Ir---.r.r-----rrrrrr.r----rr----L------((CITYSTAT STRING 08 ALL) ( (X m 1) (((INDEX 61 (+ CONST + CITY)) (W 2)) (OR ((COMMA m 3)) NIL) ((INDEX (+ CONST + STATE)) (W, 4)) (X, 5) NIL (1 2.3 4 (1 (2 4) 0 0 5) ((INSERT 6 ((+ CITYSTATE)))) --wIIIIIIIIIIII-----I----I.----------66 ( (CSYCOCNJ STRING OB ALL) ( tx 1) (*.
.( (INDEX (ORX (+ CITY + STATE + YEAR + CQ) 1) ( W . 2 1 (COMMA 3) ((INDEX (ORX (+ CITY + STATE + YEAR + CO))) (W 2)) (OR ((COMMA 3)) NIL) (OR ((AND . 4)) (~ORR . 5))) (((NOUN .* 8) (+ SG)) (((INDEX 9) (ORXI) (W 6)) 1 (X 7) ( NOT (ANALYSIS 1 T ( QUOTE ( ((XI) ((INDEX (ORX))) ((COMMA)) 1 (1234567) (1 0 0 0 0 (2 6) 7) ( (COND ( 4 ( (INSERT 9 ((+ ANDSET))I (INSE T 8 ((7 SG))) 1 1 ( 5 (1 9 ((+ O~SET))) 1 -----.l-l-.IIICe.ILUL.---.CCI.LIICIIIIIIII ( (GENAFCNJ STRING 08 ALL) ( (X . 1) (* ((&NOEX (ORX (+ CITY + STATE + YEAR + CO))) (W . 2)) (GENRF 3) (COMMA 4) ) ((INDEX (ORX (+ CITY + STATE + YEAR + CO))) (W . 2)) (GENAF . 3) (OR ((COMMA 4)) NIL) (OR ((AND 5)) ((ORR 6,))) (((NOUN 10) (+ SG)) (((INDEX 11) fORX)I (W r 7)) (GENAF 8) (X . 9) (NOT (ANALYSIS 1 T ( QUOf E ( ((XI) ((IN~EX (ORX))) ( (GENAF) 1 ((COMMA)) 1 1 (1.2345678u) (1 0 0 0 0 0 (2'7) 8 9) I (COND ( 5 ( (fNSERT 11 ((+ ANDSET))) (INSERT UO ((0 SG))) ( 6 (INSERT I1 ((+ ORSET))) 1) 1) rrc-------....--------T-d.I-'---..----I ((PPCONJ STRING 08 ALL) ( tx . 1) (* (OR ((PREP (W rn 2))) ((PREPOF (W 2))) 1 ((INDEX (ORX (+ CITY + STATE + YEAR + CO))) (W 3)) (COMMA 1 4) ) ( OR ((PREP (W 2))) ((PREPOF (W . 2))) ((INDEX (ORX (+CITY + STATE + YFAP + CO))) (We 3)) (OR ((CQMNX 4)) NIL) (OR ((AND 5)) {(ORR 6))) ( OR ((PREP (W m 7))) ((PREPOF (W rn 7))) 1 (((NOUN 10) (+ SG)) ((fINDEX . 13) IORX)) (W 8)) 1 (X . 9) 1 (AND ( NOT (.ANALY'S I s 1 f ( QUOTE ( !(XI1 (OR ('((PBEP))) ((tPR€.POF))) 1 ((INDEX (ORX))) ((COMMA11 1) 1) (COMPARELISTITEM 2 7) (123456789) (1 0 0,O 0 0 7 (3 8) 91 ( (CON0 ( 5 ( (INSERT I1 ((+ ANDSETI)) (INSERT 10 (1SG))L*) ( 6 (INSERT 11 ((+ ORSET)\) 1 ) ) ) ({RTIMEDST STRING 00 ALL) ( (X * 1) ((PROPNOM . 2) (NOUN (INDEX (+ YEAR)))) (NMNL (+ PERIODIC)) (OR ( (OR (PREP) (PREPOF)) (INDEX (+ CO)) NIL (* COMMA ((NMNL 3) (+ PERIODIC)) ( OK' ( (OR ((PREP)) ((PREPOF))) (INDEX (+ CO)) NIL ) I OR ( (OR ((COMMA 5)) NIL) AND ((NMNL . 4) (+ PERIODIC)) ( COMMA ((NMNL 4) (+ PERIOD1 I OR ( (OR ((PREP)) ((PRlE (INDEX (+ CO)) 1 NIL (* COMMA ((NMNL 6) (+ PER10 (OR ( (OR ((PREP)) ((P (INDEX (+ CO)) NIL ) (OR ((CUMMA . 7)) NIL) AND (NMNL (+ PERIODIC)) 1 1 (X 8) 1 ( AND (NOT (ANALYSIS 8 T ( QUOTE ( (OR ( ((PREP)) ((INDEX ((+ YEARI))) ((X)) (OR (((PREP))) (((PREPOF))) 1 ( (INDEX 4 (+ CO) 1.1 1 ((PREP) 1 ((INDEX ((+ YEAR)))) ((XI) 1) 1) 1) (CON0 ( 5 3 1 (T T))) ( (REPLACE (2 4) 4) 1 NIL 1 --------------.--------.---------((LTIMEDST STR~NG 00 ALL) ( (X rn 1) (OR ( (OR ((INDEX (+ CO)) GENAF ((NMNL 2) (+ PERIODIC)) 1 ( (OR (THE) NIL) ((NhNL . 2) (+ PERIODIC)) (OR ( (OR (PREP) (PREPOF)) ((NPROPNCIM . 4) (NOUN (INDEX (+ CO)))) 1 NIL: I ) 1, 9 ( (OR ((INDEX (+ CO)') GENAF ((NMNL . 3) (+ PERfODIC)) 1 ( (OR (THE) NIL) ((NMNL rn 3) (+PERIODIC)) (OR ( (OR (PREP) (PREPOF) (INDEX (+ CO)) 1 NIL I 1 1 (* COMMA (OR ((INDEX (+ CO)) GENAF (NMNL (+ PERIODIC))) (OR (THE) NIL) (NMNL (+ PERIODIC)) ( OR ( (OR (PREP) (PREPOF)) (INDEX (+ CO)) 1 NIL 1 1 'COMMA (OR ((TNDEX (+ CO)) GENAF ((NMNL 2) (+ PERIODIC)) ( (OR (THE) NIL) ((NMNL . 2) (+ PERIODIC)) I OR ( (OR (PREP) (PREPOF)) f (.NPROPNOM . 4f (NOUN (INDEX (+ CO) 1) ) NIL))))) (* COMWA (OR ((INDEX (+ C0)) GENAF ((NMNL rn 3) (+ PERIODIC)!
( (OR (THE) NIL) ((NMNL.
. 3) (+ PbERIODIC) 1 ( OR ( (OR (PREP) (PREPOF)) (INDEX (+aCO)) NIL 1 1 1 ) (QR ((COMMA . 5)) NIL) AND ( OR ((INDEX (+ CO)) GENAF (N~NL (+ PERIODIC)) (PREP . 6) ((PROPNOM . 7) (NOUN I-INDEX (+ YEAR)) 1) 1 ( (0.~ ITHE) NIL) (NMNL (+ PERIODIC)) (OR ( (OR (PREP) (PREPOF)) (INDEX t+ C0)) (PREP 6) ((PROPNOM 7) (NOUN (INDEX (+ YEAR)),)) 1 ((PREP 6) ((PROPNOM rn 7) (NOUN (INDEX (+ YEAR)))) (OR (PREP) (PREPOF)) (INDEX r+ CO1) 1 1 1 (X 8) ) ( AND (NOT (ANALYSIS 1 T (QUOTE 1 (OR ( ((XI) ((INDEX ((+ CO)))) ((GENAF)) ) (((X)) ((THE))) t 1(X)) ((NMNL ((+ PERIODIC)))) (OR I (OR (((PREP))) (((PREPOF))) 1 ((INDEX t (+ CQI))) ) NIL ((COMMA)) 1) 1)) 1 (COND ( 53 1 (7 TI)) ( (COND ( 4 (RFPLACE (4 6 7) 4) ) ( T (REPLACE (2 6 7) 21 1 1 1 NIL ---~..Y~-------------IL.I.L.LI.~---~~.
( ( LGtNDTST STRING 00 ALL) (X, 1) (OR (THE) NIL) (OR (OR ((INDEX (+ YEAR)) ((NMN~ . 2) (+ PERJODIC)) 1 (((NMNL 2) (+ PE$IODIC)) (OR (PREP (INDEX (+ YEAR))) W-IL) ) 1 1 (OR ((INDEX (+ YEAR) 1 ((NMNL 3) (+ PERIODIC)) 1 (((NMNL, 3) (+ PERIODIC)) (OR (PREP (INDEX (+ YEAR))I NIL) (* COMMA (OR (THE) NIL) (OR ((INDEX (+ YEAR)) (NMNL (+ PERIODIC))) ((NMNL (+ PERIODIC)?
(OR (PREP (INDE'X (+ YEAR))) NIL) 1 1 1 COMMA (OR (THE) NIL1 OR ((INDEX (+ YEAR)) (CNMNL 2) (+ PERIODIC)) (((NMNL 2) (+ PERIODIC)) (OR (PREP (INDEX (+ YEAR))) NIL) 1 1 (* COMMA (OR (THE) NIL) ( OR ((INDEX (+ YEAR)) ((NMNL, . 3) (+ PERIODIC)) 1 (((NMJVL 3) (+ PERIODIC)) (OR1 (PREP (INDEX (+ YEAR))) NIL) F 1 1 (OR ((COMMA 4)) NIL) AND (OR (THE) NIL) ( OR ((INDEX (+ YEAR)) (NMNL I+ PERIODIC))) ( INMNL r+ PERIODIC) 1 (OR (PREP (INDEX (+ YEAR))) NIL) ) ([Il+ ((PREP 51)) ((OREPOF . 5))) (INPRQPNOM 6) (NOL'N (INDEX (+CO)))) tx, 7) ) (AND (NOT (ANALYSIS 1 T t QUO1 E ( (OR (((XI) ((THE))) ( ((XI) (INMNL ((+ PERIODIC)))) (OR ((+ YEAR)))) NIL ((COMMA)) ( ((lo) ((INDEX ((+YEAR)))) 1) 1) 1) (COND(4 3) (T TI)) ((REPLACE (2 5 6) 2)) NIL 1 ((CARDNOUN STRING 08 ALL) ( IX . 1) (((VADJ . 2) (+ CARD)) (W 5)) ( OR ((A 3)) ((VAUX 3)) ((COMMA 3)) ((DAUX m 3)) ((PREP m 3)) ((PUNCT 3)) ((THE 3)) ((V, 3)) (((VADJ . 3) (+ CARD))) ((VADJ . 3) PREP) ((VPART 3)) (X 4) ( NOT AND (ANALYSIS 3 NIL (QUQTE t((~))))) (ANALYSIS 4 T ( QUOTE ( ( (INDEX ( (CONST) 1) ((X)) 1) 1) 1 ( (REPLACE ( t(NP1 ( (NOMI ((NOUN ((+ SG) (HUMAN))) ((INDEX ((+ CONSTI (+ CARD))) 5) 1 1 1 2)) NIL' 1 ((ABTAPPRX STRING 06 ALL) ( (X " 1) ((PREP 2) ABOUT) (OR I(IVAD3 e 3) (+ CARD))) ( (EQUAL 3) ) ((WH . 4) SOMF (OR.(LARGE) (MANY) (MUCH)) (X * 5) 1 (CON0 ( 4 (NULL 1) 1 T 7-11 ((R'EPLACE (.
(('ADv) ((V ((+ ADJ))1 ((APPROXI) 1 21) NIL 1 ---....-;L---c-..IcI-------((COMPNQFR STRING OB ALL) ( (X . 1) ( OR ( ( (,PREP . 2 1 A.3) (OR ((LEAST . 3)) ((MOST 4))) ) ( (OR ((NO 5)) ((NOT 5)) NTL) f OR (((VCOMP 7) LESSTHAN)) ( (OR ((MORE 6)) ((FEWER 71)) ((THAN8)) ) 1) ) ((VADJ 9) (+ CARD)) (X . 10) (NOT (ANALYSIS 1 Nf L ( QUOTE ( lW (((NrSS)) (((NOT))) 1 1 ) 1 ( (COND ( (AND 6 (NOT 5)) (REPLACE I 4tADV) ((V ((+ ADS) (+ COMP) (+ TWOARGS) (+ NMA3X))) ((GREATERTHAN) 1 ) 9 9) ( (AND f (NOT 5)) (REPLACE ( ((ADV) ((V ((+ A031 (+ COMP) (+ TWOARGS) (+ NMA3X))) (LESSTHAN) 1 ) ? 9 1 9) 1 ( (OR 3 (AND 5 7)) (REPLACE ( ((AOV) ((V (t+ ADd) (+ COMP) (+ TWOARGS) (+ NMA2X))) t (GRTRTHANEQ j 9 1 91 1 (OR 4" (AND 5 6)) (REPLACE ( ((ADV) ((V ((+ APJ) (+ COMP) 14 TWOARGS) (+ NMAZX))) ((LESSTHANEQ)) 1 ) 9 1 91)) (DELETE 2) (DELETE 3) (DELETE 4) (DELETE 5) (DELETE 6) (DELETE 7) (DELETE 8) NIL ) ( (WHNUMAMT STRING OB ALL) ( (X . 1) (OR (((VADJ 2) WH SOME)) ( ((WHADV . 2) (V WH SOME)) ((VADJ 2) LARGE) (A 2) ((NOMQ 3) (NOUN I v (OR ((NUMBER 7)) [(AMOUNT 81)) 1 (INDEX 9) 1 ) (OR ((OF 4) (THE 5)) ((OF 0 4)) NIL 1 (X m 6) [ AND (NOT (ANALYSIS 6 IS1 (QUOTE ( (OR (((OF)) ((X))) (((THE)) ((XI)) 1) 1 (COND ( (NULL 4) 8 ) T TI)) ( (COND ( 4 fCOND ( 7 (REPLACE ( ((WHADJ) ((ADV ((+ EXTI)) ((V ((+ AD31 + QUANT))) ((WH) ((SOME)) 1 1 ((V ((+ ADJ) (+ QUANT) (+ POL))) (IYANY)) 1 1 3) 1 ( 8 (REPLACE ( ({WHADJ) ((ADV ((+ EXTI)) ((V I(+ AD31 f+ QUANTJ)) I (WH) ((SOME)) 1 1 ((V ((+ A031 + QUANf) (+ POL))) ((MUCH)) 1 1 3)))) (T (REPLACE ( ((ONOM) (/ADV ((+ EXTI)) ((V ((+ AOJ) (+ QUANT))) ((WH) ((SOME)) 1 f (NOM) ((NOUN ((0 HUMAN) (+ SG)]) ((V ((+ ADJ) (+ QUANT) (+ POL))) ((MUCH)) 91111 3) 1) (CONO ( (AND 4 (NOT 5)) (DELETE 4) (DELETE 2) ) NIL 1 -----rr.lrC--rrrr-lrII--.--rrcrrrrrrrrrr--.---*-rr-((SPRPPREV STRING 00 ALL) ( (X . ll (OR (((PREP 2) (W rn 5))) (((PREPOF 3) (W rn 5))) ) (X . 4) 1 (NOT (ANALYSIS 4 NXL ( QUOTE t (OR (((BAUX))) ( ( (COMMA) 1) (( (OAUX))) (((PREP)) 1 (((PUNCf! 11 I((V))) (( (VADJ) 1) (((VfNG))) 1 l(?O) 1) 1) ( (CON0 1 2 (CON0 ( (ANALYSIS 2 Ntt (QUOTE (((PREP ((+ LOC2))))) ) 1 (REPLACE ( ((NSPRED ((+ COCZ))) 5) 1 2)) (t (REPLACE (((NSPREP) 51) 2) 1) ( 3 IREPLACE (((NSPREPOF) 5) ) 3) 1 I 1 NIL 1 -----~~YI---ILII-IIIICI-L---((TIMECMPD STRING OB ALL) ( (X 1) ((PROPNOH 2) (NOUN (INDEX (+ YEAR)))) ((NM-WL 3) (+ PERIODIC)) (X . 4) NIL ( (REPLACE (((NMNL) 2 3)) 31 (DELETE 2) 1 NIL 3 ((RANKCMPD STRING OR ALL) ( (X, 11 (NMNL 2) ((NMNL 3) (V PLACE RANK) INDEX) (X . 4) 1 ( NOT ( ANALYSIS 1 /Sl l QUOTE ( ((XI\ (tINDFX ((+ YEAR)))) 1 1 1 1 ( (REPLACE ((NMNL) ((NOMI 2) 3) 3 1 (DELETE 2) NIL ---C---IC----.I-CII-(..CII-------Ci(PR0PERPP STRING 08 ALL) ( (X, 1) (OR ((NSPREP 2)) ((NSPREPOF . 3))) (OR ((PROPNOM e 4)) ((NPRQPNOM 4))) (X.
5) ( NOT (OR (ANALYSIS 5 T ( QUO?
E (((GENAF)) ((X))) 1 1 (AND (ANALYSIS 5 /Sl (QUOTE ( ((NMNL ((+ PERIODIC)))) f.(X)) 1 1 1 (ANALYSIS 4 YIL I QUOTE ( ((PROPNOMI ( (NOUN ) ((INDEX (t+ YEAR)))) 1 1 1 1 1 1 1 1 I (CON0 ( 2 (REPLACE ( ((PPI 2 ((NP) 4)) 1 2)) ( 3 (REPLACE ( ((PPOF) 3 ((NP) 4)) 31 1) (DELETE 4) 1 NIL ((XI) 'I 1 T TI) (COND ( (NOT 5) ( ANALYSIS 1 T ( QUOTE [((XI) ((GENAF))) (T TI11 ( (COND t 2 (REPLACE ( ((NOMI 2 ((21) 5 6)) 2)) ( 3 REPLACE ( ((NOMN) ((N~~MNI 3) ((Z1) 5 6) 1 3 1, 1 14 (REPLACE ( ((NOMN) ((NOMN) 4) ((21) 5 6) ) 1 4) 1) (DELETE 5) (DELETE '6) 1 NIL1 ) C-1---CI---ILI--C-LII-------C-1--.----References Petrick, S.
R., "Senlantic Interpretation in the REQUEST System1', in A.
Zampolli (ed.
) Co~nputational and Mathenlatical Linguistics.
Preceedings of the International Conference on'~om~utationa1 Linguistics.
Pisa, 27'~*111 I/IX 1973, Casa Editrlce Olschki, Firenze (1974), Vol.
I. Plath, W.
J., "Transformatio~al Grammar and Transforrnatfonal Parsing in the REQUEST System", in A.
Zampolli (ed.
), Conlputationql and Mathenlatical' Linguistics.
Proceedings of the Lntc r national Conference on ~on~~ut+t$nal ~in~~istics.
Pi'sa, 27 VIII 1 /IX 1973, Casa Editrice Olschki, Firenze (1 97q.), Vol, 11.
Knuth, D.
E,, "Semantics of Contest-free Langiiages" Mathematical Systems Theory, Vol.
2 (1 968).
pp. 127-1-15.
Petrick, S.
R. "On the Use of Syntas-based Trai~slatoys for Symbolic and Algebraic ~ani~ulatidn", in S.
R. Petrick (ed ), Proceedings of the Second Syn~posium on Syn~bolic and Algebraic Manipulation, ACM, New Yoik (1971 ), pq.
224-237 Petrick, S.
R., Mapping of Linguistic Structures into ConlputerInterpretable Form, AF~RL-TR-73-0055, Final Report, Contracf No.
F19628-72-C-0129 (December 1972).
Petrick, S, R., A Recognition Procedure for Transfornlational Gram mars, MIT Doctoral Dissertation (1 965) Chomsky, N., Aspects of the The~ry of Syntax.
MIT Press, Cambridge, Mass.
(1 965 ).
McCawley; J.
D., "Meaning and the Description of Languages" Kotoba No Uchu, Vol.
2, Nos.
9-1 1 (1 967 ).
Lakoff, G., "Linguisti-cs and Natural Logic", Synthesc, Vol, 22, Nos.
1-2 (1970).
Kuno, S.
and Oettinger, A.
G., "Multiple-path Syntactic Ahalyzerl', Mathematical Linguistics and Autom,atic Translation, Report No.
NSF-8, gc.
I, he Computation ~aboratvvard University (i963).
1 1.
Plath, W.
J., "Multiple-path Syntactic Analysis of Russian", Mathe n~atiCal Linguisticg and' Automatic Translation, ReporMn.
NSF12.
The Con~putation.
Laboratory of Harvard University (1 96-31 12.
Woods, W.
A., Kaplan, R.
M. and Nash-Webber, B., The Lunar Scienc cs Natural Language Infbrmation System, Final Report, BBN Report No.
2378, Cambridge, Mass.
(1977) 13.
Plath, W.
J., "A Tag Language L for Syntactic and Semantic Analysis 'la in H.
H. Josselson (ed.
), Proceedings of the 1965 Conference on Computer Related Semantic Analysis, Wayne State University', Detroit, ~ich'.
(1 966).
146 Friedman, J., Bredt, T.
H. et al., A Computer Model of Transformational Grammar, American ~lsevier;.
New Y ork (1 97 1 ) 15.
Selzer, L.
E. (ed.
), The Columbia Lip-pincott Gazetteer of the World, Columbia Universitv P~ess, New York (1 961 ) .

