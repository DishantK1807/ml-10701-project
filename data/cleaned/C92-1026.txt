DATA TYPES IN COMPUTATIONAL PHONOLOGY Ewan Klein University of Edinburgh, Centre for Cognitive Science 2 Buccleuch Place, l~;dinl)urgh Ell8 91,W, Scotland Entail: klo in@od, ac.
uk ABSTRACT This paper exanfines certain aspects of phonological structure from the viewpoint of ahstract data types, Our imnlediate goal is to find a format for l)honological representation which will be reasonably f,'fithful to the concerns of theoreti: cal phonology while I)eing rigorous enough to a(Irail a computational interl)retation.
The longer term goal is to incorporate such representations into all appropriate general framework for llatnral language processing, i 1 Introduction One of the dominant paradignls ill cnrrell| colnputat.ional linguistics is l)rovided by unificationbased grammar formalisms.
Such formalisms (of.
IShieber 1986; Kasper t~ Rounds 1986)) describe hierarchic~d feature stl'tletllres, which iH inally ways would appear to be an ideal selling \[br formal phonological analyses.
1,'eature bundles have long been used l)y phonologists, and more recent work on so-called feature geonletry (e.~.
(Clements 1985; Sagey 19,~6)) has introduced hierarchy into such represenlations.
Nevertheless. there are reasons to step back from standard feature-based apl~roaches, and instead to adopl the algebraic perspective of abstracl data types (AD'P) which has been widely adopted iu coml)uter science.
One general motivation, which we shall not e.xplore here.
is thai Ihe aclivily of grantlnar writing, viewed as a process of programme specification, should be amenable Io sl~pwise refinement in which the set of {sol necessarily isomorphic) n,odels admitted by a loose IThe work reported in this paper has \[)¢:~,1, ~;tl ried ollt its part of the research i)rf)glitli/lll(!S o l\]l(' \].{llnl&l\[ (~oFiin/llllic&\[iOll |lesea.rch (}(:Illl'C.
sl/ppOl'led })3 the OK Economic and Social Rescalch (:ouncil aml the project Computational l)houoh)gy:.,I ('onst~aint-fh~s¢d Approach, funded by the IlV.
~qcience and Engineering I(t.
search Council, under grant (;R/(;-22081.
1 am glalt'ful to Steven Bird.
Kimba Newton and 'l'm/v Simou \[m di> cussions relating to this work.
AcrEs DE COLING-92, NAtc~S, 23-28 Ao~rr 1992 specilication is gradually narrowed down to a u,fiqtm 'algebra (cf.
(Sannella & Tarleeki 1987) for an overview, and (Newton in prep).
for the apldication to grammar writing).
A second motivation, discussed in detail by (Beierle & Pletat 1988; Beierle K~ Pletat 1989; Beierle et al.1988), is to use equational ADTS to provide a mathematical foundation for h~ature structures.
A third motivation, dominant in this pal)er, is to use the AI)T appl'oach lo provide a richer array of explicit data types than are readily admitted by "p'tlre' feature structure approaches.
Briefly, in their raw form, \[eature terms (i.e., fnrnlalislns for describing h~alure stru(:tures) do not always provide a perspicuous format for representing strllct II re.
On the ADT approach, complex data types are built up from atomic types by means of constructor functions.
For example ....
(where we use the underscore '_' to mark the position of the fimction's arguments) creates elements of type List.
A dala type may also have selector functions for taking data elements apart.
Thus, selectors for lhe type L±st are the func tions first and last.
Standard feature-bossed encoding of lisls uses only selectors for the data type; i.e. the feature labels FIRST and LAST ill ( 1 ) FIRST : o" 1 17 LAST : (FIRST : o" 2 17 LAST : nil) tlowever, the list constructor is left implicit, That is, the feature term encoding tells you how lists are pulled apart, but does not say how they are built up.
When we confine our atlention just to lists, lhis is not much to worry about, ltowever, tile situation becomes less satisfactory when we atIelnpI' to encode a larger variety of data structures into one and the same feature term; say, for example, standard lis(s, associatiw~ lists (i.e.
strings), constituent structure hierarchy, and au tosegmental association.
In order to distinguish axtequately between elements of such data types, we really need to know the logical properties of their respective constructors, and this is awl 1 4 9 PRec.
oF COLING-92.
NANTES. AUG.
23-28. 1992 ward when the constructors are not made explicit.
For computational phonoloKv, it is not an unlikely scenario to be confronted with such a variety of data structures, since one may well wish to study the complex interaction between, say, non-linear teml)oral relations and prosodic hierarchy.
As a vehicle for computational implementation, the uniformity of standard attribute/value notation is extremely usefld.
As a vehicle for theory development, it can be extraordinarily uuperspicuous.
The approach which we present here treats phonological concepts as abstract data types.
A particularly convenient development environlnent is provided by the language OBJ (Goguen & Winkler 1988), which is based on order sorted equa, tionaJ logic, and all the examples given below (except where explMtly iudicated to the con trary) run in the version of OBJ3 released by sltI in 1988.
The denotalional semantics of a.n OB.\] module is an algehra, while its operational semantics is based on order sorted rewritiug.
I 1 1.1 and 1.2 give a more detailed introduction into the formal framework, while § 2 and 3 ilhlstrate the approach with some phonological examples.
1.1 Abstract
Data Types A data type consists of one or more domains of data items, of which certaiu elements are designated as basic, together with a set of opera tious on the domains which suffice to generate al\] data items in the domains fl'om the I)asic items.
A data type is abstract if it is independenl of any particular ret)resentational scheme.
A fundamental claim of the ADJ group (cf.
(Goguen. Thatcher,~ Wagner 1976)) and llluch subsequent work (cf.
(Ehrig & MMn" 1985)) is that abstracl data types are (to be modelled as) algebras: and moreover, that the models of abstract data types are ilfitial alget)ras.
~ The signature ofa mauy-sorted algebra is a l)air = <S,O } consistiug of a set S of sorts and a se~ O of constant and operation symbols.
A specification is a pair (rE> consisting of a signal are together with a set g of equations over terms constructed from symbols in O and variables of the sorts in S.
A model for a speciIica.tion is ~An initial algebra is characlerized uniquely up to |so morphism as the semantics of a specification: there is a unique homomorphisnl from the initial algebra inlo t'vely algebra of the specification.
an algebra over the signature which satisfies all the equations £.
Initial algebras play a special role as the semantics of an algebra.
An initial algebra is minimal, in the sense expressed by the principles "no junk' and 'no confusion'.
'No junk' means that the algebra only contains data which are denoted by variable-fl'ee terms built up from ol)eration symbols in the signature.
'No confusion' means that two such terms t and t ~ denote the same object in the algebra only if the equation t = F is derivable from the equations of the specification.
Specifications are written in a convent|ohM format consisting of a declaration of sorts, operation symbols (op), and equations (oq).
Preceding the equations we list all the variables (var) which figure in them.
As an illustration, we give below an OBJ sl)ecification of the data type LIST1.
(2) obj LIST1 is sorts Ell List op nil : -> List . op .~ : Eli List -> List . op head : List -> Eli . op tail : List -> List . var X : Eli . vat L : List . eq (X . nil) = X . eq head(X, L) = X . eq tail(X . L) = L . endo The sort list betweeu the : and the -> in an operation declaration is called the arity of the operation, while the sort after the -> is its value sort.
Together. tiw al'ity and value sort constilute the rank of an operation.
The declaration op nil : -> Elt means that nil is aconstant of sorl Ell, The specitication(2) fails to guarantee that there are any objects of El/:.
While we could of course add soule constants of this sort, we would like to have a more general solution.
In a particular application, we might want to define phonological words as a List of syllables (plus other constraints, of course), and phonological phrases as a List of words, rl'hat is, we need to parameterlze the type LIST1 with respect to the class of elements which constitute the lists.
Before turning to parameterization, we will first see how a many-sorted specification language is generalized to an order sorted language by introducing a subsort relation.
Sul)l)ose, for exanlple, that we adopt the claim Aeries DE COLING-92, NANTES, 23-28 ^offr 1992 1 5 0 PROC.
OF COLING-92, NAN'rEs, AUo.
23-28, 1992 that all syllables have ('lonsets :(.
Moreover. we wish to divide syllables into the subclasses lmavy and light.
Obvimusly we wan! heavy and light syllables to inherit the l)roperties of the clas> of all syllables, e.g., they haw' ('1 onsets.
We use ltoavy < Syll to stale that Heavy is a subsorl of tile sort Syll.
We inlerl)l'et this to mean thai lhe class of heavy syllables is a subse! of the class (if all syllables.
Now, let onset_ : Syll -> Nora lie all operation which selects tlle tits! mora of a syllable, anti let us impose the Iollowing constraint (where Cv is a sul)sor! of Nora): (3) var S : Syll .var CV : Cv . eq onset S = CV, Then tile framework of or(ler sorted algebra ellsures that onset is also delined for obje('l > of s)i't Heavy.
llx~turlling to lists, the speciIication ill (,I) (sli~hll.v simplified from that used h> ((;oguen,k: Winkhq |988)) introduces Eli alld NeList (notl OlUl)t 3 lists) as subsorts of List.
and thereby !rein'ores on LISTI in a number of resi)ects, h, addition.
tile specification is parameter!zeal.
Thai is.
il characterizes a list of Xs, where the paralneler X can be instantiated tm any module which satislies tile condition TRIV; the laller is what ((;oy;uell & Winkler 1988} call a "requirenlenl theory', and in lhis case simply iml)oses on any inpul moduh, that it have a sot! which can be mal)p('(I to Ihe sort Eli.
(4) obj LIST\[X :: TRIV\] is sorts List NeList, subsorts Elt< NeList < List, op nil : -> List . op ._ : List List -> List . op . : NeList List -> NeList . op head : NeList -> Eft, op tail : NeList -> Llst . vat X ; Elt . vat L : List . eq (X, nil) : X . eq head(X . L) = X, eq tail(X . L) = L . endo Notice that the list constrllctor _._ llOW i)el'forllls the additional fluter!on ol append, allowing Iwo lists tm lie concatenated, h, addition.
!he se lectors llave beell made 'safe', ill lhe Sellse thai they only apply to objects (i.e..
nonemply lisls) for which they giwr sensible results: for whal.
ill LISTI, would have been the meaning of head(nil )? allere, the term mNSET ief(!lS to lh(' inilal mma o\[ a syllM)le in llyman's (198,t) velsion of tit(' iil(nai( th(!ol 3 2 Metrical Trees :\s a further illustration, we give below a specilit'at ion of the data lyp(!
BINTREE. This module has two parameters, bolh of whose requirelnent theories are TRIV.
4 (5) ob 3 BINTREE\[NONTERM TERM :: TRIV\] is sorts Tree Netree . subsorts Eli.TERM Netree < Tree . op _\[_._\] : EIt.NONTERM Tree Tree -> Netree . op _\[_\] : EIt.NONTERN Eft.TERM -> Tree . op label_ : Tree -> EIt.
NflNTERM . op left_ : Netree -> Tree, op right_ : Netree -> Tree . vars El E2 : Tree, vars h :EIt.
NONTERM . eq label (h \[ El, E2 \] ) = A, eq label (h \[ El \]) = A . eq left (h \[ E1, E2 \]) : E1 . eq right (h \[ E1, E2 \] ) = E2 . (~itdo \Ve can l~mx~ inslanl, iale 1he formal paranmters of th0 module in (5) with inpm module.s whiEh supply al)ln'opriale sels of ilOlll, erlnina\] and terminal symbols, l,el us use ui)percase quoted identifiers (eMnenls of the OB.I inodule QID) for nonterminals.
and lower case for terminals.
The specitlcalion in (5) allows us to treat terminMs as trees, st; Ihal a binary tree.
rooted ill a node 'A, can have lerminals as its daughters, ltowever, we ills() allow terminals to be directly dominated by a n(m-branchingmolher node.
\[Ioth possibilities occur in the examples below.
(6) illustrates the instantiation of tornlal parameters by an actual module, namely QID.
using the make construct.
16} make BINTREE-QID is BINTREE\[QID,QID\] endm The nexl exalnph, shows Nellie reductions in this module, obt, aiued by treating the equations as rewrite rules applying fi'om left to right.
~'l'hc n~tatir,a Elt .NONTERN.
EIt. TEPd4 utilizes a qual!lit:at!on M t he sort Eli by the input module's paranleter labch this is simply to allow disamlfigulttion.
ACRES DE COLING-92, NAMES, 23-28 AO~' 1992 1 5 1 Paoc.
OF COLING-92, NANTES, AUG.
23-28, 1992 (7) left ('h\['a,'b\]) . left ('A\['B\['a\],'C\['b\]\]) . "~ 'B\['a\] left ('A\['B\['a,'b\],'c\]) . ~* 'B\['a, 'b\] right(left (~A\[('B\['a,'b\]),'c\])) . label ('A\['a,'b\]) . .x~ JA label(right ('A\['a,*B\['b,'c\]\])) . ~4 JB Suppose we now wish to modify the definition of binary trees to obtalu metrical trees, These are binary trees whose branches are ortlered according to whether they are labelled 's" (strong) or 'w' (weak).
• v In addition, all trees have a tlistinguishetl leaf node called the 'designated terminal element '(dte), which is connected to the roe! of the tree I)y a path of 's' nodes.
Let us define 's' and "w' to t>e our nonterminals: (8) obj MET is sorts Label ops s w : -> Label . endo In order to buihl tilt, data iype of metrical lr¢,e~ on top of binary trees, we can import Ill(, moduh, BINTREE, suitably instantialell, using OB.l's extendingconstrucl.
Notice thai we use MET to in~tantiate the parameter which fixes BINTFLEE's ~et Of nonterminal symbols.
~ 191 obj HETTREE is extending BINTREE\[MET,QID\]*(sort Id to Leaf) op die : Tree -> Leaf . vat L : Leaf . vats T1 T2 : Tree . '~'\['he * construcl tells,s thai the i)ri,cipal ~.Ol~ of OlD.
llalnely Id, is mappe({ (1)), a sig,tai,.e .o*pl, isnl) to l llc sort Leaf in METTREE.
ceq signals the presen(c o\[a (-otldifionaI cquation.
== is a buill-in I)olymou)hic cqualil> operation in OBJ.
Acres DECOLING-92.
NAm,'~% 23-28 Aor~r 1992 vars X : Label . eq dte( X \[ L \] ) = L . ceq die ( X \[ T1, T2 \]) = die T1 if label TI == s . ceq die ( X \[ T1, T2 \]) = die T2 if label T2 == s . endo The equations state that the dte (designated terminal element) of a tree is the dte of its strong subtree.
Another way of stating this is that the information about dte element of a subtree T is percolated up to its parent node, .just in case T is tile "s' branch of that node.
The specification METTREE can be criticised on a number of grounds, it has to use conditional equations in a cumbersome way to test which daughter of a 1)inary tree is labelled 's', Moreover.
it fails to capture the restriction that no binary tree can have daughters which are both weak.
or both strong.
That is, it fails to capture the essential property of metrical trees, namely that metrical strength is a relational notion.
What we require is a method for encoding the fob lowing information at a notle: "my left (or right) daughter is strong".
One economicaJ method of doing this is to label (all and only) branching nodes in a binary tree with one of the following two lahels: 'sw' (my left daughter is strong), 'ws' (my right daughter is strong).
Thus, we replace MET with the following: obJ MET2 is sorts Label ope sw ~s : -> Label . ends We can now simplify both BINTREE and ME 'l'l l:;t'\]: obj BINTREE2\[NONTERM TERM :: TRIV\] is sorts Tree Netree, subsorts EIt.TERM Netree < Tree . op _\[_,j : EIt.NONTERM Tree Tree -> Netree . op label_ : Tree -> EIt.NONTERM . op left : Netree -> Tree . op right_ : Netree -> Tree . rare El E2 : Tree . vars A : EIt.
NONTERM . eq label (A \[ El, E2 \] ) = A . eq left (A \[ E1, E2 \]) = El . eq right (A \[ El, E2 \]) = E2 . eudo obj METTREE2 is extending BINTREE2\[MET2,QID\]*(sort Id to Leaf) . op hie_ : Tree -> Leaf . 1 5 2 Pgoc.
OF COLING-92, NArCrES, AUO.
23-28, 1992 var L : Leaf . vars TI T2 : Tree . eq dte L = L . eq dte T = if label T == sw then die(left T) else dte(right T) fi . ends 3 Feature Geometry The p~rticul~r feature geometry we shM1 specify here is based on the articul~tory structure defined in (Browman & Goklstein 1989)Y The five active articulators are grouped into a hierarchi cal structure involving a tongue node and an oral node, an shown in the following diagram.
root glot, tal relic oral tongue labial coronal dorsal This structul'e is specilied via term ('onstl'UC|Ol'~ (__} a,,a { ....
} which ~i ...... standar<i ),(,~iti ...... t encoding of features.
F, ach fealttre vahlc is expressed as a llaturaJ ltUlnl)or \[)o|w('ell 0 and 4.
representing the constriction degree of the ('or resl)onding articulator.
For examl)le, the tertu {4,0} : Tongue is an item of son Tongue con sistieg of the value,I for the Ioalure ('o)toN..\\[.
and 0 for the DORSAl,; this in turu express(,> a situation where there is maximal coasti'ictlon of the tongue tip, and minimal constriction of the tongue I)ody.
Of course, this encoding is rat her crude, and l)ossil)ly sacrifices clarily for cot,ci sion.
However, it sultices as a workiag ex;,leple.
We will returi/ to constri(qioll degt'ees })el()w.
The four sorts Gesture, Root.
Oral and Tongue ill (lO) atld the first three ol)erator~ cal)turo )h(' +;For spa(:(! reasons w( + hilVC Oltlittcd ;ItlX di~(II~H)I) O\[ \]~rowlnan (k!
Gohistein's COllStricliolt \]o(;ttion (('\[) .in(\] (:Oltslfit:tioll She+l)(!
((;S) pltl'illlittlClt,.
~*'~ (' alSO hax,.
omit ted (lie supralaryllgea\] node, since its i~hono\]ogi(al lob tsomewhat dubious.
desired tree structure, using an approach which should be familiar by uow.
For example, the third constructor takes the constriction degrees of Glottal and Volic gestures, and combines them with a complex item of sort Oral to build all item of sort Root.
The specifie~ttion imports the um(hde NAT of natural numbers to provide values for constriction degrees.
(10) obj FEATS is extending NAT, sores Gesture Root Oral Tongue . subsorts Rat Root Oral Tongue < Gesture . op {_, } : Nat Nat -> Tongue . op {_,_} : Tongue Nat -> Oral . op { .....
} : Nat Nat Oral -> Root, op _ ! coronal : Tongue --> Nat . op !dorsal : Tongue -> Nat . of !labial : Oral -> Nat . op !tongue : Oral -> Tongue . op _!glottal : Root -> Nat . op !relic : Root -> Nat . op _ ! oral : Root -> Oral . vats C CI C2 : Nat . vats 0 Oral . vats T Tongue . eq { Cl, C2 } !coronal = CI . eq { CI, C2 } !dorsal = C2, eq { T C } !tongue = T . eq { T C } !labial = C • eq { C1, C2 ) 0 } !glottal = C1 . eq { C1, C?,, O } !velic = C2 . eq { CI, C2, 0 } !oral = 0 . elldo AVe adopt the uol;atiollal coilventiOll of prepend int~ a '"! to the same of seh:ctors which col respond directly to features.
For example, the !coronal seleCor is a funct;ion defined on conlpIox ilenls of SOl"( Tollguo which rettzrlls air item ()f sort Nat, reln'eseetiug the constriction degree • ca\]u(' for ('oronality.
Sonn' illustrative reduct ions in the FEATS module are given l)elow.
(Ill {3,4,{{4,1},11} !oral . ~-, {{4,1},11 {3,4,{t4,1},1}} ~ora~ !to~gue . ....
{4,1} {3,4,{{4,1},1}} !oral !tongue !coronal . III 1 lie ..\ I)'1 ~pplo~-lch to leal Ill'e st rtlcI tires, feel'ileant 3 is represented by eqttating the values of ~('\]('('tol'~.
I'IIIIS. Sill)pose Ih;ll two 5egnlents S1, $2 '~hale ;t voicing sl)e(:ilication.
We can write th\],~ >t~ f~>llows: ACN:'S DE COLING+92, NANTES, 23-28 AO~r t992 1 5 3 PRec.
of COLING°92, NAN'rEs, AUG.
2.3-28, 1992 (12)S1 !glottal = S2 !glottal This structure sharing is consistent with one of the main motivating factors behind autosegmental phonology, namely, the undesirability of rules such as \[~ voice\] -\[~ nasal I.
Now we can illustrate the flmction of selectors in phonological rules.
Consider the case of 1';11glish regular plural formation (-s), where the voicing of the suffix seglnent agrees with that of the immediately preceding segment, unless it is a coronal fricative (in which case there musl be an intervening vowel).
Suppose we introduce the variables S1 $2 : Root, where S1 is the stemfinal segment and S2 is the suffix.
The rllle nllls\[ also be able to access tile coronal node of $1.
Making use of the selectors, this is simply $2 !oral !tongue !coronal (a nota.tion reminiscent of paths in feature logic.
(Kasper k llonnds 1986)).
The rule must test whether this coronal node contains a fi'icative specification.
This necessitates an extension to our specification, which is described below.
Browman & Goldstein (19S9.
234ff) define "con striction degree percolation', based on whal they call ~tube geometry'.
The vocal trac| can b(, viewed as an interconnected set of tllbes, and the articulators correspond to valves which have a mmlber of settings ranging from fiflly open to fiflly closed.
As already mentioned, these ~eltings are called constriction degrees ( ! cds).
where fully closed is the maximal constriction and fully open is the minimal constriction.
The net constriction degree of the oral cavity may be expressed as the maximum of the constriction degrees of the lips, tongue tip and Iongue body.
The net constriction degree of the oral and nasal cavities together is simply the minimmn of the two component constriction degrees.
To re cast this in the present framework is straight\[orward.
However, we |teed lo first define the operations max and rain over pairs of naltlra\] 1111111bers: (13) obj MINMAX is protecting NAT . ops min max : Nat Nat -> Nat . rare M N : Nat . extending FEATS + MINMAX . op _!cd : Gesture -> Nat . ops clo crit narrow mid wide obs open : Gesture -> Bool . vat G : Gesture . vat N ~1 N2 : Nat . vars 0 : Oral . vars T : Tongue . eq N !cd = N, eq {N1,N2} !cd = max(N1,N2) . eq {T,N} !cd = max(T !cd,N) . eq {N1,N2,0} !cd ~ max(Nl,min(N2,0 !cd)) . eq clo(G) = S !cd == 4 . eq crit(G) = G !cd == 3 . eq narrow(G) = G !cd == 2 . eq mid(G) = G !cd == I . eq wide(G) = G !cd == O . eq obs(G) = G !cd > 2 . eq open(G) = G !cd < 3 . endo The specification CD allows classification into five basic constriction degrees (c'lo, crit, narrow, mid, and wide) by means of corresponding oneplace predicates, i.e. boolean-valued operations over gestures.
For example, the fifth equation above states that G has the constriction degree cto (i.e.
elm(G) is true)if and only if6 !cd == 4.
The working of these predicates is illustrated bel o w: (15) {3,0,{{4,1},1}} !oral !tongue !cd . ~4 {3,0,{{4,1},1}} !oral !cd ~4 {a,o,{14,~},1}} ~cd . ~3 mid({3,0,{{4,1},1}} !oral l~ial) . true wide({3,O,{{4,1},l}} !oral !labial) . false open({3,0,{{4,1},l}} \]oral !labial) . true cl0({3,0,{{4,1},1}} !oral !tongue) . true ACRES DE COLING-92.
NANTES, 23-28 AOt~'r 1992 1 5 5 PROC.
OF COLINGO2.
NANTES, Aua.
23-28, 1992 eq min(M,N) = if M <= N then M else N fi . eq max(M,N) = if M >= N then M else N fi . AcrEs DE COLING-92.
NANTEs, 23-28 ho~" 1992 1 5 4 PROC.
OF COLING-92, NAhn'ES, AUG.
23-28, 1992 References Beierb.
C. &: U.
Pletat (1988).
Feature Graphs and Abstract Data Types: A Unifying Apendo proach.
Proeeedin9.~ of the 12th lnteruational Conj,'fence on Compvtational Lin(14) obj CD is guistic,~, pp40 45, Budapest, Ilnngary.
Beierle, C.
& II.
Pletat (19881.
The Algebra of Feature GrNlh Specifications.
W¢~s lieport 94, IBM T11-80.89-029, InM Germany, Institute for Knowledge Based Syslems.
Stuttgart. Beierle, C., U.
Pletat & tI.
liszkoreit (1988).
Ale Algebraic Chara.cterization of s'ruF.
LILOG Report 40, IBM Germany, Stuttgart.
Bird, S.
(19901. Constraint-Based Phonology.
PhD Thesis.
University of I"dinburgh.
Bird, S.
~z 1';.
Klein (1090).
Phonological events.
Journal of Linguistics, 26, 3356.
Browman, C.
& L.
Goldstein (1989).
Articulatory gestures as llhonological units.
Phouof ogy, 6, 201-251.
Cardclli, L.
(19881 A Semantics of Multiple Inheritance.
Mformation and ('omputatiml.
76, 138 164.
Clements, G.N.
(19851 The Geometry of Phonological Features.
Phonolo:ly )?arl~'*ok.
2. 225 252.
D6rre, J.
& A.
Eisele(1991). A Coumrehensiw' Unification-Based Grammar Formalisln.
I)t,liverable R3.I.B.
DYANA r, Sl'RIT Basic liesearch Action BR3175, .January 1991.
Ehrig, tl.
& B.
Mahr (1985) l,}mdam~utal.~ of .,l/gebruic Spceificotiou 1: Equations aml lllilial Semauties, llerlin: Springer Vcrlag.
Goguen, J.A., & T.
Winkler (19SS) "lnfrodueing OB,I3'.
TechnicM Report SR14',SL-SS-9.
Sl/1 lntex'national, (:oinlluter Sciellre l,al)o ratory, Menlo Park, ('A.
Goguen,,I.A., J.W.
'l:h~tcher and E.G.
Wagner (19761 'An Initial Algebra Apl)roaeh to the Specification, Correctness and hnl)lementation of Abstracl l)ata Typ(,s'.
In R.
Yeh led).
(hwrent J)'ends in Programming Methodology II: 1)ata Structuring.
pp80 14,1.
Englewood ('lifts.
NJ : Prenfice llall.
flyman, L.
M. (198,1).
On the weightlessness of syllable onsets.
In Brugm~m & Macaulay (eds).
Proceedings of the Tenth Annual Meeting of the Berkeley Linguistics Society.
University of California., Berkeley.
I,\[asper, ll.
~ W.
llounds (19861.
A Logical Semantics for Feature Structures.
Proceedings of the 24th Anmwl Meeting of the ACL, Cohuntfia University, New York, NY, 1986, 11t1257 265.
Klein, E.
(1991), Phonological Data Types.
Ill Klein, E.
and F.
Veltlnan (eds) The Dynamics of lnteu,'ctatiou: Proceedings of a Symposium on Natural Language and Speech, BrusseLs, November 26/27, 1991.
Springer Verlag.
Newton, M.
(in prel)m'~tion ).
Grammars and Specification Languages.
PhD Thesis, ('entre for Cognitive Science, University of Edinbnrgh.
Real)e, M.
(1991). Fonnda.tions of L!nification ~ Based Grammar Formalism.
Deliverable \]~.%2..:k.
DYANA ESPRIT Basic \]l.eseareh Artion BR3175, .July 1991.
Rounds, WW.,k" A, Manaster-Ramer (1987).
A l,ogica~t Version of Functional Gr~unm~r.
Proce~.ding.," of 25th Ammal Meeting of the .,lssoeiatior~ for Computational Linguistics, 6 9,hdy 1987.
Stanford University, Stanford, ('A, 89 96.
Sagey, E.
(1!1861. 'l'he RepTr, sentation of Features a~d Relations ill Non-Linear Phonology.
Phi) Thesis.
MIT, Camhridge, Mass.
Salmella 1).
~: A.
Tarlecki (1987) Some thoughts m/ algebraic specilira,tion.
I,FCS Report Series I",CS 1,1;'C8-,~7-21, l,aboratory for Foun dations of Co\[llt)uler Science, University of Edillburgh.
Shieber, S.
(1986). A~ Introduction to Unification-Based Approaches to Grammmar.
CSI,I Lecture Note Series, University of Chicago Press, Chicago.
Smolka, C,.
and II.
Ai't-Kaci (19891 'Inheritance llierarchies: Semantics and Unifiea~lion'..Iour~lol of Symbolic ('omputation, 7, '3,t',1 370 .

