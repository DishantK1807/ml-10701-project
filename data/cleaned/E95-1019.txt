Higher-order Linear Logic Programming of Categorial Deduction Glyn Morrill Secci6 d'Intel.lig~ncia Artificial Departament de Llenguatges i Sistemes Inform~ttics Universitat Polit~cnica de Catalunya Pau Gargallo, 5 08028 Barcelona morrill@lsi.upc.es Abstract We show how categorial deduction can be implemented in higher-order (linear) logic programming, thereby realising parsing as deduction for the associative and non-associative Lambek calculi.
This provides a method of solution to the parsing problem of Lambek categorial grammar applicable to a variety of its extensions.
The present work deals with the parsing problem for Lambek calculus and its extensions as developed in, for example, Moortgat (1988), van Benthem (1991), Moortgat and Morrill (1991), Moortgat and Oehrle (1993), Morrill (1994b) and Hepple (1995).
Some previous approaches to parsing Lambek grammar such as KSnig (1989), Heppie (1990) and Hendriks (1993) have concentrated on the possibilities of sequent proof normalisation.
In P~oorda (1991), Moortgat (1992), Headriks (1993) and Oehrle (1994) a strategy of unfolding and labelling for proof net construction is considered.
We aim to show here how such unfolding allows compilation into programs executable by a version of SLD resolution, implementing categorial deduction in dynamic linear clauses.
The linearity resides in the use exactly once per word token of each of the clauses compiled from lexical categorisations.
By dynamic, it is meant that clauses may be higher-order (they are hereditary Harrop Horn clauses) so that clausal resolution involves insertion in, as well as retraction from, the resolution database; see Miller et al.(1991), and Hodas and Miller (1994).
It is shown how a range of calculi can be treated by dealing with the highest common factor of connectives as linear logical validity.
The prosodic (i.e.
sublinear) aspects of word order and hierarchical structure are encoded in labels, in effect the term structure of quantified linear logic.
Compiling labels according to interpretations in groupoids provides a general method for calculi with various structural properties and also for multimodal hybrid formulations.
Unification must be carried out according to the structural axioms but is limited to one-way matching, i.e. one term is always ground.
Furthermore, for the particular case of associative Lambek calculus an additional perspective of binary relational interpretation allows an especially efficient coding in which the span of expressions is represented in such a way as to avoid the computation of unifiers under associativity, and this can also be exploited for non-associative calculus.
Higher-order linear logic programming has already been applied to natural language processing in, for example, Hodas (1992) and Hodas and Miller (1994), in work deriving from Pareschi (1989) and Pareschi and Miller (1990).
What we show here is that such implementation can be realised systematically, indeed by a mechanical compilation, while grammars themselves are written in higher level categorial grammar formalism.
Automated deduction for Lambek calculi is of interest in its own right but solution of the parsing problem for categorial logic allowing significant linguistic coverage demands automated deduction for more than just individual calculi.
There is a need for methods applying to whole classes of systems in ways which are principled and powerful enough to support the further generalisations that grammar development will demand.
We aim to indicate here how higher-order logic programruing can provide for such a need.
After reviewing the "standard" approach, via sequent proof normalisation, we outline the relevant features of (linear) logic programming and explain compilation and execution for associative and non-associative calculi in terms of groupoid and binary relational interpretations of categorial connectives.
We go on to briefly mention multimodal calculi for the binary connectives.
The parsing problem is usually construed as the recovery of structural descriptions assigned to strings by a grammar.
In practice the interest is in computing semantic forms implicit in the structural descriptions, which are themselves usually implicit in the history of a derivation recognising well-formedness of a string.
This is true in particular of compositional categorial architec133 tures and we shall focus on algorithms for showing well-formedness.
The further step to computing semantics is unproblematic.
For the non-associative Lambek calculus NL of Lambek (1961) we assume types freely generated from a set of primitive types by binary (infix) operators \, / and o.
A sequent comprises a succedent type A and an antecedent configuration r which is a binary bracketed list of one or more types; we write F ::~ A.
The notation F(A) here refers to a configuration I" with a distinguished subconfiguration A.
a. A =~ a id F =~ A A(A) =,.
B (1),Cut ~(r) ~ B b.
F =~ A A(B) =~ C \[A, r\] ~ B \L \R z~(\[r, A\B\]) ~ c r =~ A\B c.
F =~ A A(B) ~ C \[r, A\] ~ B./L ./R &(\[B/A, r\]) ~ c r =* B/A d.
r(\[A, B\]) C r = A a B oL oR F(A.B) ~ C r, .A :, AoB For the associative Lambek calculus L of Lambek (1958) the types are the same.
A sequent comprises a succedent type A and an antecedent configuration F which is a list of one or more types; again we write F =~ A.
a. A ~ A id r =~ A A(A) =~ B (2) .Cut ~(r) ~ B b.
r~ A A(B)~C A,F~ B .\L \R A(r,A\B) =~ C F =, A\B C, r =~ A &(B) =*.
C F,A ~ B /L B/A/R A(B/A, r) ~ c r d.
F(A,B)=*C r ~ A A~ B â€¢ oL oR F(AeB) ~ C r, A ~ A*B Lambek showed Cut-elimination for both calculi, i.e. every theorem has a Cut-free proof.
Of the remaining rules each instance of premises has exactly one connective occurrence less than the corresponding conclusion so Cut-elimination shows decidability through finite space Cut-free sequent proof search from conclusions to premises.
Lifting is derivable in NL as follows: A ~ A B =~ B (3) \L \[A, A\B\] =~ B A # B/(A\B)/rt It is also derivable in L; indeed all NL derivations are converted to L derivations by simply erasing the brackets.
But L-derivable composition depends essentially on associativity and is not NL-derivable: B~B C~C \L A=~ A B,B\C=~ C \L A, A\B, B\C =~ C \R A\B, B\C =~ A\C (4) Even amongst the Cut-free proofs however there is still semantic equivalence under the CurryHoward rendering (van Benthem, 1983; see Morrill, 1994b) and in this respect redundancy in parsing as exhaustive proof search since distinct lines of inference converge on common subproblems.
This derivational equivalence (or: "spurious ambiguity") betrays the permutability of certain rule applications.
Thus two left rules may be permutable: N/CN, CN, N\S :=~ S can be proved by choosing to work on either connective first.
And left and right rules are permutable: N/CN, CN =:~ S/(N\S)) may be proved by applying a left rule first, or a right rule, (and the latter step then further admits the two options of the first example).
Such non-determinism is not significant semantically: the variants ha:ve the same readings; the non-determinism in partitioning by the binary left rules in L is semantically significant, but still a source of inefficiency in its backward chaining "generate-and-test" incarnation.
Another source of derivational equivalence is that a complex id axiom instance such as N\S =:~ N\S can be proved either by a direct matching against the axiom scheme, or by two rule applications.
This is easily solved by restricting id to atomic formulas.
More problematic are the permutability of rule applications, the non-determinism of rules requiring splitting of configurations in L, and the need in NL to hypothesise configuration structure a priori (such hierarchical structure is not given by the input to the parsing problem).
It seems that only the first of these difficulties can be overcome from a Gentzen sequent perspective.
The situation regarding equivalence and rule ordering is solved, at least for L-{*L}, by sequent proof normalisation (KSnig, 1989; Hepple, 1990; Hendriks, 1993): a.
\[-)-7 =*" A id* r,,\[-Y\],r~ ~ o (s) rl,A,r \[-B-\] p" A(r,~-~)~c \L" r~\R c.
r=~r ~ A(~-\])=~C r,A=~\[B\], R This involves firstly ordering right rules before left rules reading from endsequent to axiom leaves 134 (so left rules only apply to sequents with atomic succedents; this effects uniform proof; see Miller et al., 1991), and secondly further demanding successive unfolding of the same configuration type ("focusing").
In the *-ed rules the succedent is atomic.
A necessary condition for success is that an antecedent type is only selected by P* if it yields the succedent atom as its eventual range.
Let us refer to (5) as \[-L-\].
\[~\] is free of spurious ambiguity, and I-r.
F ::~ A iff I-\[-~ F ::~ I-A-\].
The focusing strategy breaks down t.....-I for .L: (VP/PP)/N, N.PP =~ VP requires switching between configuration types.
It happens that left occurrences of product are not motivated in grammar, but more critically sequent proof normalisation leaves the non-determinism of partitioning, and offers no general method for multimodal extensions which may have complex and interacting structural properties.
To eliminate the splitting problem we need some kind of representation of configurations such that the domain of functors need not be hypothesised and then checked, but rather discovered by constraint propagation.
Such is the character of our trea.tment, whereby partitioning is explored by unification in the term structure of higher-order linear logic piogramming, to which we now turn.
By way of orientation we review the (propositional) features of clausal programming.
The first order case, naturally, corresponds to Prolog.
Let us assume a set ATO./t4 of atomic formulas, 0-ary, 1-ary, etc., formula constructors {' A...
A "}hEO,1,.,,} and a binary (infix) formula constructor,--.
A sequent comprises an agenda forlnula A and a database F which is a bag of program clauses {B1,..., B,}m,n > 0 (subscript m for multiset); we write F =:~ A.
In BNF, the set of agendas corresponding to the nonterminal AGÂ£.AfT)A and the set of program clauses corresponding to the nonterminal T'CÂ£S are defined by: AGÂ£.N'I)A ::= GOAÂ£ A ...
A gOAÂ£ PCÂ£S ::= ATOM *-AGÂ£AfDA (6) For first order programlning the set CjO.AÂ£ of goals is defined by: Â¢OAÂ£ ::= ATOM (7) Then execution is guided by the following rules.
F, A :0 A ax (8) I.e. the unit agenda is a consequence of any database containing its atomic clause.
F,A ~ B1 A...ABn =Â¢" B1 A . . . A BnA (9) C~ A...A Cm .RES F,A,--B1 A...AB, ~ AAC1 A...
ACre I.e. we can resolve the first goal on the agenda with the head of a program clause and then continue with the program as before and a new agenda given by prefixing the program clause subagenda to the rest of the original agenda (depth-first search).
For the higher-order case agendas and program clauses are defined as above, but the notion of GOAÂ£ on which they depend is generalised to include implications: GOAÂ£ ::= ATOM \[ ~OAÂ£,pcÂ£s (lO) And a "deduction theorem" rule of inference is added: F,B ~ A F =v (71 A...
A C,, (11) DT r ==~ (A *-B) AC~ A...ACm I.e. we solve a higher-order goal first on the agenda by adding its precondition to the database and trying to prove its postcondition.
In linear logic programming the rules become resource conscious; in this context we write Â® for the conjunction and ofor the implication: A =Â¢.
A ax (12) I.e. an atomic agenda is a consequence of its unit database: all program clauses must be "used up" by the resolution rule: F =v B1 Â® ...
Â®B,Â®C1 Â® ...
Â®C,,, (13) .RES F, Ao--B1 @ ...
Â®B,, =~ AÂ®C1 Â® ...
Â®Cm I.e. a program clause disappears from the database once it is resolved upon: each is used exactly once.
The deduction theorem rule for higher-order clauses also becomes sensitised to the employment of antecedent contexts: F,B ~ A A ~ CI@...Â®Cm (14) DT F, A ~ (A oB)Â®C~ Â® ...
NCm We shall motivate compilation into linear clauses directly from simple algebraic models for the calculi.
In the case of L we have first interpretation in semigroups (L, +) (i.e.
sets L closed under associative binary operations +; intuitively: strings under concatenation).
Relative to a model each type A has an interpretation as a subset D(A) of L.
Given that primitive types are interpreted as some such subsets, complex types receive their denotations by residualion as follows (cf.
e.g. Lambek, 1988): D(A.B) = {s~+s2\]sl E D(A) As2 E D(B)} (15) D(A\B) = {,IW'e D(A),s'+s E D(B)} D(B/A) = (slW' e D(A),s+s' E D(B)} For the non-associative calculus we drop the condition of associativity and interpret in arbitrary 135 groupoids (intuitively: trees under adjunctionl).
Categorial type assignment statements comprise a term ~ and a type A; we write a: A.
Given a set of lexical assignments, a phrasal assignment is projected if and only if in every model satisfying the lexical assignments the phrasal assignment is also satisfied.
A categorial sequent has a translation given by \[ â€¢ I into a linear sequent of type assignments which can be safely read as predications.
For L we have the following (NL preserves input antecedent configuration in output succedent term structure): IB0,..., B.
~ A I = (16) k0:B0 + ..... k,: B~ + =~ k0+...+k,,: ACategorial type assigmnent statements are translated into linear logic according to the interpretation of types.
The polar translation functions are identity functions on atomic assignments; on complex category predicates they are defined mutually as follows (for related unfolding, but for proof nets, see Roorda, 1991; Moortgat, 1992; Hendriks, 1993; and Oehrle, 1994); ~ indicates the polarity complementary to p: a+7: B p oo~: A "~ (17) a new variable/ ~: AkB p constant as p -'1-/-7+a: B p oa: A ~ c~ new variable/ ./: B/A p constant as p +/Tile unfolding transformations have the same general form for the positive (configuration/database) and negative (succedent/agenda) occurrences; the polarity is used to indicate whether new symbols introduced for quantified variables in the interpretation clauses are metavariables (in italics) or Skolem constants (in boldface); we shall see examples shortly.
The program clauses and agenda are read directly off the unfoldings, with the only manipulation being a flattening of positive ilnplications into uncurried forln: ((x+ o-Y1-)o ...)o-Y,7 ~> (18) X + oYlÂ® ...
Â® YÂ£ (This means that matching against the head of a clause and assembly of subgoals does not require any recursion or restructuring at runtilne).
We shall also allow unit program clauses X o-to be abbreviated X.
Starting froln the initial database and agenda, a proof will be represented as a list of agendas, avoiding the context repetition of sequent proofs by indicating where the resolution rule retracts from the database (superscript coindexed overline), and where the deduction theorem rule adds to it (subscript coindexation): 1Though NL with product is incomplete with respect to finite trees as opposed to groupoids in general.
database F, A oB1 Â® ...
Â® Bn "i (19) agenda i.
AÂ®C1 Â® ...
Â®C,~ RES i+I.
BI Â® ...
Â® B,, Â® Cx Â® ...
Â® C,n database r, Bi (20) agenda i.
(AoB)Â®CI Â® ...
Â®C,,~ DT i+1.
AÂ®CI Â® ...
Â®C,n The sharing of a Skolem constant between A and B in (20) ensures that B can and must be used to prove A so that a mechanism for the lazy splitting of contexts is effected.
The termination condition is met by a unit agenda with its unit database.
By way of illustration for L consider composition given the sequent translation (21).
IA\B, B\C ~ A\CI= (21) k: AkB +, l: B\C + ~ k+l: AkCThe a~ssignments are unfolded thus: a+k: B oa: A b+l: C ob: B(22) k: AkB + 1: BkC + m+(k+l): C om: A k+l: AkCThen tile proof runs as follows.
database a+k: B oa: A ~, (23) b+l: Co-b: B ~, In: A14 agenda 1.
m+(k+l): C om: A DT 2.
m+(k+l): C RES b = m+k 3.
re+k: B RES a = m 4.
m: A RES Tile unification at lille 2 relies on associativity.
Note that unifications are all one-way, but even one-way associative (=string) unification has expensive worst cases.
For NL the term labelling provides a clausal implementation with unification being nonassociative.
Consider lifting: IA ~ B/(A\B)I = k: A ~ k: B/(A\B) a+l: B oa: A k+l: B o-1: A\B + k: B/(AkB)The proof is as follows.
database (24) (25) k: A 3, (26) a+l: B o-a: A1 ~ agenda 1.
k+l: B o(a+l: B oa: A) DT 2.
k+l: B RES a = k 3.
k: A RES 136 The simple one-way term unification is very fast but it is unnatural from the point of view of parsing that, as for the sequent approach, a hierarchical binary structure on the input string needs to be posited before inference begins, and exhaustive search would require all possibilities to be tried.
Later we shall see how hierarchical structure can be discovered rather than conjectured by factoring out horizontal structure.
Let us note here the relation to --\[~.
\[~\] applies (working back fl'om the target sequent) right rules before left rules.
Here, when a higher-order goal is found on the agenda its precondition is added to the database by DT.
This precedes applications of the RES rule (hence the uniformity character) which corresponds to the left sequent inferences.
It applies when the agenda goal is atomic and picks out antecedent types which yields that atom (cf.
the eventual range condition of \[~\]).
Tile focusing character is eml)odied by creating in one step the objective of seeking all the arguments of all uncurried functor.
By way of further example consider the following in L, with terms and types as indicated.
(a book from which) the references are missing (27) the references are missing (28) r: N m: ((S/(NkS))kS)/PP => r+m: S/PP We have cornpilation for 'are missing' as in Figure 1 yielding (29).
I> (29) b+(m+a): So--(b+k: So-(c+k: So--c: N))Â®a: PP And the succedent unfolds as follows: (r+m)+l: S o-1: PP (30) r+m: S/PPI> (r+m)+l: S o1: PP Derivation is as in figure 2.
The unification at line 2 relies on associativity and as always atomic goals on the agenda are ground.
But in general we have to try subproofs for different unifiers, that is, we effectively still have to guess partitioning for left rules.
We shall see that this is not necessary, and that associative unification can be avoided.
There is a further problem which will be solved in the same move.
Unfolding of left products would create two positive subfonnulas and thus fall outside the scope of Horn clause programming.
However, the term-labelled implementation as it has been given also fails for right products: a: AÂ® fl: B(31) 7: A,BI = c~+fl?
The problem is that c~ and fl are not deterministically given by 7 at the "compile time" of unfolding.
The best we could manage seems to be to try different partitionings of 7 at execution time; but even if this could work it would still amount to trying different partitionings for *R as in the sequent calculus: a source of non-determinism we seek to reduce.
This limitation combines with the other difficulties with groupoid labelling of worst case of (even) one-way associative unification for L, and the need for a priori hypothesis of nonassociative structure for NL.
The method of solution resides in looking at an alternative model: the associative calculus has relational algebraic models (van Benthem, 1991) which interpret types as relations on some set V, i.e. as sets of ordered pairs.
Given denotations for primitive types, those of compound types are fixed as subsets of V x V by: D(AkB) = {(v2,v3)lV(vl,v2) E D(A), (32) (v,, v3) E D(B)} D(B/A) = {(vi,v:)lV(v2, v3) E D(A), (v,, v3) C D(B)} D(A.B) = {(v1,va)13v2,@1,v2) E D(A) & (v~, va) E D(B)} Points in V intuitively corresponds to string positions (as in definite clause grammars, and charts) and ordered pairs to the vertices of substrings pertaining to the categories to which they are assigned.
This induces unfolding as follows: i k: B p o-i j: A ~ i new variable/ (33) j k: A\B p constant as p +/-ik: B p o-jk: A ~ k new variable/ i -.j: B/A p constant as p +/Furthermore right product (though still not nonHorn left product) unfolding can be expressed: i j: AÂ® j k: B(34) .j new variable i k: A,BComposition is now treated as follows.
Assume sequent translation thus: \]A\B, B\C ::v A\CI = (35) 01: A\B +, 1-2: BkC + => 02: A\CThe assignments are compiled as shown in (36).
i 1: B o-i 0: A (36) 0 1: A\B + j-2: C oj1: B 3-2: C o3-0: A 1 2: BkC + 0 2: AkCThe proof is thus: 137 b-t-(nl+a): S c+k: S o-b+k: S ok: N\S + ob: S/(N\S)c: N rata: (S/(N\S))\S + oa: PP Figure 1: database agenda 1.
2. 3.
4. 5.
6. Figure m: ((S/(N\S))\S)/PP + Groupoid compilation of the assignment to 'are missing' r: --~5 2 b+(m+a): S o-(b+k: S o(c+k: S o-c: N)) Â® a: PP 1:PP1 ~, c+k: So-c: Na 4, (r+m)+l: S o1: PP DT (r+m)+l: S RES b=r, a=l (r+k: S o(c+k: So-c: N))Â®I: PP DT r+k: S Â® 1: PP RES c=r r:NÂ®I:PP RES l: PP RES 2: Groupoid execution for 'the references are missing' database i 1: Bo-i 0: A 3, (37) j2: Co-j1: B 2, 3 O: Al 4 agenda 1.
3-2: Co-3-0: A DT 2.
3-2: C RESj=3 3.
31: B RESi=3 4.
3 0: A RES In this way associative unification is avoided; indeed the only matching is trivial unification between constants and variables.
So for L the relational compilation allows partitioning by the binary rules to be discovered by simple constraint propagation rather than by the generate-and-test strategy of normalised sequent proof.
Although the (one-way) term unification for groupoid compilation of the non-associative calculus is very fast we want to get round the fact that a hierarchical binary structure on the input string needs to be posited before inference begins.
We can do this through observation of the following: â€¢ All non-associative theorelns are associative theorems (ignore brackets) â€¢ Interpret non-associative operators in the product algebra of NL groupoid algebra and L relational algebra, and perform labelled compilation accordingly â€¢ Use the (efficient) relational labelling to check associative validity â€¢ Use the groupoid labelling to check nonassociative validity and compute the prosodic form induced I.e. the endsequent succedent groupoid term can be left as a variable and the groupoid unification performed on the return trip from axiom leaves after associative validity has been assured, as will be seen in our final example.
The groupoid unification will now be one-way in the opposite direction.
The simultaneous compilation separates horizontal structure (word order) represented by interval segments, and horizontal-and-vertical structure (linear and hierarchical organisation) represented by groupoid terms, and uses the efficient segment labelling to compute L-validity, and then the term labelling both to check the stricter NLvalidity, and to calculate the hierarchical structure.
In this way we use the fact that models for NL are given by intersection in the product of rela.tional and groupoid models.
Each type A has an interpretation D(A) as a subset of L x V x V: D(A\B) = {(s,v~,v3)lV(s',vl,V~) â€¢ D(A), (38) (s'+s, vl, v3) â€¢ D(B)} D(B/A) = {/s,vl,v2)lV(s',v2,v3) â€¢ D(A), (s+s', vl, v3) â€¢ D(B)} D(d.B) = {(s~+s2,v~,v3)lgv2,(s~,v~,v2) â€¢ D(A) & (s2, v~, v3) â€¢ D(B)} Unfolding is thus: ~r+7-i-k: B p oo~-i-j: A F 7-j-k: A\B p (39) c~, i new variables/ constants as p 4-/-7+a'-i-k: B p (>c~-j-k: A "~ 7-i-j: B/A p ~, k new variables/ constants as p +/ol-i-j: AÂ® \[3-j-k: Ba, B, j new variables ot+B-i k: AoB138 b+(m+a)-i-kl: S c+k-l-4: S oc-l-l: N b+k-i-4: S ok-l-4: NkS + O-b-i-l: S/(N\S)n!+al-k1: (S/(N\S))\S + oa-2-kl : PP m-l-2: ((S/(N\S))\S)/PP + Figure 3: Groupoid-relational compilation of the assignment to 'are missing' database r-0-1: N 4, b+(m+a)-i-kl: S o-(b+k-i-4: S o(c+k-l-4: S oc-l-l: N)) Â® a-2-k~ : ppX, c+k-/-4: So-c-l-l: N2 3, f-2-3:pp5 agenda 1.
d-0-3: S RES d = b+(m+a) 2.
(b-Fk-0-4: S a-(c+k-/-4: So-c-l-l: N))Â®a-2-3: PP DT 3.
b+k-0-4: S Â® a-2-3: PP RES b = c 4.
c-0-1: NÂ®a-2-3: PP RES c=r 5.
a-2-3: PP RES a = f Figure 4: Groupoid-relational execution for 'the references are missing from this book' By way of example consider tile following: the references are missing r-O-l: N m-l-2: ((S/(N\S))\S)/PP ~+,7: B p oa: A F a new variable/ (40) 7: A\iBP constant as p +/-7+icr: B p oo~: A F a new variable/ 7:B/iA p constant as p +/-from this book f-2-3: PP =v d-0-3: S Tile unfolding compilation yielding (41) for 'are missing' is given in Figure 3.
I> (41) b+(m+a)-i-kl : S o(b+k-i-4: S o(c+k-l-4: So--c-l-l: N))Â®a-2-kl: PP Tile derivation is given in Figure 4.
Note how the term unification computing the hierarchical structure can be carried out one-way in the reverse order to the forward seglnent matchings: d = b+(m+a) = c+(m+a) = r+(m+a) = (42) r+(m+f) In the case of NL-invalidity tile term unification would fail.
We lnention finally lnultimodal generalisations.
In multimodal calculi families of connectives {/i, \i, *i}ie1 ......
} are each defined by residuation with respect to their adjunction in a "polygroupoid" (L, {+i}ie\] ..... n}) (Moortgat and Morrill, 1991): D(AtiB) = {s,+is2\]s, E D(A)As2 E D(B)}(43) D(A\,B) = {sirs' ~ D(A),s'+,s E D(B)} D(B/,A) = {s\[Vs' E n(A),s+,s' E D(B)} Multimodal groupoid compilation for ilnplications is immediate: (44) This is entirely general.
Any multimodal calculus can be implemented this way provided we have a (one-way) unification algorithm specialised according to the structural communication axioms.
For example Morrill (1993) deals with multimodality for discontinuity which involves varying internal structural properties (associativity vs.
non-associativity) as well as "split/wrap" interaction between modes.
This is treated computationally in tile current manner in Morrill (19941) which also considers head-oriented discontinuity and unary operators projecting bracketed string structure.
Ill these cases also simultaneous compilation including binary relational labelling can provide additional advantages.
Labelled unfolding of categorial formulas has been invoked ill the references cited as a way of checking well-formedness of proof nets for categorial calculi by unification of labels on linked formulas.
This offers improvements over sequent formulations but raises alternative problems; for example associative unification in general can have infinite solutions and is undecidable.
Taking linear validity as the highest common factor of sublinear categorial calculi we have been able to show a strategy based on resolution in which the flow of information is such that one term in unification is always ground.
Furthermore binary relational labelling propagates constraints in such a way that 139 computation of unifiers may be reduced to a subset of cases or avoided altogether.
Higher-order coding allows emission of hypotheticals to be postponed until they are germane.
Simultaneous compilation allows a factoring out of horizontal structure from vertical structure within the sublinear space in such a way that the partial information of word order can drive computation of hierarchical structure for the categorial parsing problem in the presence of non-associativity.
The treatments for the calculi above and their multimodal generalisations have been implemented in Prolog (Morrill, 1994a).
References van Benthem, Johan: 1983, 'The Semantics of Variety in Categorial Grammar', l~eport 83-29, Department of Mathenlatics, Simon Fraser University, also in Buszkowski, W., W.
Marciszewski, and J.
van Benthem (eds.): 1988, Calegorial Grammar, Linguistic & Literary Studies in Eastern Europe Volume 25, John Benjamins, Amsterdam, 37-55.
van Benthem, J.: 1991, Language in Action: Categories, Lambdas and Dynamic Logic, Studies in Logic and the Foundations of Mathematics Volume 130, North-Holland, Amsterdam.
Hendriks, Herman: 1993, Studied Flexibility: Categories and Types in Syntax and Semantics, Ph.D dissertat.ion, Institute for Logic, Language and Computation, Universiteit van Amsterdam.
Hepple, Mark: 1990, The Grammar and Processing of Order and Dependency: A Categorial Approach, Ph.D. dissertation, University of Edinburgh.
Hepple, Mark: 1995, 'Mixing Modes of Linguistic Description in Categorial Grammar', this volulne.
Hodas, J.: 1992, 'Specifying Filler-Gap Dependency Parsers in a Linear-Logic Programming Language', in Proceedings of the Joint I~lternational Conference and Symposium on Logic Programming, 622-636.
Hodas, Joshua and Dale Miller: 1994, 'Logic Progrannning in a Fragment of Intuitionistic Linear Logic', to appear in Journal of IT~formation and Computation.
Kgnig, E.: 1989, 'Parsing as natural deduction', in Proceedings of the Annual Meeting of the Association for Computational Linguistics, Vancouver.
Lambek, J.: 1958, 'The mathematics of sentence structure', American Mathematical Monthly 65, 154-170, also in Buszkowski, W., W.
Marciszewski, and J.
van Benthem (eds.): 1988, Categorial Grammar, Linguistic & Literary Studies ill Eastern Europe Volume 25, John Benjamins, Amsterdam, 153-172.
Lambek, J.: 1961, 'On the calculus of syntactic types', in R.
Jakobson (ed).
Structure of language and its mathematical aspects, Proceedings of the Symposia in Applied Mathematics XII, American Mathematical Society, 166-178.
Lambek, J.: 1988, 'Categorial and Categorical Grammars', in Richard T.
Oehrle, Emmon Bach, and Deidre Wheeler (eds).
Categorial Grammars and Natural Language Structures, Studies in Linguistics and Philosophy Volume 32, D.
Reidel, Dordrecht, 297-317.
Miller, D., G.
Nadathur, F.
Pfenning, and A.
Scedrov: 1991, 'Uniform Proofs as a Foundation for Logic Programming', Annals of Pure and Applied Logic 51, 125-157.
Moortgat, Michael: 1988, Categorial Investigations: Logical and Linguistic Aspects of the Lambek Calculus, Forts, Dordrecht.
Moortgat, Michael: 1992, 'Labelled Deductive Systems for categoriat theorem proving', OTS Working Paper OTS-WP-CL-92-003, Rijksuniversiteit Utrecht, also in Proceedings of the Eighth Amsterdam Colloquium, Institute for Language, Logic and Information, Universiteit van Amsterdam.
Moortgat, Michael and Glyn Morrill: 1991, 'Ileads and Phrases: Type Calculus for Dependency and Constituent Structure', to appear in Journal of Language, Logic, and Information.
Moortgat, Michael and Dick Oehrle: 1994, 'Adjacency, dependency and order', in Proceedings of the Ninth Amsterdam Colloquium, 447-466.
Morrill, Glyn: 1993, Discontinuity and PiedPiping in Categorial Grammar, Report de Recerca LSI-93-18-R, Departament de Llenguatges i Sistemes Inform~tics, Universitat Polit~cnica de Catalunya, to appear in Linguistics and Philosophy.
Morrill, Glyn: 1994a, 'Higher-Order Linear Logic Programming of Categorial Deduction', Report de Recerca LSI-94-42-R, Departament de Llenguatges i Sistemes InformÂ£tics, Universitat Polit~cnica de Catalunya Morrill, Glyn: 1994b, Type Logical Grammar: Categorial Logic of Sig~s, Kluwer Academic Publishers, Dordrecht.
Oehrle, Dick: 1994, 'Term labelled categorial type systems', to appear in Linguistics and Philosophy.
Pareschi, R.: 1989, Type-driven Natural Language Analysis, Ph.D. thesis, University of Edinburgh.
Pareschi, R.
and D, Miller: 1990, 'Extending Definite Clause Grammars with Scoping Constructs', in D.H.D.
Warren and P.
Szeredi (eds).
1990 International Conference in Logic Programruing, MIT Press, 373-389.
Roorda, Dirk: 1991, Resource Logics: prooftheoretical investigations, Ph.D. dissertation, Universiteit van Amsterdam. 140

